// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: session_specifics.proto

package org.chromium.components.sync.protocol;

/**
 * Protobuf type {@code sync_pb.TabNavigation}
 */
public  final class TabNavigation extends
    com.google.protobuf.GeneratedMessageLite<
        TabNavigation, TabNavigation.Builder> implements
    // @@protoc_insertion_point(message_implements:sync_pb.TabNavigation)
    TabNavigationOrBuilder {
  private TabNavigation() {
    virtualUrl_ = "";
    referrer_ = "";
    title_ = "";
    redirectType_ = 1;
    searchTerms_ = "";
    faviconUrl_ = "";
    blockedState_ = 1;
    contentPackCategories_ = com.google.protobuf.GeneratedMessageLite.emptyProtobufList();
    navigationRedirect_ = emptyProtobufList();
    lastNavigationRedirectUrl_ = "";
    correctReferrerPolicy_ = 1;
    ancestorTaskId_ = emptyLongList();
    pageLanguage_ = "";
  }
  /**
   * Protobuf enum {@code sync_pb.TabNavigation.BlockedState}
   */
  public enum BlockedState
      implements com.google.protobuf.Internal.EnumLite {
    /**
     * <code>STATE_ALLOWED = 1;</code>
     */
    STATE_ALLOWED(1),
    /**
     * <code>STATE_BLOCKED = 2;</code>
     */
    STATE_BLOCKED(2),
    ;

    /**
     * <code>STATE_ALLOWED = 1;</code>
     */
    public static final int STATE_ALLOWED_VALUE = 1;
    /**
     * <code>STATE_BLOCKED = 2;</code>
     */
    public static final int STATE_BLOCKED_VALUE = 2;


    public final int getNumber() {
      return value;
    }

    /**
     * @deprecated Use {@link #forNumber(int)} instead.
     */
    @java.lang.Deprecated
    public static BlockedState valueOf(int value) {
      return forNumber(value);
    }

    public static BlockedState forNumber(int value) {
      switch (value) {
        case 1: return STATE_ALLOWED;
        case 2: return STATE_BLOCKED;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<BlockedState>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static final com.google.protobuf.Internal.EnumLiteMap<
        BlockedState> internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<BlockedState>() {
            public BlockedState findValueByNumber(int number) {
              return BlockedState.forNumber(number);
            }
          };

    private final int value;

    private BlockedState(int value) {
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:sync_pb.TabNavigation.BlockedState)
  }

  /**
   * Protobuf enum {@code sync_pb.TabNavigation.PasswordState}
   */
  public enum PasswordState
      implements com.google.protobuf.Internal.EnumLite {
    /**
     * <code>PASSWORD_STATE_UNKNOWN = 0;</code>
     */
    PASSWORD_STATE_UNKNOWN(0),
    /**
     * <code>NO_PASSWORD_FIELD = 1;</code>
     */
    NO_PASSWORD_FIELD(1),
    /**
     * <code>HAS_PASSWORD_FIELD = 2;</code>
     */
    HAS_PASSWORD_FIELD(2),
    ;

    /**
     * <code>PASSWORD_STATE_UNKNOWN = 0;</code>
     */
    public static final int PASSWORD_STATE_UNKNOWN_VALUE = 0;
    /**
     * <code>NO_PASSWORD_FIELD = 1;</code>
     */
    public static final int NO_PASSWORD_FIELD_VALUE = 1;
    /**
     * <code>HAS_PASSWORD_FIELD = 2;</code>
     */
    public static final int HAS_PASSWORD_FIELD_VALUE = 2;


    public final int getNumber() {
      return value;
    }

    /**
     * @deprecated Use {@link #forNumber(int)} instead.
     */
    @java.lang.Deprecated
    public static PasswordState valueOf(int value) {
      return forNumber(value);
    }

    public static PasswordState forNumber(int value) {
      switch (value) {
        case 0: return PASSWORD_STATE_UNKNOWN;
        case 1: return NO_PASSWORD_FIELD;
        case 2: return HAS_PASSWORD_FIELD;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<PasswordState>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static final com.google.protobuf.Internal.EnumLiteMap<
        PasswordState> internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<PasswordState>() {
            public PasswordState findValueByNumber(int number) {
              return PasswordState.forNumber(number);
            }
          };

    private final int value;

    private PasswordState(int value) {
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:sync_pb.TabNavigation.PasswordState)
  }

  private int bitField0_;
  public static final int VIRTUAL_URL_FIELD_NUMBER = 2;
  private java.lang.String virtualUrl_;
  /**
   * <pre>
   * The index in the NavigationController. If this is -1, it means this
   * TabNavigation is bogus.
   * optional int32 index = 1 [default = -1];  // obsolete.
   * The virtual URL, when nonempty, will override the actual URL of the page
   * when we display it to the user.
   * </pre>
   *
   * <code>optional string virtual_url = 2;</code>
   */
  public boolean hasVirtualUrl() {
    return ((bitField0_ & 0x00000001) == 0x00000001);
  }
  /**
   * <pre>
   * The index in the NavigationController. If this is -1, it means this
   * TabNavigation is bogus.
   * optional int32 index = 1 [default = -1];  // obsolete.
   * The virtual URL, when nonempty, will override the actual URL of the page
   * when we display it to the user.
   * </pre>
   *
   * <code>optional string virtual_url = 2;</code>
   */
  public java.lang.String getVirtualUrl() {
    return virtualUrl_;
  }
  /**
   * <pre>
   * The index in the NavigationController. If this is -1, it means this
   * TabNavigation is bogus.
   * optional int32 index = 1 [default = -1];  // obsolete.
   * The virtual URL, when nonempty, will override the actual URL of the page
   * when we display it to the user.
   * </pre>
   *
   * <code>optional string virtual_url = 2;</code>
   */
  public com.google.protobuf.ByteString
      getVirtualUrlBytes() {
    return com.google.protobuf.ByteString.copyFromUtf8(virtualUrl_);
  }
  /**
   * <pre>
   * The index in the NavigationController. If this is -1, it means this
   * TabNavigation is bogus.
   * optional int32 index = 1 [default = -1];  // obsolete.
   * The virtual URL, when nonempty, will override the actual URL of the page
   * when we display it to the user.
   * </pre>
   *
   * <code>optional string virtual_url = 2;</code>
   */
  private void setVirtualUrl(
      java.lang.String value) {
    if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000001;
    virtualUrl_ = value;
  }
  /**
   * <pre>
   * The index in the NavigationController. If this is -1, it means this
   * TabNavigation is bogus.
   * optional int32 index = 1 [default = -1];  // obsolete.
   * The virtual URL, when nonempty, will override the actual URL of the page
   * when we display it to the user.
   * </pre>
   *
   * <code>optional string virtual_url = 2;</code>
   */
  private void clearVirtualUrl() {
    bitField0_ = (bitField0_ & ~0x00000001);
    virtualUrl_ = getDefaultInstance().getVirtualUrl();
  }
  /**
   * <pre>
   * The index in the NavigationController. If this is -1, it means this
   * TabNavigation is bogus.
   * optional int32 index = 1 [default = -1];  // obsolete.
   * The virtual URL, when nonempty, will override the actual URL of the page
   * when we display it to the user.
   * </pre>
   *
   * <code>optional string virtual_url = 2;</code>
   */
  private void setVirtualUrlBytes(
      com.google.protobuf.ByteString value) {
    if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000001;
    virtualUrl_ = value.toStringUtf8();
  }

  public static final int REFERRER_FIELD_NUMBER = 3;
  private java.lang.String referrer_;
  /**
   * <pre>
   * The referring URL, which can be empty.
   * </pre>
   *
   * <code>optional string referrer = 3;</code>
   */
  public boolean hasReferrer() {
    return ((bitField0_ & 0x00000002) == 0x00000002);
  }
  /**
   * <pre>
   * The referring URL, which can be empty.
   * </pre>
   *
   * <code>optional string referrer = 3;</code>
   */
  public java.lang.String getReferrer() {
    return referrer_;
  }
  /**
   * <pre>
   * The referring URL, which can be empty.
   * </pre>
   *
   * <code>optional string referrer = 3;</code>
   */
  public com.google.protobuf.ByteString
      getReferrerBytes() {
    return com.google.protobuf.ByteString.copyFromUtf8(referrer_);
  }
  /**
   * <pre>
   * The referring URL, which can be empty.
   * </pre>
   *
   * <code>optional string referrer = 3;</code>
   */
  private void setReferrer(
      java.lang.String value) {
    if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000002;
    referrer_ = value;
  }
  /**
   * <pre>
   * The referring URL, which can be empty.
   * </pre>
   *
   * <code>optional string referrer = 3;</code>
   */
  private void clearReferrer() {
    bitField0_ = (bitField0_ & ~0x00000002);
    referrer_ = getDefaultInstance().getReferrer();
  }
  /**
   * <pre>
   * The referring URL, which can be empty.
   * </pre>
   *
   * <code>optional string referrer = 3;</code>
   */
  private void setReferrerBytes(
      com.google.protobuf.ByteString value) {
    if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000002;
    referrer_ = value.toStringUtf8();
  }

  public static final int TITLE_FIELD_NUMBER = 4;
  private java.lang.String title_;
  /**
   * <pre>
   * The title of the page.
   * </pre>
   *
   * <code>optional string title = 4;</code>
   */
  public boolean hasTitle() {
    return ((bitField0_ & 0x00000004) == 0x00000004);
  }
  /**
   * <pre>
   * The title of the page.
   * </pre>
   *
   * <code>optional string title = 4;</code>
   */
  public java.lang.String getTitle() {
    return title_;
  }
  /**
   * <pre>
   * The title of the page.
   * </pre>
   *
   * <code>optional string title = 4;</code>
   */
  public com.google.protobuf.ByteString
      getTitleBytes() {
    return com.google.protobuf.ByteString.copyFromUtf8(title_);
  }
  /**
   * <pre>
   * The title of the page.
   * </pre>
   *
   * <code>optional string title = 4;</code>
   */
  private void setTitle(
      java.lang.String value) {
    if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000004;
    title_ = value;
  }
  /**
   * <pre>
   * The title of the page.
   * </pre>
   *
   * <code>optional string title = 4;</code>
   */
  private void clearTitle() {
    bitField0_ = (bitField0_ & ~0x00000004);
    title_ = getDefaultInstance().getTitle();
  }
  /**
   * <pre>
   * The title of the page.
   * </pre>
   *
   * <code>optional string title = 4;</code>
   */
  private void setTitleBytes(
      com.google.protobuf.ByteString value) {
    if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000004;
    title_ = value.toStringUtf8();
  }

  public static final int PAGE_TRANSITION_FIELD_NUMBER = 6;
  private int pageTransition_;
  /**
   * <pre>
   * Content state is an opaque blob created by WebKit that represents the
   * state of the page. This includes form entries and scroll position for each
   * frame.
   * optional string state = 5;  // obsolete.
   * The core transition type.
   * </pre>
   *
   * <code>optional .sync_pb.SyncEnums.PageTransition page_transition = 6 [default = LINK];</code>
   */
  public boolean hasPageTransition() {
    return ((bitField0_ & 0x00000008) == 0x00000008);
  }
  /**
   * <pre>
   * Content state is an opaque blob created by WebKit that represents the
   * state of the page. This includes form entries and scroll position for each
   * frame.
   * optional string state = 5;  // obsolete.
   * The core transition type.
   * </pre>
   *
   * <code>optional .sync_pb.SyncEnums.PageTransition page_transition = 6 [default = LINK];</code>
   */
  public org.chromium.components.sync.protocol.SyncEnums.PageTransition getPageTransition() {
    org.chromium.components.sync.protocol.SyncEnums.PageTransition result = org.chromium.components.sync.protocol.SyncEnums.PageTransition.forNumber(pageTransition_);
    return result == null ? org.chromium.components.sync.protocol.SyncEnums.PageTransition.LINK : result;
  }
  /**
   * <pre>
   * Content state is an opaque blob created by WebKit that represents the
   * state of the page. This includes form entries and scroll position for each
   * frame.
   * optional string state = 5;  // obsolete.
   * The core transition type.
   * </pre>
   *
   * <code>optional .sync_pb.SyncEnums.PageTransition page_transition = 6 [default = LINK];</code>
   */
  private void setPageTransition(org.chromium.components.sync.protocol.SyncEnums.PageTransition value) {
    if (value == null) {
      throw new NullPointerException();
    }
    bitField0_ |= 0x00000008;
    pageTransition_ = value.getNumber();
  }
  /**
   * <pre>
   * Content state is an opaque blob created by WebKit that represents the
   * state of the page. This includes form entries and scroll position for each
   * frame.
   * optional string state = 5;  // obsolete.
   * The core transition type.
   * </pre>
   *
   * <code>optional .sync_pb.SyncEnums.PageTransition page_transition = 6 [default = LINK];</code>
   */
  private void clearPageTransition() {
    bitField0_ = (bitField0_ & ~0x00000008);
    pageTransition_ = 0;
  }

  public static final int REDIRECT_TYPE_FIELD_NUMBER = 7;
  private int redirectType_;
  /**
   * <pre>
   * If this transition was triggered by a redirect, the redirect type.
   * </pre>
   *
   * <code>optional .sync_pb.SyncEnums.PageTransitionRedirectType redirect_type = 7;</code>
   */
  public boolean hasRedirectType() {
    return ((bitField0_ & 0x00000010) == 0x00000010);
  }
  /**
   * <pre>
   * If this transition was triggered by a redirect, the redirect type.
   * </pre>
   *
   * <code>optional .sync_pb.SyncEnums.PageTransitionRedirectType redirect_type = 7;</code>
   */
  public org.chromium.components.sync.protocol.SyncEnums.PageTransitionRedirectType getRedirectType() {
    org.chromium.components.sync.protocol.SyncEnums.PageTransitionRedirectType result = org.chromium.components.sync.protocol.SyncEnums.PageTransitionRedirectType.forNumber(redirectType_);
    return result == null ? org.chromium.components.sync.protocol.SyncEnums.PageTransitionRedirectType.CLIENT_REDIRECT : result;
  }
  /**
   * <pre>
   * If this transition was triggered by a redirect, the redirect type.
   * </pre>
   *
   * <code>optional .sync_pb.SyncEnums.PageTransitionRedirectType redirect_type = 7;</code>
   */
  private void setRedirectType(org.chromium.components.sync.protocol.SyncEnums.PageTransitionRedirectType value) {
    if (value == null) {
      throw new NullPointerException();
    }
    bitField0_ |= 0x00000010;
    redirectType_ = value.getNumber();
  }
  /**
   * <pre>
   * If this transition was triggered by a redirect, the redirect type.
   * </pre>
   *
   * <code>optional .sync_pb.SyncEnums.PageTransitionRedirectType redirect_type = 7;</code>
   */
  private void clearRedirectType() {
    bitField0_ = (bitField0_ & ~0x00000010);
    redirectType_ = 1;
  }

  public static final int UNIQUE_ID_FIELD_NUMBER = 8;
  private int uniqueId_;
  /**
   * <pre>
   * The unique navigation id (within this client).
   * </pre>
   *
   * <code>optional int32 unique_id = 8;</code>
   */
  public boolean hasUniqueId() {
    return ((bitField0_ & 0x00000020) == 0x00000020);
  }
  /**
   * <pre>
   * The unique navigation id (within this client).
   * </pre>
   *
   * <code>optional int32 unique_id = 8;</code>
   */
  public int getUniqueId() {
    return uniqueId_;
  }
  /**
   * <pre>
   * The unique navigation id (within this client).
   * </pre>
   *
   * <code>optional int32 unique_id = 8;</code>
   */
  private void setUniqueId(int value) {
    bitField0_ |= 0x00000020;
    uniqueId_ = value;
  }
  /**
   * <pre>
   * The unique navigation id (within this client).
   * </pre>
   *
   * <code>optional int32 unique_id = 8;</code>
   */
  private void clearUniqueId() {
    bitField0_ = (bitField0_ & ~0x00000020);
    uniqueId_ = 0;
  }

  public static final int TIMESTAMP_MSEC_FIELD_NUMBER = 9;
  private long timestampMsec_;
  /**
   * <pre>
   * Timestamp for when this navigation last occurred (in client time).
   * If the user goes back/forward in history the timestamp may refresh.
   * </pre>
   *
   * <code>optional int64 timestamp_msec = 9;</code>
   */
  public boolean hasTimestampMsec() {
    return ((bitField0_ & 0x00000040) == 0x00000040);
  }
  /**
   * <pre>
   * Timestamp for when this navigation last occurred (in client time).
   * If the user goes back/forward in history the timestamp may refresh.
   * </pre>
   *
   * <code>optional int64 timestamp_msec = 9;</code>
   */
  public long getTimestampMsec() {
    return timestampMsec_;
  }
  /**
   * <pre>
   * Timestamp for when this navigation last occurred (in client time).
   * If the user goes back/forward in history the timestamp may refresh.
   * </pre>
   *
   * <code>optional int64 timestamp_msec = 9;</code>
   */
  private void setTimestampMsec(long value) {
    bitField0_ |= 0x00000040;
    timestampMsec_ = value;
  }
  /**
   * <pre>
   * Timestamp for when this navigation last occurred (in client time).
   * If the user goes back/forward in history the timestamp may refresh.
   * </pre>
   *
   * <code>optional int64 timestamp_msec = 9;</code>
   */
  private void clearTimestampMsec() {
    bitField0_ = (bitField0_ & ~0x00000040);
    timestampMsec_ = 0L;
  }

  public static final int NAVIGATION_FORWARD_BACK_FIELD_NUMBER = 10;
  private boolean navigationForwardBack_;
  /**
   * <pre>
   * User used the Forward or Back button to navigate among browsing history.
   * </pre>
   *
   * <code>optional bool navigation_forward_back = 10;</code>
   */
  public boolean hasNavigationForwardBack() {
    return ((bitField0_ & 0x00000080) == 0x00000080);
  }
  /**
   * <pre>
   * User used the Forward or Back button to navigate among browsing history.
   * </pre>
   *
   * <code>optional bool navigation_forward_back = 10;</code>
   */
  public boolean getNavigationForwardBack() {
    return navigationForwardBack_;
  }
  /**
   * <pre>
   * User used the Forward or Back button to navigate among browsing history.
   * </pre>
   *
   * <code>optional bool navigation_forward_back = 10;</code>
   */
  private void setNavigationForwardBack(boolean value) {
    bitField0_ |= 0x00000080;
    navigationForwardBack_ = value;
  }
  /**
   * <pre>
   * User used the Forward or Back button to navigate among browsing history.
   * </pre>
   *
   * <code>optional bool navigation_forward_back = 10;</code>
   */
  private void clearNavigationForwardBack() {
    bitField0_ = (bitField0_ & ~0x00000080);
    navigationForwardBack_ = false;
  }

  public static final int NAVIGATION_FROM_ADDRESS_BAR_FIELD_NUMBER = 11;
  private boolean navigationFromAddressBar_;
  /**
   * <pre>
   * User used the address bar to trigger this navigation.
   * </pre>
   *
   * <code>optional bool navigation_from_address_bar = 11;</code>
   */
  public boolean hasNavigationFromAddressBar() {
    return ((bitField0_ & 0x00000100) == 0x00000100);
  }
  /**
   * <pre>
   * User used the address bar to trigger this navigation.
   * </pre>
   *
   * <code>optional bool navigation_from_address_bar = 11;</code>
   */
  public boolean getNavigationFromAddressBar() {
    return navigationFromAddressBar_;
  }
  /**
   * <pre>
   * User used the address bar to trigger this navigation.
   * </pre>
   *
   * <code>optional bool navigation_from_address_bar = 11;</code>
   */
  private void setNavigationFromAddressBar(boolean value) {
    bitField0_ |= 0x00000100;
    navigationFromAddressBar_ = value;
  }
  /**
   * <pre>
   * User used the address bar to trigger this navigation.
   * </pre>
   *
   * <code>optional bool navigation_from_address_bar = 11;</code>
   */
  private void clearNavigationFromAddressBar() {
    bitField0_ = (bitField0_ & ~0x00000100);
    navigationFromAddressBar_ = false;
  }

  public static final int NAVIGATION_HOME_PAGE_FIELD_NUMBER = 12;
  private boolean navigationHomePage_;
  /**
   * <pre>
   * User is navigating to the home page.
   * </pre>
   *
   * <code>optional bool navigation_home_page = 12;</code>
   */
  public boolean hasNavigationHomePage() {
    return ((bitField0_ & 0x00000200) == 0x00000200);
  }
  /**
   * <pre>
   * User is navigating to the home page.
   * </pre>
   *
   * <code>optional bool navigation_home_page = 12;</code>
   */
  public boolean getNavigationHomePage() {
    return navigationHomePage_;
  }
  /**
   * <pre>
   * User is navigating to the home page.
   * </pre>
   *
   * <code>optional bool navigation_home_page = 12;</code>
   */
  private void setNavigationHomePage(boolean value) {
    bitField0_ |= 0x00000200;
    navigationHomePage_ = value;
  }
  /**
   * <pre>
   * User is navigating to the home page.
   * </pre>
   *
   * <code>optional bool navigation_home_page = 12;</code>
   */
  private void clearNavigationHomePage() {
    bitField0_ = (bitField0_ & ~0x00000200);
    navigationHomePage_ = false;
  }

  public static final int NAVIGATION_CHAIN_START_FIELD_NUMBER = 13;
  private boolean navigationChainStart_;
  /**
   * <pre>
   * The beginning of a navigation chain.
   * </pre>
   *
   * <code>optional bool navigation_chain_start = 13;</code>
   */
  public boolean hasNavigationChainStart() {
    return ((bitField0_ & 0x00000400) == 0x00000400);
  }
  /**
   * <pre>
   * The beginning of a navigation chain.
   * </pre>
   *
   * <code>optional bool navigation_chain_start = 13;</code>
   */
  public boolean getNavigationChainStart() {
    return navigationChainStart_;
  }
  /**
   * <pre>
   * The beginning of a navigation chain.
   * </pre>
   *
   * <code>optional bool navigation_chain_start = 13;</code>
   */
  private void setNavigationChainStart(boolean value) {
    bitField0_ |= 0x00000400;
    navigationChainStart_ = value;
  }
  /**
   * <pre>
   * The beginning of a navigation chain.
   * </pre>
   *
   * <code>optional bool navigation_chain_start = 13;</code>
   */
  private void clearNavigationChainStart() {
    bitField0_ = (bitField0_ & ~0x00000400);
    navigationChainStart_ = false;
  }

  public static final int NAVIGATION_CHAIN_END_FIELD_NUMBER = 14;
  private boolean navigationChainEnd_;
  /**
   * <pre>
   * The last transition in a redirect chain.
   * </pre>
   *
   * <code>optional bool navigation_chain_end = 14;</code>
   */
  public boolean hasNavigationChainEnd() {
    return ((bitField0_ & 0x00000800) == 0x00000800);
  }
  /**
   * <pre>
   * The last transition in a redirect chain.
   * </pre>
   *
   * <code>optional bool navigation_chain_end = 14;</code>
   */
  public boolean getNavigationChainEnd() {
    return navigationChainEnd_;
  }
  /**
   * <pre>
   * The last transition in a redirect chain.
   * </pre>
   *
   * <code>optional bool navigation_chain_end = 14;</code>
   */
  private void setNavigationChainEnd(boolean value) {
    bitField0_ |= 0x00000800;
    navigationChainEnd_ = value;
  }
  /**
   * <pre>
   * The last transition in a redirect chain.
   * </pre>
   *
   * <code>optional bool navigation_chain_end = 14;</code>
   */
  private void clearNavigationChainEnd() {
    bitField0_ = (bitField0_ & ~0x00000800);
    navigationChainEnd_ = false;
  }

  public static final int GLOBAL_ID_FIELD_NUMBER = 15;
  private long globalId_;
  /**
   * <pre>
   * The id for this navigation, which is globally unique with high
   * probability.
   * </pre>
   *
   * <code>optional int64 global_id = 15;</code>
   */
  public boolean hasGlobalId() {
    return ((bitField0_ & 0x00001000) == 0x00001000);
  }
  /**
   * <pre>
   * The id for this navigation, which is globally unique with high
   * probability.
   * </pre>
   *
   * <code>optional int64 global_id = 15;</code>
   */
  public long getGlobalId() {
    return globalId_;
  }
  /**
   * <pre>
   * The id for this navigation, which is globally unique with high
   * probability.
   * </pre>
   *
   * <code>optional int64 global_id = 15;</code>
   */
  private void setGlobalId(long value) {
    bitField0_ |= 0x00001000;
    globalId_ = value;
  }
  /**
   * <pre>
   * The id for this navigation, which is globally unique with high
   * probability.
   * </pre>
   *
   * <code>optional int64 global_id = 15;</code>
   */
  private void clearGlobalId() {
    bitField0_ = (bitField0_ & ~0x00001000);
    globalId_ = 0L;
  }

  public static final int SEARCH_TERMS_FIELD_NUMBER = 16;
  private java.lang.String searchTerms_;
  /**
   * <pre>
   * Search terms extracted from the URL.
   * </pre>
   *
   * <code>optional string search_terms = 16 [deprecated = true];</code>
   */
  @java.lang.Deprecated public boolean hasSearchTerms() {
    return ((bitField0_ & 0x00002000) == 0x00002000);
  }
  /**
   * <pre>
   * Search terms extracted from the URL.
   * </pre>
   *
   * <code>optional string search_terms = 16 [deprecated = true];</code>
   */
  @java.lang.Deprecated public java.lang.String getSearchTerms() {
    return searchTerms_;
  }
  /**
   * <pre>
   * Search terms extracted from the URL.
   * </pre>
   *
   * <code>optional string search_terms = 16 [deprecated = true];</code>
   */
  @java.lang.Deprecated public com.google.protobuf.ByteString
      getSearchTermsBytes() {
    return com.google.protobuf.ByteString.copyFromUtf8(searchTerms_);
  }
  /**
   * <pre>
   * Search terms extracted from the URL.
   * </pre>
   *
   * <code>optional string search_terms = 16 [deprecated = true];</code>
   */
  private void setSearchTerms(
      java.lang.String value) {
    if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00002000;
    searchTerms_ = value;
  }
  /**
   * <pre>
   * Search terms extracted from the URL.
   * </pre>
   *
   * <code>optional string search_terms = 16 [deprecated = true];</code>
   */
  private void clearSearchTerms() {
    bitField0_ = (bitField0_ & ~0x00002000);
    searchTerms_ = getDefaultInstance().getSearchTerms();
  }
  /**
   * <pre>
   * Search terms extracted from the URL.
   * </pre>
   *
   * <code>optional string search_terms = 16 [deprecated = true];</code>
   */
  private void setSearchTermsBytes(
      com.google.protobuf.ByteString value) {
    if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00002000;
    searchTerms_ = value.toStringUtf8();
  }

  public static final int FAVICON_URL_FIELD_NUMBER = 17;
  private java.lang.String faviconUrl_;
  /**
   * <pre>
   * The favicon url associated with this page.
   * </pre>
   *
   * <code>optional string favicon_url = 17;</code>
   */
  public boolean hasFaviconUrl() {
    return ((bitField0_ & 0x00004000) == 0x00004000);
  }
  /**
   * <pre>
   * The favicon url associated with this page.
   * </pre>
   *
   * <code>optional string favicon_url = 17;</code>
   */
  public java.lang.String getFaviconUrl() {
    return faviconUrl_;
  }
  /**
   * <pre>
   * The favicon url associated with this page.
   * </pre>
   *
   * <code>optional string favicon_url = 17;</code>
   */
  public com.google.protobuf.ByteString
      getFaviconUrlBytes() {
    return com.google.protobuf.ByteString.copyFromUtf8(faviconUrl_);
  }
  /**
   * <pre>
   * The favicon url associated with this page.
   * </pre>
   *
   * <code>optional string favicon_url = 17;</code>
   */
  private void setFaviconUrl(
      java.lang.String value) {
    if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00004000;
    faviconUrl_ = value;
  }
  /**
   * <pre>
   * The favicon url associated with this page.
   * </pre>
   *
   * <code>optional string favicon_url = 17;</code>
   */
  private void clearFaviconUrl() {
    bitField0_ = (bitField0_ & ~0x00004000);
    faviconUrl_ = getDefaultInstance().getFaviconUrl();
  }
  /**
   * <pre>
   * The favicon url associated with this page.
   * </pre>
   *
   * <code>optional string favicon_url = 17;</code>
   */
  private void setFaviconUrlBytes(
      com.google.protobuf.ByteString value) {
    if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00004000;
    faviconUrl_ = value.toStringUtf8();
  }

  public static final int BLOCKED_STATE_FIELD_NUMBER = 18;
  private int blockedState_;
  /**
   * <pre>
   * Whether access to the URL was allowed or blocked.
   * </pre>
   *
   * <code>optional .sync_pb.TabNavigation.BlockedState blocked_state = 18 [default = STATE_ALLOWED];</code>
   */
  public boolean hasBlockedState() {
    return ((bitField0_ & 0x00008000) == 0x00008000);
  }
  /**
   * <pre>
   * Whether access to the URL was allowed or blocked.
   * </pre>
   *
   * <code>optional .sync_pb.TabNavigation.BlockedState blocked_state = 18 [default = STATE_ALLOWED];</code>
   */
  public org.chromium.components.sync.protocol.TabNavigation.BlockedState getBlockedState() {
    org.chromium.components.sync.protocol.TabNavigation.BlockedState result = org.chromium.components.sync.protocol.TabNavigation.BlockedState.forNumber(blockedState_);
    return result == null ? org.chromium.components.sync.protocol.TabNavigation.BlockedState.STATE_ALLOWED : result;
  }
  /**
   * <pre>
   * Whether access to the URL was allowed or blocked.
   * </pre>
   *
   * <code>optional .sync_pb.TabNavigation.BlockedState blocked_state = 18 [default = STATE_ALLOWED];</code>
   */
  private void setBlockedState(org.chromium.components.sync.protocol.TabNavigation.BlockedState value) {
    if (value == null) {
      throw new NullPointerException();
    }
    bitField0_ |= 0x00008000;
    blockedState_ = value.getNumber();
  }
  /**
   * <pre>
   * Whether access to the URL was allowed or blocked.
   * </pre>
   *
   * <code>optional .sync_pb.TabNavigation.BlockedState blocked_state = 18 [default = STATE_ALLOWED];</code>
   */
  private void clearBlockedState() {
    bitField0_ = (bitField0_ & ~0x00008000);
    blockedState_ = 1;
  }

  public static final int CONTENT_PACK_CATEGORIES_FIELD_NUMBER = 19;
  private com.google.protobuf.Internal.ProtobufList<String> contentPackCategories_;
  /**
   * <pre>
   * A list of category identifiers for the URL.
   * </pre>
   *
   * <code>repeated string content_pack_categories = 19;</code>
   */
  public java.util.List<String> getContentPackCategoriesList() {
    return contentPackCategories_;
  }
  /**
   * <pre>
   * A list of category identifiers for the URL.
   * </pre>
   *
   * <code>repeated string content_pack_categories = 19;</code>
   */
  public int getContentPackCategoriesCount() {
    return contentPackCategories_.size();
  }
  /**
   * <pre>
   * A list of category identifiers for the URL.
   * </pre>
   *
   * <code>repeated string content_pack_categories = 19;</code>
   */
  public java.lang.String getContentPackCategories(int index) {
    return contentPackCategories_.get(index);
  }
  /**
   * <pre>
   * A list of category identifiers for the URL.
   * </pre>
   *
   * <code>repeated string content_pack_categories = 19;</code>
   */
  public com.google.protobuf.ByteString
      getContentPackCategoriesBytes(int index) {
    return com.google.protobuf.ByteString.copyFromUtf8(
        contentPackCategories_.get(index));
  }
  private void ensureContentPackCategoriesIsMutable() {
    if (!contentPackCategories_.isModifiable()) {
      contentPackCategories_ =
          com.google.protobuf.GeneratedMessageLite.mutableCopy(contentPackCategories_);
     }
  }
  /**
   * <pre>
   * A list of category identifiers for the URL.
   * </pre>
   *
   * <code>repeated string content_pack_categories = 19;</code>
   */
  private void setContentPackCategories(
      int index, java.lang.String value) {
    if (value == null) {
    throw new NullPointerException();
  }
  ensureContentPackCategoriesIsMutable();
    contentPackCategories_.set(index, value);
  }
  /**
   * <pre>
   * A list of category identifiers for the URL.
   * </pre>
   *
   * <code>repeated string content_pack_categories = 19;</code>
   */
  private void addContentPackCategories(
      java.lang.String value) {
    if (value == null) {
    throw new NullPointerException();
  }
  ensureContentPackCategoriesIsMutable();
    contentPackCategories_.add(value);
  }
  /**
   * <pre>
   * A list of category identifiers for the URL.
   * </pre>
   *
   * <code>repeated string content_pack_categories = 19;</code>
   */
  private void addAllContentPackCategories(
      java.lang.Iterable<java.lang.String> values) {
    ensureContentPackCategoriesIsMutable();
    com.google.protobuf.AbstractMessageLite.addAll(
        values, contentPackCategories_);
  }
  /**
   * <pre>
   * A list of category identifiers for the URL.
   * </pre>
   *
   * <code>repeated string content_pack_categories = 19;</code>
   */
  private void clearContentPackCategories() {
    contentPackCategories_ = com.google.protobuf.GeneratedMessageLite.emptyProtobufList();
  }
  /**
   * <pre>
   * A list of category identifiers for the URL.
   * </pre>
   *
   * <code>repeated string content_pack_categories = 19;</code>
   */
  private void addContentPackCategoriesBytes(
      com.google.protobuf.ByteString value) {
    if (value == null) {
    throw new NullPointerException();
  }
  ensureContentPackCategoriesIsMutable();
    contentPackCategories_.add(value.toStringUtf8());
  }

  public static final int HTTP_STATUS_CODE_FIELD_NUMBER = 20;
  private int httpStatusCode_;
  /**
   * <pre>
   * The status code from the last navigation.
   * </pre>
   *
   * <code>optional int32 http_status_code = 20;</code>
   */
  public boolean hasHttpStatusCode() {
    return ((bitField0_ & 0x00010000) == 0x00010000);
  }
  /**
   * <pre>
   * The status code from the last navigation.
   * </pre>
   *
   * <code>optional int32 http_status_code = 20;</code>
   */
  public int getHttpStatusCode() {
    return httpStatusCode_;
  }
  /**
   * <pre>
   * The status code from the last navigation.
   * </pre>
   *
   * <code>optional int32 http_status_code = 20;</code>
   */
  private void setHttpStatusCode(int value) {
    bitField0_ |= 0x00010000;
    httpStatusCode_ = value;
  }
  /**
   * <pre>
   * The status code from the last navigation.
   * </pre>
   *
   * <code>optional int32 http_status_code = 20;</code>
   */
  private void clearHttpStatusCode() {
    bitField0_ = (bitField0_ & ~0x00010000);
    httpStatusCode_ = 0;
  }

  public static final int OBSOLETE_REFERRER_POLICY_FIELD_NUMBER = 21;
  private int obsoleteReferrerPolicy_;
  /**
   * <pre>
   * Referrer policy. Old, broken value. Deprecated in M61.
   * </pre>
   *
   * <code>optional int32 obsolete_referrer_policy = 21 [deprecated = true];</code>
   */
  @java.lang.Deprecated public boolean hasObsoleteReferrerPolicy() {
    return ((bitField0_ & 0x00020000) == 0x00020000);
  }
  /**
   * <pre>
   * Referrer policy. Old, broken value. Deprecated in M61.
   * </pre>
   *
   * <code>optional int32 obsolete_referrer_policy = 21 [deprecated = true];</code>
   */
  @java.lang.Deprecated public int getObsoleteReferrerPolicy() {
    return obsoleteReferrerPolicy_;
  }
  /**
   * <pre>
   * Referrer policy. Old, broken value. Deprecated in M61.
   * </pre>
   *
   * <code>optional int32 obsolete_referrer_policy = 21 [deprecated = true];</code>
   */
  private void setObsoleteReferrerPolicy(int value) {
    bitField0_ |= 0x00020000;
    obsoleteReferrerPolicy_ = value;
  }
  /**
   * <pre>
   * Referrer policy. Old, broken value. Deprecated in M61.
   * </pre>
   *
   * <code>optional int32 obsolete_referrer_policy = 21 [deprecated = true];</code>
   */
  private void clearObsoleteReferrerPolicy() {
    bitField0_ = (bitField0_ & ~0x00020000);
    obsoleteReferrerPolicy_ = 0;
  }

  public static final int IS_RESTORED_FIELD_NUMBER = 22;
  private boolean isRestored_;
  /**
   * <pre>
   * True if created from restored navigation entry that hasn't been loaded.
   * </pre>
   *
   * <code>optional bool is_restored = 22;</code>
   */
  public boolean hasIsRestored() {
    return ((bitField0_ & 0x00040000) == 0x00040000);
  }
  /**
   * <pre>
   * True if created from restored navigation entry that hasn't been loaded.
   * </pre>
   *
   * <code>optional bool is_restored = 22;</code>
   */
  public boolean getIsRestored() {
    return isRestored_;
  }
  /**
   * <pre>
   * True if created from restored navigation entry that hasn't been loaded.
   * </pre>
   *
   * <code>optional bool is_restored = 22;</code>
   */
  private void setIsRestored(boolean value) {
    bitField0_ |= 0x00040000;
    isRestored_ = value;
  }
  /**
   * <pre>
   * True if created from restored navigation entry that hasn't been loaded.
   * </pre>
   *
   * <code>optional bool is_restored = 22;</code>
   */
  private void clearIsRestored() {
    bitField0_ = (bitField0_ & ~0x00040000);
    isRestored_ = false;
  }

  public static final int NAVIGATION_REDIRECT_FIELD_NUMBER = 23;
  private com.google.protobuf.Internal.ProtobufList<org.chromium.components.sync.protocol.NavigationRedirect> navigationRedirect_;
  /**
   * <pre>
   * The chain of redirections for this navigation, from the original URL
   * through the last URL that redirected.
   * </pre>
   *
   * <code>repeated .sync_pb.NavigationRedirect navigation_redirect = 23;</code>
   */
  public java.util.List<org.chromium.components.sync.protocol.NavigationRedirect> getNavigationRedirectList() {
    return navigationRedirect_;
  }
  /**
   * <pre>
   * The chain of redirections for this navigation, from the original URL
   * through the last URL that redirected.
   * </pre>
   *
   * <code>repeated .sync_pb.NavigationRedirect navigation_redirect = 23;</code>
   */
  public java.util.List<? extends org.chromium.components.sync.protocol.NavigationRedirectOrBuilder> 
      getNavigationRedirectOrBuilderList() {
    return navigationRedirect_;
  }
  /**
   * <pre>
   * The chain of redirections for this navigation, from the original URL
   * through the last URL that redirected.
   * </pre>
   *
   * <code>repeated .sync_pb.NavigationRedirect navigation_redirect = 23;</code>
   */
  public int getNavigationRedirectCount() {
    return navigationRedirect_.size();
  }
  /**
   * <pre>
   * The chain of redirections for this navigation, from the original URL
   * through the last URL that redirected.
   * </pre>
   *
   * <code>repeated .sync_pb.NavigationRedirect navigation_redirect = 23;</code>
   */
  public org.chromium.components.sync.protocol.NavigationRedirect getNavigationRedirect(int index) {
    return navigationRedirect_.get(index);
  }
  /**
   * <pre>
   * The chain of redirections for this navigation, from the original URL
   * through the last URL that redirected.
   * </pre>
   *
   * <code>repeated .sync_pb.NavigationRedirect navigation_redirect = 23;</code>
   */
  public org.chromium.components.sync.protocol.NavigationRedirectOrBuilder getNavigationRedirectOrBuilder(
      int index) {
    return navigationRedirect_.get(index);
  }
  private void ensureNavigationRedirectIsMutable() {
    if (!navigationRedirect_.isModifiable()) {
      navigationRedirect_ =
          com.google.protobuf.GeneratedMessageLite.mutableCopy(navigationRedirect_);
     }
  }

  /**
   * <pre>
   * The chain of redirections for this navigation, from the original URL
   * through the last URL that redirected.
   * </pre>
   *
   * <code>repeated .sync_pb.NavigationRedirect navigation_redirect = 23;</code>
   */
  private void setNavigationRedirect(
      int index, org.chromium.components.sync.protocol.NavigationRedirect value) {
    if (value == null) {
      throw new NullPointerException();
    }
    ensureNavigationRedirectIsMutable();
    navigationRedirect_.set(index, value);
  }
  /**
   * <pre>
   * The chain of redirections for this navigation, from the original URL
   * through the last URL that redirected.
   * </pre>
   *
   * <code>repeated .sync_pb.NavigationRedirect navigation_redirect = 23;</code>
   */
  private void setNavigationRedirect(
      int index, org.chromium.components.sync.protocol.NavigationRedirect.Builder builderForValue) {
    ensureNavigationRedirectIsMutable();
    navigationRedirect_.set(index, builderForValue.build());
  }
  /**
   * <pre>
   * The chain of redirections for this navigation, from the original URL
   * through the last URL that redirected.
   * </pre>
   *
   * <code>repeated .sync_pb.NavigationRedirect navigation_redirect = 23;</code>
   */
  private void addNavigationRedirect(org.chromium.components.sync.protocol.NavigationRedirect value) {
    if (value == null) {
      throw new NullPointerException();
    }
    ensureNavigationRedirectIsMutable();
    navigationRedirect_.add(value);
  }
  /**
   * <pre>
   * The chain of redirections for this navigation, from the original URL
   * through the last URL that redirected.
   * </pre>
   *
   * <code>repeated .sync_pb.NavigationRedirect navigation_redirect = 23;</code>
   */
  private void addNavigationRedirect(
      int index, org.chromium.components.sync.protocol.NavigationRedirect value) {
    if (value == null) {
      throw new NullPointerException();
    }
    ensureNavigationRedirectIsMutable();
    navigationRedirect_.add(index, value);
  }
  /**
   * <pre>
   * The chain of redirections for this navigation, from the original URL
   * through the last URL that redirected.
   * </pre>
   *
   * <code>repeated .sync_pb.NavigationRedirect navigation_redirect = 23;</code>
   */
  private void addNavigationRedirect(
      org.chromium.components.sync.protocol.NavigationRedirect.Builder builderForValue) {
    ensureNavigationRedirectIsMutable();
    navigationRedirect_.add(builderForValue.build());
  }
  /**
   * <pre>
   * The chain of redirections for this navigation, from the original URL
   * through the last URL that redirected.
   * </pre>
   *
   * <code>repeated .sync_pb.NavigationRedirect navigation_redirect = 23;</code>
   */
  private void addNavigationRedirect(
      int index, org.chromium.components.sync.protocol.NavigationRedirect.Builder builderForValue) {
    ensureNavigationRedirectIsMutable();
    navigationRedirect_.add(index, builderForValue.build());
  }
  /**
   * <pre>
   * The chain of redirections for this navigation, from the original URL
   * through the last URL that redirected.
   * </pre>
   *
   * <code>repeated .sync_pb.NavigationRedirect navigation_redirect = 23;</code>
   */
  private void addAllNavigationRedirect(
      java.lang.Iterable<? extends org.chromium.components.sync.protocol.NavigationRedirect> values) {
    ensureNavigationRedirectIsMutable();
    com.google.protobuf.AbstractMessageLite.addAll(
        values, navigationRedirect_);
  }
  /**
   * <pre>
   * The chain of redirections for this navigation, from the original URL
   * through the last URL that redirected.
   * </pre>
   *
   * <code>repeated .sync_pb.NavigationRedirect navigation_redirect = 23;</code>
   */
  private void clearNavigationRedirect() {
    navigationRedirect_ = emptyProtobufList();
  }
  /**
   * <pre>
   * The chain of redirections for this navigation, from the original URL
   * through the last URL that redirected.
   * </pre>
   *
   * <code>repeated .sync_pb.NavigationRedirect navigation_redirect = 23;</code>
   */
  private void removeNavigationRedirect(int index) {
    ensureNavigationRedirectIsMutable();
    navigationRedirect_.remove(index);
  }

  public static final int LAST_NAVIGATION_REDIRECT_URL_FIELD_NUMBER = 24;
  private java.lang.String lastNavigationRedirectUrl_;
  /**
   * <pre>
   * Normally not present.
   * The last URL traversed when different from the virtual_url.
   * </pre>
   *
   * <code>optional string last_navigation_redirect_url = 24;</code>
   */
  public boolean hasLastNavigationRedirectUrl() {
    return ((bitField0_ & 0x00080000) == 0x00080000);
  }
  /**
   * <pre>
   * Normally not present.
   * The last URL traversed when different from the virtual_url.
   * </pre>
   *
   * <code>optional string last_navigation_redirect_url = 24;</code>
   */
  public java.lang.String getLastNavigationRedirectUrl() {
    return lastNavigationRedirectUrl_;
  }
  /**
   * <pre>
   * Normally not present.
   * The last URL traversed when different from the virtual_url.
   * </pre>
   *
   * <code>optional string last_navigation_redirect_url = 24;</code>
   */
  public com.google.protobuf.ByteString
      getLastNavigationRedirectUrlBytes() {
    return com.google.protobuf.ByteString.copyFromUtf8(lastNavigationRedirectUrl_);
  }
  /**
   * <pre>
   * Normally not present.
   * The last URL traversed when different from the virtual_url.
   * </pre>
   *
   * <code>optional string last_navigation_redirect_url = 24;</code>
   */
  private void setLastNavigationRedirectUrl(
      java.lang.String value) {
    if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00080000;
    lastNavigationRedirectUrl_ = value;
  }
  /**
   * <pre>
   * Normally not present.
   * The last URL traversed when different from the virtual_url.
   * </pre>
   *
   * <code>optional string last_navigation_redirect_url = 24;</code>
   */
  private void clearLastNavigationRedirectUrl() {
    bitField0_ = (bitField0_ & ~0x00080000);
    lastNavigationRedirectUrl_ = getDefaultInstance().getLastNavigationRedirectUrl();
  }
  /**
   * <pre>
   * Normally not present.
   * The last URL traversed when different from the virtual_url.
   * </pre>
   *
   * <code>optional string last_navigation_redirect_url = 24;</code>
   */
  private void setLastNavigationRedirectUrlBytes(
      com.google.protobuf.ByteString value) {
    if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00080000;
    lastNavigationRedirectUrl_ = value.toStringUtf8();
  }

  public static final int CORRECT_REFERRER_POLICY_FIELD_NUMBER = 25;
  private int correctReferrerPolicy_;
  /**
   * <pre>
   * Correct referrer policy. Valid enums are defined in
   * third_party/WebKit/public/platform/WebReferrerPolicy.h.
   * </pre>
   *
   * <code>optional int32 correct_referrer_policy = 25 [default = 1];</code>
   */
  public boolean hasCorrectReferrerPolicy() {
    return ((bitField0_ & 0x00100000) == 0x00100000);
  }
  /**
   * <pre>
   * Correct referrer policy. Valid enums are defined in
   * third_party/WebKit/public/platform/WebReferrerPolicy.h.
   * </pre>
   *
   * <code>optional int32 correct_referrer_policy = 25 [default = 1];</code>
   */
  public int getCorrectReferrerPolicy() {
    return correctReferrerPolicy_;
  }
  /**
   * <pre>
   * Correct referrer policy. Valid enums are defined in
   * third_party/WebKit/public/platform/WebReferrerPolicy.h.
   * </pre>
   *
   * <code>optional int32 correct_referrer_policy = 25 [default = 1];</code>
   */
  private void setCorrectReferrerPolicy(int value) {
    bitField0_ |= 0x00100000;
    correctReferrerPolicy_ = value;
  }
  /**
   * <pre>
   * Correct referrer policy. Valid enums are defined in
   * third_party/WebKit/public/platform/WebReferrerPolicy.h.
   * </pre>
   *
   * <code>optional int32 correct_referrer_policy = 25 [default = 1];</code>
   */
  private void clearCorrectReferrerPolicy() {
    bitField0_ = (bitField0_ & ~0x00100000);
    correctReferrerPolicy_ = 1;
  }

  public static final int PASSWORD_STATE_FIELD_NUMBER = 26;
  private int passwordState_;
  /**
   * <pre>
   * Whether the Password Manager saw a password field on the page.
   * </pre>
   *
   * <code>optional .sync_pb.TabNavigation.PasswordState password_state = 26;</code>
   */
  public boolean hasPasswordState() {
    return ((bitField0_ & 0x00200000) == 0x00200000);
  }
  /**
   * <pre>
   * Whether the Password Manager saw a password field on the page.
   * </pre>
   *
   * <code>optional .sync_pb.TabNavigation.PasswordState password_state = 26;</code>
   */
  public org.chromium.components.sync.protocol.TabNavigation.PasswordState getPasswordState() {
    org.chromium.components.sync.protocol.TabNavigation.PasswordState result = org.chromium.components.sync.protocol.TabNavigation.PasswordState.forNumber(passwordState_);
    return result == null ? org.chromium.components.sync.protocol.TabNavigation.PasswordState.PASSWORD_STATE_UNKNOWN : result;
  }
  /**
   * <pre>
   * Whether the Password Manager saw a password field on the page.
   * </pre>
   *
   * <code>optional .sync_pb.TabNavigation.PasswordState password_state = 26;</code>
   */
  private void setPasswordState(org.chromium.components.sync.protocol.TabNavigation.PasswordState value) {
    if (value == null) {
      throw new NullPointerException();
    }
    bitField0_ |= 0x00200000;
    passwordState_ = value.getNumber();
  }
  /**
   * <pre>
   * Whether the Password Manager saw a password field on the page.
   * </pre>
   *
   * <code>optional .sync_pb.TabNavigation.PasswordState password_state = 26;</code>
   */
  private void clearPasswordState() {
    bitField0_ = (bitField0_ & ~0x00200000);
    passwordState_ = 0;
  }

  public static final int TASK_ID_FIELD_NUMBER = 27;
  private long taskId_;
  /**
   * <pre>
   * The id for the task associated with this navigation, which is globally
   * unique with high probability.
   * Similar with global_id, but used to identify a navigation in Chrome Tasks,
   * so navigations of a page have the same task_id if one is the first visit of
   * the page, and others are its back/forward visits.
   * </pre>
   *
   * <code>optional int64 task_id = 27;</code>
   */
  public boolean hasTaskId() {
    return ((bitField0_ & 0x00400000) == 0x00400000);
  }
  /**
   * <pre>
   * The id for the task associated with this navigation, which is globally
   * unique with high probability.
   * Similar with global_id, but used to identify a navigation in Chrome Tasks,
   * so navigations of a page have the same task_id if one is the first visit of
   * the page, and others are its back/forward visits.
   * </pre>
   *
   * <code>optional int64 task_id = 27;</code>
   */
  public long getTaskId() {
    return taskId_;
  }
  /**
   * <pre>
   * The id for the task associated with this navigation, which is globally
   * unique with high probability.
   * Similar with global_id, but used to identify a navigation in Chrome Tasks,
   * so navigations of a page have the same task_id if one is the first visit of
   * the page, and others are its back/forward visits.
   * </pre>
   *
   * <code>optional int64 task_id = 27;</code>
   */
  private void setTaskId(long value) {
    bitField0_ |= 0x00400000;
    taskId_ = value;
  }
  /**
   * <pre>
   * The id for the task associated with this navigation, which is globally
   * unique with high probability.
   * Similar with global_id, but used to identify a navigation in Chrome Tasks,
   * so navigations of a page have the same task_id if one is the first visit of
   * the page, and others are its back/forward visits.
   * </pre>
   *
   * <code>optional int64 task_id = 27;</code>
   */
  private void clearTaskId() {
    bitField0_ = (bitField0_ & ~0x00400000);
    taskId_ = 0L;
  }

  public static final int ANCESTOR_TASK_ID_FIELD_NUMBER = 28;
  private com.google.protobuf.Internal.LongList ancestorTaskId_;
  /**
   * <pre>
   * Task ids of all ancestor navigations, which can be from other tabs, from
   * root to parent. We define navigation A is parent of navigation B if page of
   * B is got by clicking a link on page of A. This relationship is used to
   * define a Chrome Task as a tree rooted by a navigation.
   * </pre>
   *
   * <code>repeated int64 ancestor_task_id = 28;</code>
   */
  public java.util.List<java.lang.Long>
      getAncestorTaskIdList() {
    return ancestorTaskId_;
  }
  /**
   * <pre>
   * Task ids of all ancestor navigations, which can be from other tabs, from
   * root to parent. We define navigation A is parent of navigation B if page of
   * B is got by clicking a link on page of A. This relationship is used to
   * define a Chrome Task as a tree rooted by a navigation.
   * </pre>
   *
   * <code>repeated int64 ancestor_task_id = 28;</code>
   */
  public int getAncestorTaskIdCount() {
    return ancestorTaskId_.size();
  }
  /**
   * <pre>
   * Task ids of all ancestor navigations, which can be from other tabs, from
   * root to parent. We define navigation A is parent of navigation B if page of
   * B is got by clicking a link on page of A. This relationship is used to
   * define a Chrome Task as a tree rooted by a navigation.
   * </pre>
   *
   * <code>repeated int64 ancestor_task_id = 28;</code>
   */
  public long getAncestorTaskId(int index) {
    return ancestorTaskId_.getLong(index);
  }
  private void ensureAncestorTaskIdIsMutable() {
    if (!ancestorTaskId_.isModifiable()) {
      ancestorTaskId_ =
          com.google.protobuf.GeneratedMessageLite.mutableCopy(ancestorTaskId_);
     }
  }
  /**
   * <pre>
   * Task ids of all ancestor navigations, which can be from other tabs, from
   * root to parent. We define navigation A is parent of navigation B if page of
   * B is got by clicking a link on page of A. This relationship is used to
   * define a Chrome Task as a tree rooted by a navigation.
   * </pre>
   *
   * <code>repeated int64 ancestor_task_id = 28;</code>
   */
  private void setAncestorTaskId(
      int index, long value) {
    ensureAncestorTaskIdIsMutable();
    ancestorTaskId_.setLong(index, value);
  }
  /**
   * <pre>
   * Task ids of all ancestor navigations, which can be from other tabs, from
   * root to parent. We define navigation A is parent of navigation B if page of
   * B is got by clicking a link on page of A. This relationship is used to
   * define a Chrome Task as a tree rooted by a navigation.
   * </pre>
   *
   * <code>repeated int64 ancestor_task_id = 28;</code>
   */
  private void addAncestorTaskId(long value) {
    ensureAncestorTaskIdIsMutable();
    ancestorTaskId_.addLong(value);
  }
  /**
   * <pre>
   * Task ids of all ancestor navigations, which can be from other tabs, from
   * root to parent. We define navigation A is parent of navigation B if page of
   * B is got by clicking a link on page of A. This relationship is used to
   * define a Chrome Task as a tree rooted by a navigation.
   * </pre>
   *
   * <code>repeated int64 ancestor_task_id = 28;</code>
   */
  private void addAllAncestorTaskId(
      java.lang.Iterable<? extends java.lang.Long> values) {
    ensureAncestorTaskIdIsMutable();
    com.google.protobuf.AbstractMessageLite.addAll(
        values, ancestorTaskId_);
  }
  /**
   * <pre>
   * Task ids of all ancestor navigations, which can be from other tabs, from
   * root to parent. We define navigation A is parent of navigation B if page of
   * B is got by clicking a link on page of A. This relationship is used to
   * define a Chrome Task as a tree rooted by a navigation.
   * </pre>
   *
   * <code>repeated int64 ancestor_task_id = 28;</code>
   */
  private void clearAncestorTaskId() {
    ancestorTaskId_ = emptyLongList();
  }

  public static final int REPLACED_NAVIGATION_FIELD_NUMBER = 29;
  private org.chromium.components.sync.protocol.ReplacedNavigation replacedNavigation_;
  /**
   * <pre>
   * When a history entry is replaced (e.g. history.replaceState()), this
   * contains some information about the entry prior to being replaced. Even if
   * an entry is replaced multiple times, it represents data prior to the
   * *first* replace.
   * </pre>
   *
   * <code>optional .sync_pb.ReplacedNavigation replaced_navigation = 29;</code>
   */
  public boolean hasReplacedNavigation() {
    return ((bitField0_ & 0x00800000) == 0x00800000);
  }
  /**
   * <pre>
   * When a history entry is replaced (e.g. history.replaceState()), this
   * contains some information about the entry prior to being replaced. Even if
   * an entry is replaced multiple times, it represents data prior to the
   * *first* replace.
   * </pre>
   *
   * <code>optional .sync_pb.ReplacedNavigation replaced_navigation = 29;</code>
   */
  public org.chromium.components.sync.protocol.ReplacedNavigation getReplacedNavigation() {
    return replacedNavigation_ == null ? org.chromium.components.sync.protocol.ReplacedNavigation.getDefaultInstance() : replacedNavigation_;
  }
  /**
   * <pre>
   * When a history entry is replaced (e.g. history.replaceState()), this
   * contains some information about the entry prior to being replaced. Even if
   * an entry is replaced multiple times, it represents data prior to the
   * *first* replace.
   * </pre>
   *
   * <code>optional .sync_pb.ReplacedNavigation replaced_navigation = 29;</code>
   */
  private void setReplacedNavigation(org.chromium.components.sync.protocol.ReplacedNavigation value) {
    if (value == null) {
      throw new NullPointerException();
    }
    replacedNavigation_ = value;
    bitField0_ |= 0x00800000;
    }
  /**
   * <pre>
   * When a history entry is replaced (e.g. history.replaceState()), this
   * contains some information about the entry prior to being replaced. Even if
   * an entry is replaced multiple times, it represents data prior to the
   * *first* replace.
   * </pre>
   *
   * <code>optional .sync_pb.ReplacedNavigation replaced_navigation = 29;</code>
   */
  private void setReplacedNavigation(
      org.chromium.components.sync.protocol.ReplacedNavigation.Builder builderForValue) {
    replacedNavigation_ = builderForValue.build();
    bitField0_ |= 0x00800000;
  }
  /**
   * <pre>
   * When a history entry is replaced (e.g. history.replaceState()), this
   * contains some information about the entry prior to being replaced. Even if
   * an entry is replaced multiple times, it represents data prior to the
   * *first* replace.
   * </pre>
   *
   * <code>optional .sync_pb.ReplacedNavigation replaced_navigation = 29;</code>
   */
  private void mergeReplacedNavigation(org.chromium.components.sync.protocol.ReplacedNavigation value) {
    if (replacedNavigation_ != null &&
        replacedNavigation_ != org.chromium.components.sync.protocol.ReplacedNavigation.getDefaultInstance()) {
      replacedNavigation_ =
        org.chromium.components.sync.protocol.ReplacedNavigation.newBuilder(replacedNavigation_).mergeFrom(value).buildPartial();
    } else {
      replacedNavigation_ = value;
    }
    bitField0_ |= 0x00800000;
  }
  /**
   * <pre>
   * When a history entry is replaced (e.g. history.replaceState()), this
   * contains some information about the entry prior to being replaced. Even if
   * an entry is replaced multiple times, it represents data prior to the
   * *first* replace.
   * </pre>
   *
   * <code>optional .sync_pb.ReplacedNavigation replaced_navigation = 29;</code>
   */
  private void clearReplacedNavigation() {  replacedNavigation_ = null;
    bitField0_ = (bitField0_ & ~0x00800000);
  }

  public static final int PAGE_LANGUAGE_FIELD_NUMBER = 30;
  private java.lang.String pageLanguage_;
  /**
   * <pre>
   * The page language as determined by its textual content. An ISO 639 language
   * code (two letters, except for Chinese where a localization is necessary).
   * </pre>
   *
   * <code>optional string page_language = 30;</code>
   */
  public boolean hasPageLanguage() {
    return ((bitField0_ & 0x01000000) == 0x01000000);
  }
  /**
   * <pre>
   * The page language as determined by its textual content. An ISO 639 language
   * code (two letters, except for Chinese where a localization is necessary).
   * </pre>
   *
   * <code>optional string page_language = 30;</code>
   */
  public java.lang.String getPageLanguage() {
    return pageLanguage_;
  }
  /**
   * <pre>
   * The page language as determined by its textual content. An ISO 639 language
   * code (two letters, except for Chinese where a localization is necessary).
   * </pre>
   *
   * <code>optional string page_language = 30;</code>
   */
  public com.google.protobuf.ByteString
      getPageLanguageBytes() {
    return com.google.protobuf.ByteString.copyFromUtf8(pageLanguage_);
  }
  /**
   * <pre>
   * The page language as determined by its textual content. An ISO 639 language
   * code (two letters, except for Chinese where a localization is necessary).
   * </pre>
   *
   * <code>optional string page_language = 30;</code>
   */
  private void setPageLanguage(
      java.lang.String value) {
    if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x01000000;
    pageLanguage_ = value;
  }
  /**
   * <pre>
   * The page language as determined by its textual content. An ISO 639 language
   * code (two letters, except for Chinese where a localization is necessary).
   * </pre>
   *
   * <code>optional string page_language = 30;</code>
   */
  private void clearPageLanguage() {
    bitField0_ = (bitField0_ & ~0x01000000);
    pageLanguage_ = getDefaultInstance().getPageLanguage();
  }
  /**
   * <pre>
   * The page language as determined by its textual content. An ISO 639 language
   * code (two letters, except for Chinese where a localization is necessary).
   * </pre>
   *
   * <code>optional string page_language = 30;</code>
   */
  private void setPageLanguageBytes(
      com.google.protobuf.ByteString value) {
    if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x01000000;
    pageLanguage_ = value.toStringUtf8();
  }

  public void writeTo(com.google.protobuf.CodedOutputStream output)
                      throws java.io.IOException {
    if (((bitField0_ & 0x00000001) == 0x00000001)) {
      output.writeString(2, getVirtualUrl());
    }
    if (((bitField0_ & 0x00000002) == 0x00000002)) {
      output.writeString(3, getReferrer());
    }
    if (((bitField0_ & 0x00000004) == 0x00000004)) {
      output.writeString(4, getTitle());
    }
    if (((bitField0_ & 0x00000008) == 0x00000008)) {
      output.writeEnum(6, pageTransition_);
    }
    if (((bitField0_ & 0x00000010) == 0x00000010)) {
      output.writeEnum(7, redirectType_);
    }
    if (((bitField0_ & 0x00000020) == 0x00000020)) {
      output.writeInt32(8, uniqueId_);
    }
    if (((bitField0_ & 0x00000040) == 0x00000040)) {
      output.writeInt64(9, timestampMsec_);
    }
    if (((bitField0_ & 0x00000080) == 0x00000080)) {
      output.writeBool(10, navigationForwardBack_);
    }
    if (((bitField0_ & 0x00000100) == 0x00000100)) {
      output.writeBool(11, navigationFromAddressBar_);
    }
    if (((bitField0_ & 0x00000200) == 0x00000200)) {
      output.writeBool(12, navigationHomePage_);
    }
    if (((bitField0_ & 0x00000400) == 0x00000400)) {
      output.writeBool(13, navigationChainStart_);
    }
    if (((bitField0_ & 0x00000800) == 0x00000800)) {
      output.writeBool(14, navigationChainEnd_);
    }
    if (((bitField0_ & 0x00001000) == 0x00001000)) {
      output.writeInt64(15, globalId_);
    }
    if (((bitField0_ & 0x00002000) == 0x00002000)) {
      output.writeString(16, getSearchTerms());
    }
    if (((bitField0_ & 0x00004000) == 0x00004000)) {
      output.writeString(17, getFaviconUrl());
    }
    if (((bitField0_ & 0x00008000) == 0x00008000)) {
      output.writeEnum(18, blockedState_);
    }
    for (int i = 0; i < contentPackCategories_.size(); i++) {
      output.writeString(19, contentPackCategories_.get(i));
    }
    if (((bitField0_ & 0x00010000) == 0x00010000)) {
      output.writeInt32(20, httpStatusCode_);
    }
    if (((bitField0_ & 0x00020000) == 0x00020000)) {
      output.writeInt32(21, obsoleteReferrerPolicy_);
    }
    if (((bitField0_ & 0x00040000) == 0x00040000)) {
      output.writeBool(22, isRestored_);
    }
    for (int i = 0; i < navigationRedirect_.size(); i++) {
      output.writeMessage(23, navigationRedirect_.get(i));
    }
    if (((bitField0_ & 0x00080000) == 0x00080000)) {
      output.writeString(24, getLastNavigationRedirectUrl());
    }
    if (((bitField0_ & 0x00100000) == 0x00100000)) {
      output.writeInt32(25, correctReferrerPolicy_);
    }
    if (((bitField0_ & 0x00200000) == 0x00200000)) {
      output.writeEnum(26, passwordState_);
    }
    if (((bitField0_ & 0x00400000) == 0x00400000)) {
      output.writeInt64(27, taskId_);
    }
    for (int i = 0; i < ancestorTaskId_.size(); i++) {
      output.writeInt64(28, ancestorTaskId_.getLong(i));
    }
    if (((bitField0_ & 0x00800000) == 0x00800000)) {
      output.writeMessage(29, getReplacedNavigation());
    }
    if (((bitField0_ & 0x01000000) == 0x01000000)) {
      output.writeString(30, getPageLanguage());
    }
    unknownFields.writeTo(output);
  }

  public int getSerializedSize() {
    int size = memoizedSerializedSize;
    if (size != -1) return size;

    size = 0;
    if (((bitField0_ & 0x00000001) == 0x00000001)) {
      size += com.google.protobuf.CodedOutputStream
        .computeStringSize(2, getVirtualUrl());
    }
    if (((bitField0_ & 0x00000002) == 0x00000002)) {
      size += com.google.protobuf.CodedOutputStream
        .computeStringSize(3, getReferrer());
    }
    if (((bitField0_ & 0x00000004) == 0x00000004)) {
      size += com.google.protobuf.CodedOutputStream
        .computeStringSize(4, getTitle());
    }
    if (((bitField0_ & 0x00000008) == 0x00000008)) {
      size += com.google.protobuf.CodedOutputStream
        .computeEnumSize(6, pageTransition_);
    }
    if (((bitField0_ & 0x00000010) == 0x00000010)) {
      size += com.google.protobuf.CodedOutputStream
        .computeEnumSize(7, redirectType_);
    }
    if (((bitField0_ & 0x00000020) == 0x00000020)) {
      size += com.google.protobuf.CodedOutputStream
        .computeInt32Size(8, uniqueId_);
    }
    if (((bitField0_ & 0x00000040) == 0x00000040)) {
      size += com.google.protobuf.CodedOutputStream
        .computeInt64Size(9, timestampMsec_);
    }
    if (((bitField0_ & 0x00000080) == 0x00000080)) {
      size += com.google.protobuf.CodedOutputStream
        .computeBoolSize(10, navigationForwardBack_);
    }
    if (((bitField0_ & 0x00000100) == 0x00000100)) {
      size += com.google.protobuf.CodedOutputStream
        .computeBoolSize(11, navigationFromAddressBar_);
    }
    if (((bitField0_ & 0x00000200) == 0x00000200)) {
      size += com.google.protobuf.CodedOutputStream
        .computeBoolSize(12, navigationHomePage_);
    }
    if (((bitField0_ & 0x00000400) == 0x00000400)) {
      size += com.google.protobuf.CodedOutputStream
        .computeBoolSize(13, navigationChainStart_);
    }
    if (((bitField0_ & 0x00000800) == 0x00000800)) {
      size += com.google.protobuf.CodedOutputStream
        .computeBoolSize(14, navigationChainEnd_);
    }
    if (((bitField0_ & 0x00001000) == 0x00001000)) {
      size += com.google.protobuf.CodedOutputStream
        .computeInt64Size(15, globalId_);
    }
    if (((bitField0_ & 0x00002000) == 0x00002000)) {
      size += com.google.protobuf.CodedOutputStream
        .computeStringSize(16, getSearchTerms());
    }
    if (((bitField0_ & 0x00004000) == 0x00004000)) {
      size += com.google.protobuf.CodedOutputStream
        .computeStringSize(17, getFaviconUrl());
    }
    if (((bitField0_ & 0x00008000) == 0x00008000)) {
      size += com.google.protobuf.CodedOutputStream
        .computeEnumSize(18, blockedState_);
    }
    {
      int dataSize = 0;
      for (int i = 0; i < contentPackCategories_.size(); i++) {
        dataSize += com.google.protobuf.CodedOutputStream
          .computeStringSizeNoTag(contentPackCategories_.get(i));
      }
      size += dataSize;
      size += 2 * getContentPackCategoriesList().size();
    }
    if (((bitField0_ & 0x00010000) == 0x00010000)) {
      size += com.google.protobuf.CodedOutputStream
        .computeInt32Size(20, httpStatusCode_);
    }
    if (((bitField0_ & 0x00020000) == 0x00020000)) {
      size += com.google.protobuf.CodedOutputStream
        .computeInt32Size(21, obsoleteReferrerPolicy_);
    }
    if (((bitField0_ & 0x00040000) == 0x00040000)) {
      size += com.google.protobuf.CodedOutputStream
        .computeBoolSize(22, isRestored_);
    }
    for (int i = 0; i < navigationRedirect_.size(); i++) {
      size += com.google.protobuf.CodedOutputStream
        .computeMessageSize(23, navigationRedirect_.get(i));
    }
    if (((bitField0_ & 0x00080000) == 0x00080000)) {
      size += com.google.protobuf.CodedOutputStream
        .computeStringSize(24, getLastNavigationRedirectUrl());
    }
    if (((bitField0_ & 0x00100000) == 0x00100000)) {
      size += com.google.protobuf.CodedOutputStream
        .computeInt32Size(25, correctReferrerPolicy_);
    }
    if (((bitField0_ & 0x00200000) == 0x00200000)) {
      size += com.google.protobuf.CodedOutputStream
        .computeEnumSize(26, passwordState_);
    }
    if (((bitField0_ & 0x00400000) == 0x00400000)) {
      size += com.google.protobuf.CodedOutputStream
        .computeInt64Size(27, taskId_);
    }
    {
      int dataSize = 0;
      for (int i = 0; i < ancestorTaskId_.size(); i++) {
        dataSize += com.google.protobuf.CodedOutputStream
          .computeInt64SizeNoTag(ancestorTaskId_.getLong(i));
      }
      size += dataSize;
      size += 2 * getAncestorTaskIdList().size();
    }
    if (((bitField0_ & 0x00800000) == 0x00800000)) {
      size += com.google.protobuf.CodedOutputStream
        .computeMessageSize(29, getReplacedNavigation());
    }
    if (((bitField0_ & 0x01000000) == 0x01000000)) {
      size += com.google.protobuf.CodedOutputStream
        .computeStringSize(30, getPageLanguage());
    }
    size += unknownFields.getSerializedSize();
    memoizedSerializedSize = size;
    return size;
  }

  public static org.chromium.components.sync.protocol.TabNavigation parseFrom(
      com.google.protobuf.ByteString data)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, data);
  }
  public static org.chromium.components.sync.protocol.TabNavigation parseFrom(
      com.google.protobuf.ByteString data,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, data, extensionRegistry);
  }
  public static org.chromium.components.sync.protocol.TabNavigation parseFrom(byte[] data)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, data);
  }
  public static org.chromium.components.sync.protocol.TabNavigation parseFrom(
      byte[] data,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, data, extensionRegistry);
  }
  public static org.chromium.components.sync.protocol.TabNavigation parseFrom(java.io.InputStream input)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, input);
  }
  public static org.chromium.components.sync.protocol.TabNavigation parseFrom(
      java.io.InputStream input,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, input, extensionRegistry);
  }
  public static org.chromium.components.sync.protocol.TabNavigation parseDelimitedFrom(java.io.InputStream input)
      throws java.io.IOException {
    return parseDelimitedFrom(DEFAULT_INSTANCE, input);
  }
  public static org.chromium.components.sync.protocol.TabNavigation parseDelimitedFrom(
      java.io.InputStream input,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws java.io.IOException {
    return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
  }
  public static org.chromium.components.sync.protocol.TabNavigation parseFrom(
      com.google.protobuf.CodedInputStream input)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, input);
  }
  public static org.chromium.components.sync.protocol.TabNavigation parseFrom(
      com.google.protobuf.CodedInputStream input,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, input, extensionRegistry);
  }

  public static Builder newBuilder() {
    return DEFAULT_INSTANCE.toBuilder();
  }
  public static Builder newBuilder(org.chromium.components.sync.protocol.TabNavigation prototype) {
    return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
  }

  /**
   * Protobuf type {@code sync_pb.TabNavigation}
   */
  public static final class Builder extends
      com.google.protobuf.GeneratedMessageLite.Builder<
        org.chromium.components.sync.protocol.TabNavigation, Builder> implements
      // @@protoc_insertion_point(builder_implements:sync_pb.TabNavigation)
      org.chromium.components.sync.protocol.TabNavigationOrBuilder {
    // Construct using org.chromium.components.sync.protocol.TabNavigation.newBuilder()
    private Builder() {
      super(DEFAULT_INSTANCE);
    }


    /**
     * <pre>
     * The index in the NavigationController. If this is -1, it means this
     * TabNavigation is bogus.
     * optional int32 index = 1 [default = -1];  // obsolete.
     * The virtual URL, when nonempty, will override the actual URL of the page
     * when we display it to the user.
     * </pre>
     *
     * <code>optional string virtual_url = 2;</code>
     */
    public boolean hasVirtualUrl() {
      return instance.hasVirtualUrl();
    }
    /**
     * <pre>
     * The index in the NavigationController. If this is -1, it means this
     * TabNavigation is bogus.
     * optional int32 index = 1 [default = -1];  // obsolete.
     * The virtual URL, when nonempty, will override the actual URL of the page
     * when we display it to the user.
     * </pre>
     *
     * <code>optional string virtual_url = 2;</code>
     */
    public java.lang.String getVirtualUrl() {
      return instance.getVirtualUrl();
    }
    /**
     * <pre>
     * The index in the NavigationController. If this is -1, it means this
     * TabNavigation is bogus.
     * optional int32 index = 1 [default = -1];  // obsolete.
     * The virtual URL, when nonempty, will override the actual URL of the page
     * when we display it to the user.
     * </pre>
     *
     * <code>optional string virtual_url = 2;</code>
     */
    public com.google.protobuf.ByteString
        getVirtualUrlBytes() {
      return instance.getVirtualUrlBytes();
    }
    /**
     * <pre>
     * The index in the NavigationController. If this is -1, it means this
     * TabNavigation is bogus.
     * optional int32 index = 1 [default = -1];  // obsolete.
     * The virtual URL, when nonempty, will override the actual URL of the page
     * when we display it to the user.
     * </pre>
     *
     * <code>optional string virtual_url = 2;</code>
     */
    public Builder setVirtualUrl(
        java.lang.String value) {
      copyOnWrite();
      instance.setVirtualUrl(value);
      return this;
    }
    /**
     * <pre>
     * The index in the NavigationController. If this is -1, it means this
     * TabNavigation is bogus.
     * optional int32 index = 1 [default = -1];  // obsolete.
     * The virtual URL, when nonempty, will override the actual URL of the page
     * when we display it to the user.
     * </pre>
     *
     * <code>optional string virtual_url = 2;</code>
     */
    public Builder clearVirtualUrl() {
      copyOnWrite();
      instance.clearVirtualUrl();
      return this;
    }
    /**
     * <pre>
     * The index in the NavigationController. If this is -1, it means this
     * TabNavigation is bogus.
     * optional int32 index = 1 [default = -1];  // obsolete.
     * The virtual URL, when nonempty, will override the actual URL of the page
     * when we display it to the user.
     * </pre>
     *
     * <code>optional string virtual_url = 2;</code>
     */
    public Builder setVirtualUrlBytes(
        com.google.protobuf.ByteString value) {
      copyOnWrite();
      instance.setVirtualUrlBytes(value);
      return this;
    }

    /**
     * <pre>
     * The referring URL, which can be empty.
     * </pre>
     *
     * <code>optional string referrer = 3;</code>
     */
    public boolean hasReferrer() {
      return instance.hasReferrer();
    }
    /**
     * <pre>
     * The referring URL, which can be empty.
     * </pre>
     *
     * <code>optional string referrer = 3;</code>
     */
    public java.lang.String getReferrer() {
      return instance.getReferrer();
    }
    /**
     * <pre>
     * The referring URL, which can be empty.
     * </pre>
     *
     * <code>optional string referrer = 3;</code>
     */
    public com.google.protobuf.ByteString
        getReferrerBytes() {
      return instance.getReferrerBytes();
    }
    /**
     * <pre>
     * The referring URL, which can be empty.
     * </pre>
     *
     * <code>optional string referrer = 3;</code>
     */
    public Builder setReferrer(
        java.lang.String value) {
      copyOnWrite();
      instance.setReferrer(value);
      return this;
    }
    /**
     * <pre>
     * The referring URL, which can be empty.
     * </pre>
     *
     * <code>optional string referrer = 3;</code>
     */
    public Builder clearReferrer() {
      copyOnWrite();
      instance.clearReferrer();
      return this;
    }
    /**
     * <pre>
     * The referring URL, which can be empty.
     * </pre>
     *
     * <code>optional string referrer = 3;</code>
     */
    public Builder setReferrerBytes(
        com.google.protobuf.ByteString value) {
      copyOnWrite();
      instance.setReferrerBytes(value);
      return this;
    }

    /**
     * <pre>
     * The title of the page.
     * </pre>
     *
     * <code>optional string title = 4;</code>
     */
    public boolean hasTitle() {
      return instance.hasTitle();
    }
    /**
     * <pre>
     * The title of the page.
     * </pre>
     *
     * <code>optional string title = 4;</code>
     */
    public java.lang.String getTitle() {
      return instance.getTitle();
    }
    /**
     * <pre>
     * The title of the page.
     * </pre>
     *
     * <code>optional string title = 4;</code>
     */
    public com.google.protobuf.ByteString
        getTitleBytes() {
      return instance.getTitleBytes();
    }
    /**
     * <pre>
     * The title of the page.
     * </pre>
     *
     * <code>optional string title = 4;</code>
     */
    public Builder setTitle(
        java.lang.String value) {
      copyOnWrite();
      instance.setTitle(value);
      return this;
    }
    /**
     * <pre>
     * The title of the page.
     * </pre>
     *
     * <code>optional string title = 4;</code>
     */
    public Builder clearTitle() {
      copyOnWrite();
      instance.clearTitle();
      return this;
    }
    /**
     * <pre>
     * The title of the page.
     * </pre>
     *
     * <code>optional string title = 4;</code>
     */
    public Builder setTitleBytes(
        com.google.protobuf.ByteString value) {
      copyOnWrite();
      instance.setTitleBytes(value);
      return this;
    }

    /**
     * <pre>
     * Content state is an opaque blob created by WebKit that represents the
     * state of the page. This includes form entries and scroll position for each
     * frame.
     * optional string state = 5;  // obsolete.
     * The core transition type.
     * </pre>
     *
     * <code>optional .sync_pb.SyncEnums.PageTransition page_transition = 6 [default = LINK];</code>
     */
    public boolean hasPageTransition() {
      return instance.hasPageTransition();
    }
    /**
     * <pre>
     * Content state is an opaque blob created by WebKit that represents the
     * state of the page. This includes form entries and scroll position for each
     * frame.
     * optional string state = 5;  // obsolete.
     * The core transition type.
     * </pre>
     *
     * <code>optional .sync_pb.SyncEnums.PageTransition page_transition = 6 [default = LINK];</code>
     */
    public org.chromium.components.sync.protocol.SyncEnums.PageTransition getPageTransition() {
      return instance.getPageTransition();
    }
    /**
     * <pre>
     * Content state is an opaque blob created by WebKit that represents the
     * state of the page. This includes form entries and scroll position for each
     * frame.
     * optional string state = 5;  // obsolete.
     * The core transition type.
     * </pre>
     *
     * <code>optional .sync_pb.SyncEnums.PageTransition page_transition = 6 [default = LINK];</code>
     */
    public Builder setPageTransition(org.chromium.components.sync.protocol.SyncEnums.PageTransition value) {
      copyOnWrite();
      instance.setPageTransition(value);
      return this;
    }
    /**
     * <pre>
     * Content state is an opaque blob created by WebKit that represents the
     * state of the page. This includes form entries and scroll position for each
     * frame.
     * optional string state = 5;  // obsolete.
     * The core transition type.
     * </pre>
     *
     * <code>optional .sync_pb.SyncEnums.PageTransition page_transition = 6 [default = LINK];</code>
     */
    public Builder clearPageTransition() {
      copyOnWrite();
      instance.clearPageTransition();
      return this;
    }

    /**
     * <pre>
     * If this transition was triggered by a redirect, the redirect type.
     * </pre>
     *
     * <code>optional .sync_pb.SyncEnums.PageTransitionRedirectType redirect_type = 7;</code>
     */
    public boolean hasRedirectType() {
      return instance.hasRedirectType();
    }
    /**
     * <pre>
     * If this transition was triggered by a redirect, the redirect type.
     * </pre>
     *
     * <code>optional .sync_pb.SyncEnums.PageTransitionRedirectType redirect_type = 7;</code>
     */
    public org.chromium.components.sync.protocol.SyncEnums.PageTransitionRedirectType getRedirectType() {
      return instance.getRedirectType();
    }
    /**
     * <pre>
     * If this transition was triggered by a redirect, the redirect type.
     * </pre>
     *
     * <code>optional .sync_pb.SyncEnums.PageTransitionRedirectType redirect_type = 7;</code>
     */
    public Builder setRedirectType(org.chromium.components.sync.protocol.SyncEnums.PageTransitionRedirectType value) {
      copyOnWrite();
      instance.setRedirectType(value);
      return this;
    }
    /**
     * <pre>
     * If this transition was triggered by a redirect, the redirect type.
     * </pre>
     *
     * <code>optional .sync_pb.SyncEnums.PageTransitionRedirectType redirect_type = 7;</code>
     */
    public Builder clearRedirectType() {
      copyOnWrite();
      instance.clearRedirectType();
      return this;
    }

    /**
     * <pre>
     * The unique navigation id (within this client).
     * </pre>
     *
     * <code>optional int32 unique_id = 8;</code>
     */
    public boolean hasUniqueId() {
      return instance.hasUniqueId();
    }
    /**
     * <pre>
     * The unique navigation id (within this client).
     * </pre>
     *
     * <code>optional int32 unique_id = 8;</code>
     */
    public int getUniqueId() {
      return instance.getUniqueId();
    }
    /**
     * <pre>
     * The unique navigation id (within this client).
     * </pre>
     *
     * <code>optional int32 unique_id = 8;</code>
     */
    public Builder setUniqueId(int value) {
      copyOnWrite();
      instance.setUniqueId(value);
      return this;
    }
    /**
     * <pre>
     * The unique navigation id (within this client).
     * </pre>
     *
     * <code>optional int32 unique_id = 8;</code>
     */
    public Builder clearUniqueId() {
      copyOnWrite();
      instance.clearUniqueId();
      return this;
    }

    /**
     * <pre>
     * Timestamp for when this navigation last occurred (in client time).
     * If the user goes back/forward in history the timestamp may refresh.
     * </pre>
     *
     * <code>optional int64 timestamp_msec = 9;</code>
     */
    public boolean hasTimestampMsec() {
      return instance.hasTimestampMsec();
    }
    /**
     * <pre>
     * Timestamp for when this navigation last occurred (in client time).
     * If the user goes back/forward in history the timestamp may refresh.
     * </pre>
     *
     * <code>optional int64 timestamp_msec = 9;</code>
     */
    public long getTimestampMsec() {
      return instance.getTimestampMsec();
    }
    /**
     * <pre>
     * Timestamp for when this navigation last occurred (in client time).
     * If the user goes back/forward in history the timestamp may refresh.
     * </pre>
     *
     * <code>optional int64 timestamp_msec = 9;</code>
     */
    public Builder setTimestampMsec(long value) {
      copyOnWrite();
      instance.setTimestampMsec(value);
      return this;
    }
    /**
     * <pre>
     * Timestamp for when this navigation last occurred (in client time).
     * If the user goes back/forward in history the timestamp may refresh.
     * </pre>
     *
     * <code>optional int64 timestamp_msec = 9;</code>
     */
    public Builder clearTimestampMsec() {
      copyOnWrite();
      instance.clearTimestampMsec();
      return this;
    }

    /**
     * <pre>
     * User used the Forward or Back button to navigate among browsing history.
     * </pre>
     *
     * <code>optional bool navigation_forward_back = 10;</code>
     */
    public boolean hasNavigationForwardBack() {
      return instance.hasNavigationForwardBack();
    }
    /**
     * <pre>
     * User used the Forward or Back button to navigate among browsing history.
     * </pre>
     *
     * <code>optional bool navigation_forward_back = 10;</code>
     */
    public boolean getNavigationForwardBack() {
      return instance.getNavigationForwardBack();
    }
    /**
     * <pre>
     * User used the Forward or Back button to navigate among browsing history.
     * </pre>
     *
     * <code>optional bool navigation_forward_back = 10;</code>
     */
    public Builder setNavigationForwardBack(boolean value) {
      copyOnWrite();
      instance.setNavigationForwardBack(value);
      return this;
    }
    /**
     * <pre>
     * User used the Forward or Back button to navigate among browsing history.
     * </pre>
     *
     * <code>optional bool navigation_forward_back = 10;</code>
     */
    public Builder clearNavigationForwardBack() {
      copyOnWrite();
      instance.clearNavigationForwardBack();
      return this;
    }

    /**
     * <pre>
     * User used the address bar to trigger this navigation.
     * </pre>
     *
     * <code>optional bool navigation_from_address_bar = 11;</code>
     */
    public boolean hasNavigationFromAddressBar() {
      return instance.hasNavigationFromAddressBar();
    }
    /**
     * <pre>
     * User used the address bar to trigger this navigation.
     * </pre>
     *
     * <code>optional bool navigation_from_address_bar = 11;</code>
     */
    public boolean getNavigationFromAddressBar() {
      return instance.getNavigationFromAddressBar();
    }
    /**
     * <pre>
     * User used the address bar to trigger this navigation.
     * </pre>
     *
     * <code>optional bool navigation_from_address_bar = 11;</code>
     */
    public Builder setNavigationFromAddressBar(boolean value) {
      copyOnWrite();
      instance.setNavigationFromAddressBar(value);
      return this;
    }
    /**
     * <pre>
     * User used the address bar to trigger this navigation.
     * </pre>
     *
     * <code>optional bool navigation_from_address_bar = 11;</code>
     */
    public Builder clearNavigationFromAddressBar() {
      copyOnWrite();
      instance.clearNavigationFromAddressBar();
      return this;
    }

    /**
     * <pre>
     * User is navigating to the home page.
     * </pre>
     *
     * <code>optional bool navigation_home_page = 12;</code>
     */
    public boolean hasNavigationHomePage() {
      return instance.hasNavigationHomePage();
    }
    /**
     * <pre>
     * User is navigating to the home page.
     * </pre>
     *
     * <code>optional bool navigation_home_page = 12;</code>
     */
    public boolean getNavigationHomePage() {
      return instance.getNavigationHomePage();
    }
    /**
     * <pre>
     * User is navigating to the home page.
     * </pre>
     *
     * <code>optional bool navigation_home_page = 12;</code>
     */
    public Builder setNavigationHomePage(boolean value) {
      copyOnWrite();
      instance.setNavigationHomePage(value);
      return this;
    }
    /**
     * <pre>
     * User is navigating to the home page.
     * </pre>
     *
     * <code>optional bool navigation_home_page = 12;</code>
     */
    public Builder clearNavigationHomePage() {
      copyOnWrite();
      instance.clearNavigationHomePage();
      return this;
    }

    /**
     * <pre>
     * The beginning of a navigation chain.
     * </pre>
     *
     * <code>optional bool navigation_chain_start = 13;</code>
     */
    public boolean hasNavigationChainStart() {
      return instance.hasNavigationChainStart();
    }
    /**
     * <pre>
     * The beginning of a navigation chain.
     * </pre>
     *
     * <code>optional bool navigation_chain_start = 13;</code>
     */
    public boolean getNavigationChainStart() {
      return instance.getNavigationChainStart();
    }
    /**
     * <pre>
     * The beginning of a navigation chain.
     * </pre>
     *
     * <code>optional bool navigation_chain_start = 13;</code>
     */
    public Builder setNavigationChainStart(boolean value) {
      copyOnWrite();
      instance.setNavigationChainStart(value);
      return this;
    }
    /**
     * <pre>
     * The beginning of a navigation chain.
     * </pre>
     *
     * <code>optional bool navigation_chain_start = 13;</code>
     */
    public Builder clearNavigationChainStart() {
      copyOnWrite();
      instance.clearNavigationChainStart();
      return this;
    }

    /**
     * <pre>
     * The last transition in a redirect chain.
     * </pre>
     *
     * <code>optional bool navigation_chain_end = 14;</code>
     */
    public boolean hasNavigationChainEnd() {
      return instance.hasNavigationChainEnd();
    }
    /**
     * <pre>
     * The last transition in a redirect chain.
     * </pre>
     *
     * <code>optional bool navigation_chain_end = 14;</code>
     */
    public boolean getNavigationChainEnd() {
      return instance.getNavigationChainEnd();
    }
    /**
     * <pre>
     * The last transition in a redirect chain.
     * </pre>
     *
     * <code>optional bool navigation_chain_end = 14;</code>
     */
    public Builder setNavigationChainEnd(boolean value) {
      copyOnWrite();
      instance.setNavigationChainEnd(value);
      return this;
    }
    /**
     * <pre>
     * The last transition in a redirect chain.
     * </pre>
     *
     * <code>optional bool navigation_chain_end = 14;</code>
     */
    public Builder clearNavigationChainEnd() {
      copyOnWrite();
      instance.clearNavigationChainEnd();
      return this;
    }

    /**
     * <pre>
     * The id for this navigation, which is globally unique with high
     * probability.
     * </pre>
     *
     * <code>optional int64 global_id = 15;</code>
     */
    public boolean hasGlobalId() {
      return instance.hasGlobalId();
    }
    /**
     * <pre>
     * The id for this navigation, which is globally unique with high
     * probability.
     * </pre>
     *
     * <code>optional int64 global_id = 15;</code>
     */
    public long getGlobalId() {
      return instance.getGlobalId();
    }
    /**
     * <pre>
     * The id for this navigation, which is globally unique with high
     * probability.
     * </pre>
     *
     * <code>optional int64 global_id = 15;</code>
     */
    public Builder setGlobalId(long value) {
      copyOnWrite();
      instance.setGlobalId(value);
      return this;
    }
    /**
     * <pre>
     * The id for this navigation, which is globally unique with high
     * probability.
     * </pre>
     *
     * <code>optional int64 global_id = 15;</code>
     */
    public Builder clearGlobalId() {
      copyOnWrite();
      instance.clearGlobalId();
      return this;
    }

    /**
     * <pre>
     * Search terms extracted from the URL.
     * </pre>
     *
     * <code>optional string search_terms = 16 [deprecated = true];</code>
     */
    @java.lang.Deprecated public boolean hasSearchTerms() {
      return instance.hasSearchTerms();
    }
    /**
     * <pre>
     * Search terms extracted from the URL.
     * </pre>
     *
     * <code>optional string search_terms = 16 [deprecated = true];</code>
     */
    @java.lang.Deprecated public java.lang.String getSearchTerms() {
      return instance.getSearchTerms();
    }
    /**
     * <pre>
     * Search terms extracted from the URL.
     * </pre>
     *
     * <code>optional string search_terms = 16 [deprecated = true];</code>
     */
    @java.lang.Deprecated public com.google.protobuf.ByteString
        getSearchTermsBytes() {
      return instance.getSearchTermsBytes();
    }
    /**
     * <pre>
     * Search terms extracted from the URL.
     * </pre>
     *
     * <code>optional string search_terms = 16 [deprecated = true];</code>
     */
    @java.lang.Deprecated public Builder setSearchTerms(
        java.lang.String value) {
      copyOnWrite();
      instance.setSearchTerms(value);
      return this;
    }
    /**
     * <pre>
     * Search terms extracted from the URL.
     * </pre>
     *
     * <code>optional string search_terms = 16 [deprecated = true];</code>
     */
    @java.lang.Deprecated public Builder clearSearchTerms() {
      copyOnWrite();
      instance.clearSearchTerms();
      return this;
    }
    /**
     * <pre>
     * Search terms extracted from the URL.
     * </pre>
     *
     * <code>optional string search_terms = 16 [deprecated = true];</code>
     */
    @java.lang.Deprecated public Builder setSearchTermsBytes(
        com.google.protobuf.ByteString value) {
      copyOnWrite();
      instance.setSearchTermsBytes(value);
      return this;
    }

    /**
     * <pre>
     * The favicon url associated with this page.
     * </pre>
     *
     * <code>optional string favicon_url = 17;</code>
     */
    public boolean hasFaviconUrl() {
      return instance.hasFaviconUrl();
    }
    /**
     * <pre>
     * The favicon url associated with this page.
     * </pre>
     *
     * <code>optional string favicon_url = 17;</code>
     */
    public java.lang.String getFaviconUrl() {
      return instance.getFaviconUrl();
    }
    /**
     * <pre>
     * The favicon url associated with this page.
     * </pre>
     *
     * <code>optional string favicon_url = 17;</code>
     */
    public com.google.protobuf.ByteString
        getFaviconUrlBytes() {
      return instance.getFaviconUrlBytes();
    }
    /**
     * <pre>
     * The favicon url associated with this page.
     * </pre>
     *
     * <code>optional string favicon_url = 17;</code>
     */
    public Builder setFaviconUrl(
        java.lang.String value) {
      copyOnWrite();
      instance.setFaviconUrl(value);
      return this;
    }
    /**
     * <pre>
     * The favicon url associated with this page.
     * </pre>
     *
     * <code>optional string favicon_url = 17;</code>
     */
    public Builder clearFaviconUrl() {
      copyOnWrite();
      instance.clearFaviconUrl();
      return this;
    }
    /**
     * <pre>
     * The favicon url associated with this page.
     * </pre>
     *
     * <code>optional string favicon_url = 17;</code>
     */
    public Builder setFaviconUrlBytes(
        com.google.protobuf.ByteString value) {
      copyOnWrite();
      instance.setFaviconUrlBytes(value);
      return this;
    }

    /**
     * <pre>
     * Whether access to the URL was allowed or blocked.
     * </pre>
     *
     * <code>optional .sync_pb.TabNavigation.BlockedState blocked_state = 18 [default = STATE_ALLOWED];</code>
     */
    public boolean hasBlockedState() {
      return instance.hasBlockedState();
    }
    /**
     * <pre>
     * Whether access to the URL was allowed or blocked.
     * </pre>
     *
     * <code>optional .sync_pb.TabNavigation.BlockedState blocked_state = 18 [default = STATE_ALLOWED];</code>
     */
    public org.chromium.components.sync.protocol.TabNavigation.BlockedState getBlockedState() {
      return instance.getBlockedState();
    }
    /**
     * <pre>
     * Whether access to the URL was allowed or blocked.
     * </pre>
     *
     * <code>optional .sync_pb.TabNavigation.BlockedState blocked_state = 18 [default = STATE_ALLOWED];</code>
     */
    public Builder setBlockedState(org.chromium.components.sync.protocol.TabNavigation.BlockedState value) {
      copyOnWrite();
      instance.setBlockedState(value);
      return this;
    }
    /**
     * <pre>
     * Whether access to the URL was allowed or blocked.
     * </pre>
     *
     * <code>optional .sync_pb.TabNavigation.BlockedState blocked_state = 18 [default = STATE_ALLOWED];</code>
     */
    public Builder clearBlockedState() {
      copyOnWrite();
      instance.clearBlockedState();
      return this;
    }

    /**
     * <pre>
     * A list of category identifiers for the URL.
     * </pre>
     *
     * <code>repeated string content_pack_categories = 19;</code>
     */
    public java.util.List<String>
        getContentPackCategoriesList() {
      return java.util.Collections.unmodifiableList(
          instance.getContentPackCategoriesList());
    }
    /**
     * <pre>
     * A list of category identifiers for the URL.
     * </pre>
     *
     * <code>repeated string content_pack_categories = 19;</code>
     */
    public int getContentPackCategoriesCount() {
      return instance.getContentPackCategoriesCount();
    }
    /**
     * <pre>
     * A list of category identifiers for the URL.
     * </pre>
     *
     * <code>repeated string content_pack_categories = 19;</code>
     */
    public java.lang.String getContentPackCategories(int index) {
      return instance.getContentPackCategories(index);
    }
    /**
     * <pre>
     * A list of category identifiers for the URL.
     * </pre>
     *
     * <code>repeated string content_pack_categories = 19;</code>
     */
    public com.google.protobuf.ByteString
        getContentPackCategoriesBytes(int index) {
      return instance.getContentPackCategoriesBytes(index);
    }
    /**
     * <pre>
     * A list of category identifiers for the URL.
     * </pre>
     *
     * <code>repeated string content_pack_categories = 19;</code>
     */
    public Builder setContentPackCategories(
        int index, java.lang.String value) {
      copyOnWrite();
      instance.setContentPackCategories(index, value);
      return this;
    }
    /**
     * <pre>
     * A list of category identifiers for the URL.
     * </pre>
     *
     * <code>repeated string content_pack_categories = 19;</code>
     */
    public Builder addContentPackCategories(
        java.lang.String value) {
      copyOnWrite();
      instance.addContentPackCategories(value);
      return this;
    }
    /**
     * <pre>
     * A list of category identifiers for the URL.
     * </pre>
     *
     * <code>repeated string content_pack_categories = 19;</code>
     */
    public Builder addAllContentPackCategories(
        java.lang.Iterable<java.lang.String> values) {
      copyOnWrite();
      instance.addAllContentPackCategories(values);
      return this;
    }
    /**
     * <pre>
     * A list of category identifiers for the URL.
     * </pre>
     *
     * <code>repeated string content_pack_categories = 19;</code>
     */
    public Builder clearContentPackCategories() {
      copyOnWrite();
      instance.clearContentPackCategories();
      return this;
    }
    /**
     * <pre>
     * A list of category identifiers for the URL.
     * </pre>
     *
     * <code>repeated string content_pack_categories = 19;</code>
     */
    public Builder addContentPackCategoriesBytes(
        com.google.protobuf.ByteString value) {
      copyOnWrite();
      instance.addContentPackCategoriesBytes(value);
      return this;
    }

    /**
     * <pre>
     * The status code from the last navigation.
     * </pre>
     *
     * <code>optional int32 http_status_code = 20;</code>
     */
    public boolean hasHttpStatusCode() {
      return instance.hasHttpStatusCode();
    }
    /**
     * <pre>
     * The status code from the last navigation.
     * </pre>
     *
     * <code>optional int32 http_status_code = 20;</code>
     */
    public int getHttpStatusCode() {
      return instance.getHttpStatusCode();
    }
    /**
     * <pre>
     * The status code from the last navigation.
     * </pre>
     *
     * <code>optional int32 http_status_code = 20;</code>
     */
    public Builder setHttpStatusCode(int value) {
      copyOnWrite();
      instance.setHttpStatusCode(value);
      return this;
    }
    /**
     * <pre>
     * The status code from the last navigation.
     * </pre>
     *
     * <code>optional int32 http_status_code = 20;</code>
     */
    public Builder clearHttpStatusCode() {
      copyOnWrite();
      instance.clearHttpStatusCode();
      return this;
    }

    /**
     * <pre>
     * Referrer policy. Old, broken value. Deprecated in M61.
     * </pre>
     *
     * <code>optional int32 obsolete_referrer_policy = 21 [deprecated = true];</code>
     */
    @java.lang.Deprecated public boolean hasObsoleteReferrerPolicy() {
      return instance.hasObsoleteReferrerPolicy();
    }
    /**
     * <pre>
     * Referrer policy. Old, broken value. Deprecated in M61.
     * </pre>
     *
     * <code>optional int32 obsolete_referrer_policy = 21 [deprecated = true];</code>
     */
    @java.lang.Deprecated public int getObsoleteReferrerPolicy() {
      return instance.getObsoleteReferrerPolicy();
    }
    /**
     * <pre>
     * Referrer policy. Old, broken value. Deprecated in M61.
     * </pre>
     *
     * <code>optional int32 obsolete_referrer_policy = 21 [deprecated = true];</code>
     */
    @java.lang.Deprecated public Builder setObsoleteReferrerPolicy(int value) {
      copyOnWrite();
      instance.setObsoleteReferrerPolicy(value);
      return this;
    }
    /**
     * <pre>
     * Referrer policy. Old, broken value. Deprecated in M61.
     * </pre>
     *
     * <code>optional int32 obsolete_referrer_policy = 21 [deprecated = true];</code>
     */
    @java.lang.Deprecated public Builder clearObsoleteReferrerPolicy() {
      copyOnWrite();
      instance.clearObsoleteReferrerPolicy();
      return this;
    }

    /**
     * <pre>
     * True if created from restored navigation entry that hasn't been loaded.
     * </pre>
     *
     * <code>optional bool is_restored = 22;</code>
     */
    public boolean hasIsRestored() {
      return instance.hasIsRestored();
    }
    /**
     * <pre>
     * True if created from restored navigation entry that hasn't been loaded.
     * </pre>
     *
     * <code>optional bool is_restored = 22;</code>
     */
    public boolean getIsRestored() {
      return instance.getIsRestored();
    }
    /**
     * <pre>
     * True if created from restored navigation entry that hasn't been loaded.
     * </pre>
     *
     * <code>optional bool is_restored = 22;</code>
     */
    public Builder setIsRestored(boolean value) {
      copyOnWrite();
      instance.setIsRestored(value);
      return this;
    }
    /**
     * <pre>
     * True if created from restored navigation entry that hasn't been loaded.
     * </pre>
     *
     * <code>optional bool is_restored = 22;</code>
     */
    public Builder clearIsRestored() {
      copyOnWrite();
      instance.clearIsRestored();
      return this;
    }

    /**
     * <pre>
     * The chain of redirections for this navigation, from the original URL
     * through the last URL that redirected.
     * </pre>
     *
     * <code>repeated .sync_pb.NavigationRedirect navigation_redirect = 23;</code>
     */
    public java.util.List<org.chromium.components.sync.protocol.NavigationRedirect> getNavigationRedirectList() {
      return java.util.Collections.unmodifiableList(
          instance.getNavigationRedirectList());
    }
    /**
     * <pre>
     * The chain of redirections for this navigation, from the original URL
     * through the last URL that redirected.
     * </pre>
     *
     * <code>repeated .sync_pb.NavigationRedirect navigation_redirect = 23;</code>
     */
    public int getNavigationRedirectCount() {
      return instance.getNavigationRedirectCount();
    }/**
     * <pre>
     * The chain of redirections for this navigation, from the original URL
     * through the last URL that redirected.
     * </pre>
     *
     * <code>repeated .sync_pb.NavigationRedirect navigation_redirect = 23;</code>
     */
    public org.chromium.components.sync.protocol.NavigationRedirect getNavigationRedirect(int index) {
      return instance.getNavigationRedirect(index);
    }
    /**
     * <pre>
     * The chain of redirections for this navigation, from the original URL
     * through the last URL that redirected.
     * </pre>
     *
     * <code>repeated .sync_pb.NavigationRedirect navigation_redirect = 23;</code>
     */
    public Builder setNavigationRedirect(
        int index, org.chromium.components.sync.protocol.NavigationRedirect value) {
      copyOnWrite();
      instance.setNavigationRedirect(index, value);
      return this;
    }
    /**
     * <pre>
     * The chain of redirections for this navigation, from the original URL
     * through the last URL that redirected.
     * </pre>
     *
     * <code>repeated .sync_pb.NavigationRedirect navigation_redirect = 23;</code>
     */
    public Builder setNavigationRedirect(
        int index, org.chromium.components.sync.protocol.NavigationRedirect.Builder builderForValue) {
      copyOnWrite();
      instance.setNavigationRedirect(index, builderForValue);
      return this;
    }
    /**
     * <pre>
     * The chain of redirections for this navigation, from the original URL
     * through the last URL that redirected.
     * </pre>
     *
     * <code>repeated .sync_pb.NavigationRedirect navigation_redirect = 23;</code>
     */
    public Builder addNavigationRedirect(org.chromium.components.sync.protocol.NavigationRedirect value) {
      copyOnWrite();
      instance.addNavigationRedirect(value);
      return this;
    }
    /**
     * <pre>
     * The chain of redirections for this navigation, from the original URL
     * through the last URL that redirected.
     * </pre>
     *
     * <code>repeated .sync_pb.NavigationRedirect navigation_redirect = 23;</code>
     */
    public Builder addNavigationRedirect(
        int index, org.chromium.components.sync.protocol.NavigationRedirect value) {
      copyOnWrite();
      instance.addNavigationRedirect(index, value);
      return this;
    }
    /**
     * <pre>
     * The chain of redirections for this navigation, from the original URL
     * through the last URL that redirected.
     * </pre>
     *
     * <code>repeated .sync_pb.NavigationRedirect navigation_redirect = 23;</code>
     */
    public Builder addNavigationRedirect(
        org.chromium.components.sync.protocol.NavigationRedirect.Builder builderForValue) {
      copyOnWrite();
      instance.addNavigationRedirect(builderForValue);
      return this;
    }
    /**
     * <pre>
     * The chain of redirections for this navigation, from the original URL
     * through the last URL that redirected.
     * </pre>
     *
     * <code>repeated .sync_pb.NavigationRedirect navigation_redirect = 23;</code>
     */
    public Builder addNavigationRedirect(
        int index, org.chromium.components.sync.protocol.NavigationRedirect.Builder builderForValue) {
      copyOnWrite();
      instance.addNavigationRedirect(index, builderForValue);
      return this;
    }
    /**
     * <pre>
     * The chain of redirections for this navigation, from the original URL
     * through the last URL that redirected.
     * </pre>
     *
     * <code>repeated .sync_pb.NavigationRedirect navigation_redirect = 23;</code>
     */
    public Builder addAllNavigationRedirect(
        java.lang.Iterable<? extends org.chromium.components.sync.protocol.NavigationRedirect> values) {
      copyOnWrite();
      instance.addAllNavigationRedirect(values);
      return this;
    }
    /**
     * <pre>
     * The chain of redirections for this navigation, from the original URL
     * through the last URL that redirected.
     * </pre>
     *
     * <code>repeated .sync_pb.NavigationRedirect navigation_redirect = 23;</code>
     */
    public Builder clearNavigationRedirect() {
      copyOnWrite();
      instance.clearNavigationRedirect();
      return this;
    }
    /**
     * <pre>
     * The chain of redirections for this navigation, from the original URL
     * through the last URL that redirected.
     * </pre>
     *
     * <code>repeated .sync_pb.NavigationRedirect navigation_redirect = 23;</code>
     */
    public Builder removeNavigationRedirect(int index) {
      copyOnWrite();
      instance.removeNavigationRedirect(index);
      return this;
    }

    /**
     * <pre>
     * Normally not present.
     * The last URL traversed when different from the virtual_url.
     * </pre>
     *
     * <code>optional string last_navigation_redirect_url = 24;</code>
     */
    public boolean hasLastNavigationRedirectUrl() {
      return instance.hasLastNavigationRedirectUrl();
    }
    /**
     * <pre>
     * Normally not present.
     * The last URL traversed when different from the virtual_url.
     * </pre>
     *
     * <code>optional string last_navigation_redirect_url = 24;</code>
     */
    public java.lang.String getLastNavigationRedirectUrl() {
      return instance.getLastNavigationRedirectUrl();
    }
    /**
     * <pre>
     * Normally not present.
     * The last URL traversed when different from the virtual_url.
     * </pre>
     *
     * <code>optional string last_navigation_redirect_url = 24;</code>
     */
    public com.google.protobuf.ByteString
        getLastNavigationRedirectUrlBytes() {
      return instance.getLastNavigationRedirectUrlBytes();
    }
    /**
     * <pre>
     * Normally not present.
     * The last URL traversed when different from the virtual_url.
     * </pre>
     *
     * <code>optional string last_navigation_redirect_url = 24;</code>
     */
    public Builder setLastNavigationRedirectUrl(
        java.lang.String value) {
      copyOnWrite();
      instance.setLastNavigationRedirectUrl(value);
      return this;
    }
    /**
     * <pre>
     * Normally not present.
     * The last URL traversed when different from the virtual_url.
     * </pre>
     *
     * <code>optional string last_navigation_redirect_url = 24;</code>
     */
    public Builder clearLastNavigationRedirectUrl() {
      copyOnWrite();
      instance.clearLastNavigationRedirectUrl();
      return this;
    }
    /**
     * <pre>
     * Normally not present.
     * The last URL traversed when different from the virtual_url.
     * </pre>
     *
     * <code>optional string last_navigation_redirect_url = 24;</code>
     */
    public Builder setLastNavigationRedirectUrlBytes(
        com.google.protobuf.ByteString value) {
      copyOnWrite();
      instance.setLastNavigationRedirectUrlBytes(value);
      return this;
    }

    /**
     * <pre>
     * Correct referrer policy. Valid enums are defined in
     * third_party/WebKit/public/platform/WebReferrerPolicy.h.
     * </pre>
     *
     * <code>optional int32 correct_referrer_policy = 25 [default = 1];</code>
     */
    public boolean hasCorrectReferrerPolicy() {
      return instance.hasCorrectReferrerPolicy();
    }
    /**
     * <pre>
     * Correct referrer policy. Valid enums are defined in
     * third_party/WebKit/public/platform/WebReferrerPolicy.h.
     * </pre>
     *
     * <code>optional int32 correct_referrer_policy = 25 [default = 1];</code>
     */
    public int getCorrectReferrerPolicy() {
      return instance.getCorrectReferrerPolicy();
    }
    /**
     * <pre>
     * Correct referrer policy. Valid enums are defined in
     * third_party/WebKit/public/platform/WebReferrerPolicy.h.
     * </pre>
     *
     * <code>optional int32 correct_referrer_policy = 25 [default = 1];</code>
     */
    public Builder setCorrectReferrerPolicy(int value) {
      copyOnWrite();
      instance.setCorrectReferrerPolicy(value);
      return this;
    }
    /**
     * <pre>
     * Correct referrer policy. Valid enums are defined in
     * third_party/WebKit/public/platform/WebReferrerPolicy.h.
     * </pre>
     *
     * <code>optional int32 correct_referrer_policy = 25 [default = 1];</code>
     */
    public Builder clearCorrectReferrerPolicy() {
      copyOnWrite();
      instance.clearCorrectReferrerPolicy();
      return this;
    }

    /**
     * <pre>
     * Whether the Password Manager saw a password field on the page.
     * </pre>
     *
     * <code>optional .sync_pb.TabNavigation.PasswordState password_state = 26;</code>
     */
    public boolean hasPasswordState() {
      return instance.hasPasswordState();
    }
    /**
     * <pre>
     * Whether the Password Manager saw a password field on the page.
     * </pre>
     *
     * <code>optional .sync_pb.TabNavigation.PasswordState password_state = 26;</code>
     */
    public org.chromium.components.sync.protocol.TabNavigation.PasswordState getPasswordState() {
      return instance.getPasswordState();
    }
    /**
     * <pre>
     * Whether the Password Manager saw a password field on the page.
     * </pre>
     *
     * <code>optional .sync_pb.TabNavigation.PasswordState password_state = 26;</code>
     */
    public Builder setPasswordState(org.chromium.components.sync.protocol.TabNavigation.PasswordState value) {
      copyOnWrite();
      instance.setPasswordState(value);
      return this;
    }
    /**
     * <pre>
     * Whether the Password Manager saw a password field on the page.
     * </pre>
     *
     * <code>optional .sync_pb.TabNavigation.PasswordState password_state = 26;</code>
     */
    public Builder clearPasswordState() {
      copyOnWrite();
      instance.clearPasswordState();
      return this;
    }

    /**
     * <pre>
     * The id for the task associated with this navigation, which is globally
     * unique with high probability.
     * Similar with global_id, but used to identify a navigation in Chrome Tasks,
     * so navigations of a page have the same task_id if one is the first visit of
     * the page, and others are its back/forward visits.
     * </pre>
     *
     * <code>optional int64 task_id = 27;</code>
     */
    public boolean hasTaskId() {
      return instance.hasTaskId();
    }
    /**
     * <pre>
     * The id for the task associated with this navigation, which is globally
     * unique with high probability.
     * Similar with global_id, but used to identify a navigation in Chrome Tasks,
     * so navigations of a page have the same task_id if one is the first visit of
     * the page, and others are its back/forward visits.
     * </pre>
     *
     * <code>optional int64 task_id = 27;</code>
     */
    public long getTaskId() {
      return instance.getTaskId();
    }
    /**
     * <pre>
     * The id for the task associated with this navigation, which is globally
     * unique with high probability.
     * Similar with global_id, but used to identify a navigation in Chrome Tasks,
     * so navigations of a page have the same task_id if one is the first visit of
     * the page, and others are its back/forward visits.
     * </pre>
     *
     * <code>optional int64 task_id = 27;</code>
     */
    public Builder setTaskId(long value) {
      copyOnWrite();
      instance.setTaskId(value);
      return this;
    }
    /**
     * <pre>
     * The id for the task associated with this navigation, which is globally
     * unique with high probability.
     * Similar with global_id, but used to identify a navigation in Chrome Tasks,
     * so navigations of a page have the same task_id if one is the first visit of
     * the page, and others are its back/forward visits.
     * </pre>
     *
     * <code>optional int64 task_id = 27;</code>
     */
    public Builder clearTaskId() {
      copyOnWrite();
      instance.clearTaskId();
      return this;
    }

    /**
     * <pre>
     * Task ids of all ancestor navigations, which can be from other tabs, from
     * root to parent. We define navigation A is parent of navigation B if page of
     * B is got by clicking a link on page of A. This relationship is used to
     * define a Chrome Task as a tree rooted by a navigation.
     * </pre>
     *
     * <code>repeated int64 ancestor_task_id = 28;</code>
     */
    public java.util.List<java.lang.Long>
        getAncestorTaskIdList() {
      return java.util.Collections.unmodifiableList(
          instance.getAncestorTaskIdList());
    }
    /**
     * <pre>
     * Task ids of all ancestor navigations, which can be from other tabs, from
     * root to parent. We define navigation A is parent of navigation B if page of
     * B is got by clicking a link on page of A. This relationship is used to
     * define a Chrome Task as a tree rooted by a navigation.
     * </pre>
     *
     * <code>repeated int64 ancestor_task_id = 28;</code>
     */
    public int getAncestorTaskIdCount() {
      return instance.getAncestorTaskIdCount();
    }
    /**
     * <pre>
     * Task ids of all ancestor navigations, which can be from other tabs, from
     * root to parent. We define navigation A is parent of navigation B if page of
     * B is got by clicking a link on page of A. This relationship is used to
     * define a Chrome Task as a tree rooted by a navigation.
     * </pre>
     *
     * <code>repeated int64 ancestor_task_id = 28;</code>
     */
    public long getAncestorTaskId(int index) {
      return instance.getAncestorTaskId(index);
    }
    /**
     * <pre>
     * Task ids of all ancestor navigations, which can be from other tabs, from
     * root to parent. We define navigation A is parent of navigation B if page of
     * B is got by clicking a link on page of A. This relationship is used to
     * define a Chrome Task as a tree rooted by a navigation.
     * </pre>
     *
     * <code>repeated int64 ancestor_task_id = 28;</code>
     */
    public Builder setAncestorTaskId(
        int index, long value) {
      copyOnWrite();
      instance.setAncestorTaskId(index, value);
      return this;
    }
    /**
     * <pre>
     * Task ids of all ancestor navigations, which can be from other tabs, from
     * root to parent. We define navigation A is parent of navigation B if page of
     * B is got by clicking a link on page of A. This relationship is used to
     * define a Chrome Task as a tree rooted by a navigation.
     * </pre>
     *
     * <code>repeated int64 ancestor_task_id = 28;</code>
     */
    public Builder addAncestorTaskId(long value) {
      copyOnWrite();
      instance.addAncestorTaskId(value);
      return this;
    }
    /**
     * <pre>
     * Task ids of all ancestor navigations, which can be from other tabs, from
     * root to parent. We define navigation A is parent of navigation B if page of
     * B is got by clicking a link on page of A. This relationship is used to
     * define a Chrome Task as a tree rooted by a navigation.
     * </pre>
     *
     * <code>repeated int64 ancestor_task_id = 28;</code>
     */
    public Builder addAllAncestorTaskId(
        java.lang.Iterable<? extends java.lang.Long> values) {
      copyOnWrite();
      instance.addAllAncestorTaskId(values);
      return this;
    }
    /**
     * <pre>
     * Task ids of all ancestor navigations, which can be from other tabs, from
     * root to parent. We define navigation A is parent of navigation B if page of
     * B is got by clicking a link on page of A. This relationship is used to
     * define a Chrome Task as a tree rooted by a navigation.
     * </pre>
     *
     * <code>repeated int64 ancestor_task_id = 28;</code>
     */
    public Builder clearAncestorTaskId() {
      copyOnWrite();
      instance.clearAncestorTaskId();
      return this;
    }

    /**
     * <pre>
     * When a history entry is replaced (e.g. history.replaceState()), this
     * contains some information about the entry prior to being replaced. Even if
     * an entry is replaced multiple times, it represents data prior to the
     * *first* replace.
     * </pre>
     *
     * <code>optional .sync_pb.ReplacedNavigation replaced_navigation = 29;</code>
     */
    public boolean hasReplacedNavigation() {
      return instance.hasReplacedNavigation();
    }
    /**
     * <pre>
     * When a history entry is replaced (e.g. history.replaceState()), this
     * contains some information about the entry prior to being replaced. Even if
     * an entry is replaced multiple times, it represents data prior to the
     * *first* replace.
     * </pre>
     *
     * <code>optional .sync_pb.ReplacedNavigation replaced_navigation = 29;</code>
     */
    public org.chromium.components.sync.protocol.ReplacedNavigation getReplacedNavigation() {
      return instance.getReplacedNavigation();
    }
    /**
     * <pre>
     * When a history entry is replaced (e.g. history.replaceState()), this
     * contains some information about the entry prior to being replaced. Even if
     * an entry is replaced multiple times, it represents data prior to the
     * *first* replace.
     * </pre>
     *
     * <code>optional .sync_pb.ReplacedNavigation replaced_navigation = 29;</code>
     */
    public Builder setReplacedNavigation(org.chromium.components.sync.protocol.ReplacedNavigation value) {
      copyOnWrite();
      instance.setReplacedNavigation(value);
      return this;
      }
    /**
     * <pre>
     * When a history entry is replaced (e.g. history.replaceState()), this
     * contains some information about the entry prior to being replaced. Even if
     * an entry is replaced multiple times, it represents data prior to the
     * *first* replace.
     * </pre>
     *
     * <code>optional .sync_pb.ReplacedNavigation replaced_navigation = 29;</code>
     */
    public Builder setReplacedNavigation(
        org.chromium.components.sync.protocol.ReplacedNavigation.Builder builderForValue) {
      copyOnWrite();
      instance.setReplacedNavigation(builderForValue);
      return this;
    }
    /**
     * <pre>
     * When a history entry is replaced (e.g. history.replaceState()), this
     * contains some information about the entry prior to being replaced. Even if
     * an entry is replaced multiple times, it represents data prior to the
     * *first* replace.
     * </pre>
     *
     * <code>optional .sync_pb.ReplacedNavigation replaced_navigation = 29;</code>
     */
    public Builder mergeReplacedNavigation(org.chromium.components.sync.protocol.ReplacedNavigation value) {
      copyOnWrite();
      instance.mergeReplacedNavigation(value);
      return this;
    }
    /**
     * <pre>
     * When a history entry is replaced (e.g. history.replaceState()), this
     * contains some information about the entry prior to being replaced. Even if
     * an entry is replaced multiple times, it represents data prior to the
     * *first* replace.
     * </pre>
     *
     * <code>optional .sync_pb.ReplacedNavigation replaced_navigation = 29;</code>
     */
    public Builder clearReplacedNavigation() {  copyOnWrite();
      instance.clearReplacedNavigation();
      return this;
    }

    /**
     * <pre>
     * The page language as determined by its textual content. An ISO 639 language
     * code (two letters, except for Chinese where a localization is necessary).
     * </pre>
     *
     * <code>optional string page_language = 30;</code>
     */
    public boolean hasPageLanguage() {
      return instance.hasPageLanguage();
    }
    /**
     * <pre>
     * The page language as determined by its textual content. An ISO 639 language
     * code (two letters, except for Chinese where a localization is necessary).
     * </pre>
     *
     * <code>optional string page_language = 30;</code>
     */
    public java.lang.String getPageLanguage() {
      return instance.getPageLanguage();
    }
    /**
     * <pre>
     * The page language as determined by its textual content. An ISO 639 language
     * code (two letters, except for Chinese where a localization is necessary).
     * </pre>
     *
     * <code>optional string page_language = 30;</code>
     */
    public com.google.protobuf.ByteString
        getPageLanguageBytes() {
      return instance.getPageLanguageBytes();
    }
    /**
     * <pre>
     * The page language as determined by its textual content. An ISO 639 language
     * code (two letters, except for Chinese where a localization is necessary).
     * </pre>
     *
     * <code>optional string page_language = 30;</code>
     */
    public Builder setPageLanguage(
        java.lang.String value) {
      copyOnWrite();
      instance.setPageLanguage(value);
      return this;
    }
    /**
     * <pre>
     * The page language as determined by its textual content. An ISO 639 language
     * code (two letters, except for Chinese where a localization is necessary).
     * </pre>
     *
     * <code>optional string page_language = 30;</code>
     */
    public Builder clearPageLanguage() {
      copyOnWrite();
      instance.clearPageLanguage();
      return this;
    }
    /**
     * <pre>
     * The page language as determined by its textual content. An ISO 639 language
     * code (two letters, except for Chinese where a localization is necessary).
     * </pre>
     *
     * <code>optional string page_language = 30;</code>
     */
    public Builder setPageLanguageBytes(
        com.google.protobuf.ByteString value) {
      copyOnWrite();
      instance.setPageLanguageBytes(value);
      return this;
    }

    // @@protoc_insertion_point(builder_scope:sync_pb.TabNavigation)
  }
  protected final Object dynamicMethod(
      com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
      Object arg0, Object arg1) {
    switch (method) {
      case NEW_MUTABLE_INSTANCE: {
        return new org.chromium.components.sync.protocol.TabNavigation();
      }
      case IS_INITIALIZED: {
        return DEFAULT_INSTANCE;
      }
      case MAKE_IMMUTABLE: {
        contentPackCategories_.makeImmutable();
        navigationRedirect_.makeImmutable();
        ancestorTaskId_.makeImmutable();
        return null;
      }
      case NEW_BUILDER: {
        return new Builder();
      }
      case VISIT: {
        Visitor visitor = (Visitor) arg0;
        org.chromium.components.sync.protocol.TabNavigation other = (org.chromium.components.sync.protocol.TabNavigation) arg1;
        virtualUrl_ = visitor.visitString(
            hasVirtualUrl(), virtualUrl_,
            other.hasVirtualUrl(), other.virtualUrl_);
        referrer_ = visitor.visitString(
            hasReferrer(), referrer_,
            other.hasReferrer(), other.referrer_);
        title_ = visitor.visitString(
            hasTitle(), title_,
            other.hasTitle(), other.title_);
        pageTransition_ = visitor.visitInt(hasPageTransition(), pageTransition_,
            other.hasPageTransition(), other.pageTransition_);
        redirectType_ = visitor.visitInt(hasRedirectType(), redirectType_,
            other.hasRedirectType(), other.redirectType_);
        uniqueId_ = visitor.visitInt(
            hasUniqueId(), uniqueId_,
            other.hasUniqueId(), other.uniqueId_);
        timestampMsec_ = visitor.visitLong(
            hasTimestampMsec(), timestampMsec_,
            other.hasTimestampMsec(), other.timestampMsec_);
        navigationForwardBack_ = visitor.visitBoolean(
            hasNavigationForwardBack(), navigationForwardBack_,
            other.hasNavigationForwardBack(), other.navigationForwardBack_);
        navigationFromAddressBar_ = visitor.visitBoolean(
            hasNavigationFromAddressBar(), navigationFromAddressBar_,
            other.hasNavigationFromAddressBar(), other.navigationFromAddressBar_);
        navigationHomePage_ = visitor.visitBoolean(
            hasNavigationHomePage(), navigationHomePage_,
            other.hasNavigationHomePage(), other.navigationHomePage_);
        navigationChainStart_ = visitor.visitBoolean(
            hasNavigationChainStart(), navigationChainStart_,
            other.hasNavigationChainStart(), other.navigationChainStart_);
        navigationChainEnd_ = visitor.visitBoolean(
            hasNavigationChainEnd(), navigationChainEnd_,
            other.hasNavigationChainEnd(), other.navigationChainEnd_);
        globalId_ = visitor.visitLong(
            hasGlobalId(), globalId_,
            other.hasGlobalId(), other.globalId_);
        searchTerms_ = visitor.visitString(
            hasSearchTerms(), searchTerms_,
            other.hasSearchTerms(), other.searchTerms_);
        faviconUrl_ = visitor.visitString(
            hasFaviconUrl(), faviconUrl_,
            other.hasFaviconUrl(), other.faviconUrl_);
        blockedState_ = visitor.visitInt(hasBlockedState(), blockedState_,
            other.hasBlockedState(), other.blockedState_);
        contentPackCategories_= visitor.visitList(contentPackCategories_, other.contentPackCategories_);
        httpStatusCode_ = visitor.visitInt(
            hasHttpStatusCode(), httpStatusCode_,
            other.hasHttpStatusCode(), other.httpStatusCode_);
        obsoleteReferrerPolicy_ = visitor.visitInt(
            hasObsoleteReferrerPolicy(), obsoleteReferrerPolicy_,
            other.hasObsoleteReferrerPolicy(), other.obsoleteReferrerPolicy_);
        isRestored_ = visitor.visitBoolean(
            hasIsRestored(), isRestored_,
            other.hasIsRestored(), other.isRestored_);
        navigationRedirect_= visitor.visitList(navigationRedirect_, other.navigationRedirect_);
        lastNavigationRedirectUrl_ = visitor.visitString(
            hasLastNavigationRedirectUrl(), lastNavigationRedirectUrl_,
            other.hasLastNavigationRedirectUrl(), other.lastNavigationRedirectUrl_);
        correctReferrerPolicy_ = visitor.visitInt(
            hasCorrectReferrerPolicy(), correctReferrerPolicy_,
            other.hasCorrectReferrerPolicy(), other.correctReferrerPolicy_);
        passwordState_ = visitor.visitInt(hasPasswordState(), passwordState_,
            other.hasPasswordState(), other.passwordState_);
        taskId_ = visitor.visitLong(
            hasTaskId(), taskId_,
            other.hasTaskId(), other.taskId_);
        ancestorTaskId_= visitor.visitLongList(ancestorTaskId_, other.ancestorTaskId_);
        replacedNavigation_ = visitor.visitMessage(replacedNavigation_, other.replacedNavigation_);
        pageLanguage_ = visitor.visitString(
            hasPageLanguage(), pageLanguage_,
            other.hasPageLanguage(), other.pageLanguage_);
        if (visitor == com.google.protobuf.GeneratedMessageLite.MergeFromVisitor
            .INSTANCE) {
          bitField0_ |= other.bitField0_;
        }
        return this;
      }
      case MERGE_FROM_STREAM: {
        com.google.protobuf.CodedInputStream input =
            (com.google.protobuf.CodedInputStream) arg0;
        com.google.protobuf.ExtensionRegistryLite extensionRegistry =
            (com.google.protobuf.ExtensionRegistryLite) arg1;
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              default: {
                if (!parseUnknownField(tag, input)) {
                  done = true;
                }
                break;
              }
              case 18: {
                String s = input.readString();
                bitField0_ |= 0x00000001;
                virtualUrl_ = s;
                break;
              }
              case 26: {
                String s = input.readString();
                bitField0_ |= 0x00000002;
                referrer_ = s;
                break;
              }
              case 34: {
                String s = input.readString();
                bitField0_ |= 0x00000004;
                title_ = s;
                break;
              }
              case 48: {
                int rawValue = input.readEnum();
                org.chromium.components.sync.protocol.SyncEnums.PageTransition value = org.chromium.components.sync.protocol.SyncEnums.PageTransition.forNumber(rawValue);
                if (value == null) {
                  super.mergeVarintField(6, rawValue);
                } else {
                  bitField0_ |= 0x00000008;
                  pageTransition_ = rawValue;
                }
                break;
              }
              case 56: {
                int rawValue = input.readEnum();
                org.chromium.components.sync.protocol.SyncEnums.PageTransitionRedirectType value = org.chromium.components.sync.protocol.SyncEnums.PageTransitionRedirectType.forNumber(rawValue);
                if (value == null) {
                  super.mergeVarintField(7, rawValue);
                } else {
                  bitField0_ |= 0x00000010;
                  redirectType_ = rawValue;
                }
                break;
              }
              case 64: {
                bitField0_ |= 0x00000020;
                uniqueId_ = input.readInt32();
                break;
              }
              case 72: {
                bitField0_ |= 0x00000040;
                timestampMsec_ = input.readInt64();
                break;
              }
              case 80: {
                bitField0_ |= 0x00000080;
                navigationForwardBack_ = input.readBool();
                break;
              }
              case 88: {
                bitField0_ |= 0x00000100;
                navigationFromAddressBar_ = input.readBool();
                break;
              }
              case 96: {
                bitField0_ |= 0x00000200;
                navigationHomePage_ = input.readBool();
                break;
              }
              case 104: {
                bitField0_ |= 0x00000400;
                navigationChainStart_ = input.readBool();
                break;
              }
              case 112: {
                bitField0_ |= 0x00000800;
                navigationChainEnd_ = input.readBool();
                break;
              }
              case 120: {
                bitField0_ |= 0x00001000;
                globalId_ = input.readInt64();
                break;
              }
              case 130: {
                String s = input.readString();
                bitField0_ |= 0x00002000;
                searchTerms_ = s;
                break;
              }
              case 138: {
                String s = input.readString();
                bitField0_ |= 0x00004000;
                faviconUrl_ = s;
                break;
              }
              case 144: {
                int rawValue = input.readEnum();
                org.chromium.components.sync.protocol.TabNavigation.BlockedState value = org.chromium.components.sync.protocol.TabNavigation.BlockedState.forNumber(rawValue);
                if (value == null) {
                  super.mergeVarintField(18, rawValue);
                } else {
                  bitField0_ |= 0x00008000;
                  blockedState_ = rawValue;
                }
                break;
              }
              case 154: {
                String s = input.readString();
                if (!contentPackCategories_.isModifiable()) {
                  contentPackCategories_ =
                      com.google.protobuf.GeneratedMessageLite.mutableCopy(contentPackCategories_);
                }
                contentPackCategories_.add(s);
                break;
              }
              case 160: {
                bitField0_ |= 0x00010000;
                httpStatusCode_ = input.readInt32();
                break;
              }
              case 168: {
                bitField0_ |= 0x00020000;
                obsoleteReferrerPolicy_ = input.readInt32();
                break;
              }
              case 176: {
                bitField0_ |= 0x00040000;
                isRestored_ = input.readBool();
                break;
              }
              case 186: {
                if (!navigationRedirect_.isModifiable()) {
                  navigationRedirect_ =
                      com.google.protobuf.GeneratedMessageLite.mutableCopy(navigationRedirect_);
                }
                navigationRedirect_.add(
                    input.readMessage(org.chromium.components.sync.protocol.NavigationRedirect.parser(), extensionRegistry));
                break;
              }
              case 194: {
                String s = input.readString();
                bitField0_ |= 0x00080000;
                lastNavigationRedirectUrl_ = s;
                break;
              }
              case 200: {
                bitField0_ |= 0x00100000;
                correctReferrerPolicy_ = input.readInt32();
                break;
              }
              case 208: {
                int rawValue = input.readEnum();
                org.chromium.components.sync.protocol.TabNavigation.PasswordState value = org.chromium.components.sync.protocol.TabNavigation.PasswordState.forNumber(rawValue);
                if (value == null) {
                  super.mergeVarintField(26, rawValue);
                } else {
                  bitField0_ |= 0x00200000;
                  passwordState_ = rawValue;
                }
                break;
              }
              case 216: {
                bitField0_ |= 0x00400000;
                taskId_ = input.readInt64();
                break;
              }
              case 224: {
                if (!ancestorTaskId_.isModifiable()) {
                  ancestorTaskId_ =
                      com.google.protobuf.GeneratedMessageLite.mutableCopy(ancestorTaskId_);
                }
                ancestorTaskId_.addLong(input.readInt64());
                break;
              }
              case 226: {
                int length = input.readRawVarint32();
                int limit = input.pushLimit(length);
                if (!ancestorTaskId_.isModifiable() && input.getBytesUntilLimit() > 0) {
                  ancestorTaskId_ =
                      com.google.protobuf.GeneratedMessageLite.mutableCopy(ancestorTaskId_);
                }
                while (input.getBytesUntilLimit() > 0) {
                  ancestorTaskId_.addLong(input.readInt64());
                }
                input.popLimit(limit);
                break;
              }
              case 234: {
                org.chromium.components.sync.protocol.ReplacedNavigation.Builder subBuilder = null;
                if (((bitField0_ & 0x00800000) == 0x00800000)) {
                  subBuilder = replacedNavigation_.toBuilder();
                }
                replacedNavigation_ = input.readMessage(org.chromium.components.sync.protocol.ReplacedNavigation.parser(), extensionRegistry);
                if (subBuilder != null) {
                  subBuilder.mergeFrom(replacedNavigation_);
                  replacedNavigation_ = subBuilder.buildPartial();
                }
                bitField0_ |= 0x00800000;
                break;
              }
              case 242: {
                String s = input.readString();
                bitField0_ |= 0x01000000;
                pageLanguage_ = s;
                break;
              }
            }
          }
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw new RuntimeException(e.setUnfinishedMessage(this));
        } catch (java.io.IOException e) {
          throw new RuntimeException(
              new com.google.protobuf.InvalidProtocolBufferException(
                  e.getMessage()).setUnfinishedMessage(this));
        } finally {
        }
      }
      case GET_DEFAULT_INSTANCE: {
        return DEFAULT_INSTANCE;
      }
      case GET_PARSER: {
        if (PARSER == null) {    synchronized (org.chromium.components.sync.protocol.TabNavigation.class) {
            if (PARSER == null) {
              PARSER = new DefaultInstanceBasedParser(DEFAULT_INSTANCE);
            }
          }
        }
        return PARSER;
      }
    }
    throw new UnsupportedOperationException();
  }


  // @@protoc_insertion_point(class_scope:sync_pb.TabNavigation)
  private static final org.chromium.components.sync.protocol.TabNavigation DEFAULT_INSTANCE;
  static {
    DEFAULT_INSTANCE = new TabNavigation();
    DEFAULT_INSTANCE.makeImmutable();
  }

  public static org.chromium.components.sync.protocol.TabNavigation getDefaultInstance() {
    return DEFAULT_INSTANCE;
  }

  private static volatile com.google.protobuf.Parser<TabNavigation> PARSER;

  public static com.google.protobuf.Parser<TabNavigation> parser() {
    return DEFAULT_INSTANCE.getParserForType();
  }
}

