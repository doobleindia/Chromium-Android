// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: sync.proto

package org.chromium.components.sync.protocol;

/**
 * Protobuf type {@code sync_pb.SyncEntity}
 */
public  final class SyncEntity extends
    com.google.protobuf.GeneratedMessageLite<
        SyncEntity, SyncEntity.Builder> implements
    // @@protoc_insertion_point(message_implements:sync_pb.SyncEntity)
    SyncEntityOrBuilder {
  private SyncEntity() {
    idString_ = "";
    parentIdString_ = "";
    oldParentId_ = "";
    name_ = "";
    nonUniqueName_ = "";
    serverDefinedUniqueTag_ = "";
    insertAfterItemId_ = "";
    originatorCacheGuid_ = "";
    originatorClientItemId_ = "";
    clientDefinedUniqueTag_ = "";
    ordinalInParent_ = com.google.protobuf.ByteString.EMPTY;
  }
  private int bitField0_;
  public static final int ID_STRING_FIELD_NUMBER = 1;
  private java.lang.String idString_;
  /**
   * <pre>
   * This item's identifier.  In a commit of a new item, this will be a
   * client-generated ID.  If the commit succeeds, the server will generate
   * a globally unique ID and return it to the committing client in the
   * CommitResponse.EntryResponse.  In the context of a GetUpdatesResponse,
   * |id_string| is always the server generated ID.  The original
   * client-generated ID is preserved in the |originator_client_id| field.
   * Present in both GetUpdatesResponse and CommitMessage.
   * </pre>
   *
   * <code>optional string id_string = 1;</code>
   */
  public boolean hasIdString() {
    return ((bitField0_ & 0x00000001) == 0x00000001);
  }
  /**
   * <pre>
   * This item's identifier.  In a commit of a new item, this will be a
   * client-generated ID.  If the commit succeeds, the server will generate
   * a globally unique ID and return it to the committing client in the
   * CommitResponse.EntryResponse.  In the context of a GetUpdatesResponse,
   * |id_string| is always the server generated ID.  The original
   * client-generated ID is preserved in the |originator_client_id| field.
   * Present in both GetUpdatesResponse and CommitMessage.
   * </pre>
   *
   * <code>optional string id_string = 1;</code>
   */
  public java.lang.String getIdString() {
    return idString_;
  }
  /**
   * <pre>
   * This item's identifier.  In a commit of a new item, this will be a
   * client-generated ID.  If the commit succeeds, the server will generate
   * a globally unique ID and return it to the committing client in the
   * CommitResponse.EntryResponse.  In the context of a GetUpdatesResponse,
   * |id_string| is always the server generated ID.  The original
   * client-generated ID is preserved in the |originator_client_id| field.
   * Present in both GetUpdatesResponse and CommitMessage.
   * </pre>
   *
   * <code>optional string id_string = 1;</code>
   */
  public com.google.protobuf.ByteString
      getIdStringBytes() {
    return com.google.protobuf.ByteString.copyFromUtf8(idString_);
  }
  /**
   * <pre>
   * This item's identifier.  In a commit of a new item, this will be a
   * client-generated ID.  If the commit succeeds, the server will generate
   * a globally unique ID and return it to the committing client in the
   * CommitResponse.EntryResponse.  In the context of a GetUpdatesResponse,
   * |id_string| is always the server generated ID.  The original
   * client-generated ID is preserved in the |originator_client_id| field.
   * Present in both GetUpdatesResponse and CommitMessage.
   * </pre>
   *
   * <code>optional string id_string = 1;</code>
   */
  private void setIdString(
      java.lang.String value) {
    if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000001;
    idString_ = value;
  }
  /**
   * <pre>
   * This item's identifier.  In a commit of a new item, this will be a
   * client-generated ID.  If the commit succeeds, the server will generate
   * a globally unique ID and return it to the committing client in the
   * CommitResponse.EntryResponse.  In the context of a GetUpdatesResponse,
   * |id_string| is always the server generated ID.  The original
   * client-generated ID is preserved in the |originator_client_id| field.
   * Present in both GetUpdatesResponse and CommitMessage.
   * </pre>
   *
   * <code>optional string id_string = 1;</code>
   */
  private void clearIdString() {
    bitField0_ = (bitField0_ & ~0x00000001);
    idString_ = getDefaultInstance().getIdString();
  }
  /**
   * <pre>
   * This item's identifier.  In a commit of a new item, this will be a
   * client-generated ID.  If the commit succeeds, the server will generate
   * a globally unique ID and return it to the committing client in the
   * CommitResponse.EntryResponse.  In the context of a GetUpdatesResponse,
   * |id_string| is always the server generated ID.  The original
   * client-generated ID is preserved in the |originator_client_id| field.
   * Present in both GetUpdatesResponse and CommitMessage.
   * </pre>
   *
   * <code>optional string id_string = 1;</code>
   */
  private void setIdStringBytes(
      com.google.protobuf.ByteString value) {
    if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000001;
    idString_ = value.toStringUtf8();
  }

  public static final int PARENT_ID_STRING_FIELD_NUMBER = 2;
  private java.lang.String parentIdString_;
  /**
   * <pre>
   * An id referencing this item's parent in the hierarchy.  In a
   * CommitMessage, it is accepted for this to be a client-generated temporary
   * ID if there was a new created item with that ID appearing earlier
   * in the message.  In all other situations, it is a server ID.
   * Present in both GetUpdatesResponse and CommitMessage.
   * </pre>
   *
   * <code>optional string parent_id_string = 2;</code>
   */
  public boolean hasParentIdString() {
    return ((bitField0_ & 0x00000002) == 0x00000002);
  }
  /**
   * <pre>
   * An id referencing this item's parent in the hierarchy.  In a
   * CommitMessage, it is accepted for this to be a client-generated temporary
   * ID if there was a new created item with that ID appearing earlier
   * in the message.  In all other situations, it is a server ID.
   * Present in both GetUpdatesResponse and CommitMessage.
   * </pre>
   *
   * <code>optional string parent_id_string = 2;</code>
   */
  public java.lang.String getParentIdString() {
    return parentIdString_;
  }
  /**
   * <pre>
   * An id referencing this item's parent in the hierarchy.  In a
   * CommitMessage, it is accepted for this to be a client-generated temporary
   * ID if there was a new created item with that ID appearing earlier
   * in the message.  In all other situations, it is a server ID.
   * Present in both GetUpdatesResponse and CommitMessage.
   * </pre>
   *
   * <code>optional string parent_id_string = 2;</code>
   */
  public com.google.protobuf.ByteString
      getParentIdStringBytes() {
    return com.google.protobuf.ByteString.copyFromUtf8(parentIdString_);
  }
  /**
   * <pre>
   * An id referencing this item's parent in the hierarchy.  In a
   * CommitMessage, it is accepted for this to be a client-generated temporary
   * ID if there was a new created item with that ID appearing earlier
   * in the message.  In all other situations, it is a server ID.
   * Present in both GetUpdatesResponse and CommitMessage.
   * </pre>
   *
   * <code>optional string parent_id_string = 2;</code>
   */
  private void setParentIdString(
      java.lang.String value) {
    if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000002;
    parentIdString_ = value;
  }
  /**
   * <pre>
   * An id referencing this item's parent in the hierarchy.  In a
   * CommitMessage, it is accepted for this to be a client-generated temporary
   * ID if there was a new created item with that ID appearing earlier
   * in the message.  In all other situations, it is a server ID.
   * Present in both GetUpdatesResponse and CommitMessage.
   * </pre>
   *
   * <code>optional string parent_id_string = 2;</code>
   */
  private void clearParentIdString() {
    bitField0_ = (bitField0_ & ~0x00000002);
    parentIdString_ = getDefaultInstance().getParentIdString();
  }
  /**
   * <pre>
   * An id referencing this item's parent in the hierarchy.  In a
   * CommitMessage, it is accepted for this to be a client-generated temporary
   * ID if there was a new created item with that ID appearing earlier
   * in the message.  In all other situations, it is a server ID.
   * Present in both GetUpdatesResponse and CommitMessage.
   * </pre>
   *
   * <code>optional string parent_id_string = 2;</code>
   */
  private void setParentIdStringBytes(
      com.google.protobuf.ByteString value) {
    if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000002;
    parentIdString_ = value.toStringUtf8();
  }

  public static final int OLD_PARENT_ID_FIELD_NUMBER = 3;
  private java.lang.String oldParentId_;
  /**
   * <pre>
   * old_parent_id is only set in commits and indicates the old server
   * parent(s) to remove. When omitted, the old parent is the same as
   * the new.
   * Present only in CommitMessage.
   * </pre>
   *
   * <code>optional string old_parent_id = 3;</code>
   */
  public boolean hasOldParentId() {
    return ((bitField0_ & 0x00000004) == 0x00000004);
  }
  /**
   * <pre>
   * old_parent_id is only set in commits and indicates the old server
   * parent(s) to remove. When omitted, the old parent is the same as
   * the new.
   * Present only in CommitMessage.
   * </pre>
   *
   * <code>optional string old_parent_id = 3;</code>
   */
  public java.lang.String getOldParentId() {
    return oldParentId_;
  }
  /**
   * <pre>
   * old_parent_id is only set in commits and indicates the old server
   * parent(s) to remove. When omitted, the old parent is the same as
   * the new.
   * Present only in CommitMessage.
   * </pre>
   *
   * <code>optional string old_parent_id = 3;</code>
   */
  public com.google.protobuf.ByteString
      getOldParentIdBytes() {
    return com.google.protobuf.ByteString.copyFromUtf8(oldParentId_);
  }
  /**
   * <pre>
   * old_parent_id is only set in commits and indicates the old server
   * parent(s) to remove. When omitted, the old parent is the same as
   * the new.
   * Present only in CommitMessage.
   * </pre>
   *
   * <code>optional string old_parent_id = 3;</code>
   */
  private void setOldParentId(
      java.lang.String value) {
    if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000004;
    oldParentId_ = value;
  }
  /**
   * <pre>
   * old_parent_id is only set in commits and indicates the old server
   * parent(s) to remove. When omitted, the old parent is the same as
   * the new.
   * Present only in CommitMessage.
   * </pre>
   *
   * <code>optional string old_parent_id = 3;</code>
   */
  private void clearOldParentId() {
    bitField0_ = (bitField0_ & ~0x00000004);
    oldParentId_ = getDefaultInstance().getOldParentId();
  }
  /**
   * <pre>
   * old_parent_id is only set in commits and indicates the old server
   * parent(s) to remove. When omitted, the old parent is the same as
   * the new.
   * Present only in CommitMessage.
   * </pre>
   *
   * <code>optional string old_parent_id = 3;</code>
   */
  private void setOldParentIdBytes(
      com.google.protobuf.ByteString value) {
    if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000004;
    oldParentId_ = value.toStringUtf8();
  }

  public static final int VERSION_FIELD_NUMBER = 4;
  private long version_;
  /**
   * <pre>
   * The version of this item -- a monotonically increasing value that is
   * maintained by for each item.  If zero in a CommitMessage, the server
   * will interpret this entity as a newly-created item and generate a
   * new server ID and an initial version number.  If nonzero in a
   * CommitMessage, this item is treated as an update to an existing item, and
   * the server will use |id_string| to locate the item.  Then, if the item's
   * current version on the server does not match |version|, the commit will
   * fail for that item.  The server will not update it, and will return
   * a result code of CONFLICT.  In a GetUpdatesResponse, |version| is
   * always positive and indentifies the revision of the item data being sent
   * to the client.
   * Present in both GetUpdatesResponse and CommitMessage.
   * WARNING: This field used to be required before M60. Any client before this
   * will fail to deserialize if this field is missing.
   * </pre>
   *
   * <code>optional int64 version = 4;</code>
   */
  public boolean hasVersion() {
    return ((bitField0_ & 0x00000008) == 0x00000008);
  }
  /**
   * <pre>
   * The version of this item -- a monotonically increasing value that is
   * maintained by for each item.  If zero in a CommitMessage, the server
   * will interpret this entity as a newly-created item and generate a
   * new server ID and an initial version number.  If nonzero in a
   * CommitMessage, this item is treated as an update to an existing item, and
   * the server will use |id_string| to locate the item.  Then, if the item's
   * current version on the server does not match |version|, the commit will
   * fail for that item.  The server will not update it, and will return
   * a result code of CONFLICT.  In a GetUpdatesResponse, |version| is
   * always positive and indentifies the revision of the item data being sent
   * to the client.
   * Present in both GetUpdatesResponse and CommitMessage.
   * WARNING: This field used to be required before M60. Any client before this
   * will fail to deserialize if this field is missing.
   * </pre>
   *
   * <code>optional int64 version = 4;</code>
   */
  public long getVersion() {
    return version_;
  }
  /**
   * <pre>
   * The version of this item -- a monotonically increasing value that is
   * maintained by for each item.  If zero in a CommitMessage, the server
   * will interpret this entity as a newly-created item and generate a
   * new server ID and an initial version number.  If nonzero in a
   * CommitMessage, this item is treated as an update to an existing item, and
   * the server will use |id_string| to locate the item.  Then, if the item's
   * current version on the server does not match |version|, the commit will
   * fail for that item.  The server will not update it, and will return
   * a result code of CONFLICT.  In a GetUpdatesResponse, |version| is
   * always positive and indentifies the revision of the item data being sent
   * to the client.
   * Present in both GetUpdatesResponse and CommitMessage.
   * WARNING: This field used to be required before M60. Any client before this
   * will fail to deserialize if this field is missing.
   * </pre>
   *
   * <code>optional int64 version = 4;</code>
   */
  private void setVersion(long value) {
    bitField0_ |= 0x00000008;
    version_ = value;
  }
  /**
   * <pre>
   * The version of this item -- a monotonically increasing value that is
   * maintained by for each item.  If zero in a CommitMessage, the server
   * will interpret this entity as a newly-created item and generate a
   * new server ID and an initial version number.  If nonzero in a
   * CommitMessage, this item is treated as an update to an existing item, and
   * the server will use |id_string| to locate the item.  Then, if the item's
   * current version on the server does not match |version|, the commit will
   * fail for that item.  The server will not update it, and will return
   * a result code of CONFLICT.  In a GetUpdatesResponse, |version| is
   * always positive and indentifies the revision of the item data being sent
   * to the client.
   * Present in both GetUpdatesResponse and CommitMessage.
   * WARNING: This field used to be required before M60. Any client before this
   * will fail to deserialize if this field is missing.
   * </pre>
   *
   * <code>optional int64 version = 4;</code>
   */
  private void clearVersion() {
    bitField0_ = (bitField0_ & ~0x00000008);
    version_ = 0L;
  }

  public static final int MTIME_FIELD_NUMBER = 5;
  private long mtime_;
  /**
   * <pre>
   * Last modification time (in java time milliseconds)
   * Present in both GetUpdatesResponse and CommitMessage.
   * </pre>
   *
   * <code>optional int64 mtime = 5;</code>
   */
  public boolean hasMtime() {
    return ((bitField0_ & 0x00000010) == 0x00000010);
  }
  /**
   * <pre>
   * Last modification time (in java time milliseconds)
   * Present in both GetUpdatesResponse and CommitMessage.
   * </pre>
   *
   * <code>optional int64 mtime = 5;</code>
   */
  public long getMtime() {
    return mtime_;
  }
  /**
   * <pre>
   * Last modification time (in java time milliseconds)
   * Present in both GetUpdatesResponse and CommitMessage.
   * </pre>
   *
   * <code>optional int64 mtime = 5;</code>
   */
  private void setMtime(long value) {
    bitField0_ |= 0x00000010;
    mtime_ = value;
  }
  /**
   * <pre>
   * Last modification time (in java time milliseconds)
   * Present in both GetUpdatesResponse and CommitMessage.
   * </pre>
   *
   * <code>optional int64 mtime = 5;</code>
   */
  private void clearMtime() {
    bitField0_ = (bitField0_ & ~0x00000010);
    mtime_ = 0L;
  }

  public static final int CTIME_FIELD_NUMBER = 6;
  private long ctime_;
  /**
   * <pre>
   * Creation time.
   * Present in both GetUpdatesResponse and CommitMessage.
   * </pre>
   *
   * <code>optional int64 ctime = 6;</code>
   */
  public boolean hasCtime() {
    return ((bitField0_ & 0x00000020) == 0x00000020);
  }
  /**
   * <pre>
   * Creation time.
   * Present in both GetUpdatesResponse and CommitMessage.
   * </pre>
   *
   * <code>optional int64 ctime = 6;</code>
   */
  public long getCtime() {
    return ctime_;
  }
  /**
   * <pre>
   * Creation time.
   * Present in both GetUpdatesResponse and CommitMessage.
   * </pre>
   *
   * <code>optional int64 ctime = 6;</code>
   */
  private void setCtime(long value) {
    bitField0_ |= 0x00000020;
    ctime_ = value;
  }
  /**
   * <pre>
   * Creation time.
   * Present in both GetUpdatesResponse and CommitMessage.
   * </pre>
   *
   * <code>optional int64 ctime = 6;</code>
   */
  private void clearCtime() {
    bitField0_ = (bitField0_ & ~0x00000020);
    ctime_ = 0L;
  }

  public static final int NAME_FIELD_NUMBER = 7;
  private java.lang.String name_;
  /**
   * <pre>
   * The name of this item.
   * Historical note:
   *   Since November 2010, this value is no different from non_unique_name.
   *   Before then, server implementations would maintain a unique-within-parent
   *   value separate from its base, "non-unique" value.  Clients had not
   *   depended on the uniqueness of the property since November 2009; it was
   *   removed from Chromium by http://codereview.chromium.org/371029 .
   * Present in both GetUpdatesResponse and CommitMessage.
   * WARNING: This field used to be required before M60. Any client before this
   * will fail to deserialize if this field is missing.
   * </pre>
   *
   * <code>optional string name = 7;</code>
   */
  public boolean hasName() {
    return ((bitField0_ & 0x00000040) == 0x00000040);
  }
  /**
   * <pre>
   * The name of this item.
   * Historical note:
   *   Since November 2010, this value is no different from non_unique_name.
   *   Before then, server implementations would maintain a unique-within-parent
   *   value separate from its base, "non-unique" value.  Clients had not
   *   depended on the uniqueness of the property since November 2009; it was
   *   removed from Chromium by http://codereview.chromium.org/371029 .
   * Present in both GetUpdatesResponse and CommitMessage.
   * WARNING: This field used to be required before M60. Any client before this
   * will fail to deserialize if this field is missing.
   * </pre>
   *
   * <code>optional string name = 7;</code>
   */
  public java.lang.String getName() {
    return name_;
  }
  /**
   * <pre>
   * The name of this item.
   * Historical note:
   *   Since November 2010, this value is no different from non_unique_name.
   *   Before then, server implementations would maintain a unique-within-parent
   *   value separate from its base, "non-unique" value.  Clients had not
   *   depended on the uniqueness of the property since November 2009; it was
   *   removed from Chromium by http://codereview.chromium.org/371029 .
   * Present in both GetUpdatesResponse and CommitMessage.
   * WARNING: This field used to be required before M60. Any client before this
   * will fail to deserialize if this field is missing.
   * </pre>
   *
   * <code>optional string name = 7;</code>
   */
  public com.google.protobuf.ByteString
      getNameBytes() {
    return com.google.protobuf.ByteString.copyFromUtf8(name_);
  }
  /**
   * <pre>
   * The name of this item.
   * Historical note:
   *   Since November 2010, this value is no different from non_unique_name.
   *   Before then, server implementations would maintain a unique-within-parent
   *   value separate from its base, "non-unique" value.  Clients had not
   *   depended on the uniqueness of the property since November 2009; it was
   *   removed from Chromium by http://codereview.chromium.org/371029 .
   * Present in both GetUpdatesResponse and CommitMessage.
   * WARNING: This field used to be required before M60. Any client before this
   * will fail to deserialize if this field is missing.
   * </pre>
   *
   * <code>optional string name = 7;</code>
   */
  private void setName(
      java.lang.String value) {
    if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000040;
    name_ = value;
  }
  /**
   * <pre>
   * The name of this item.
   * Historical note:
   *   Since November 2010, this value is no different from non_unique_name.
   *   Before then, server implementations would maintain a unique-within-parent
   *   value separate from its base, "non-unique" value.  Clients had not
   *   depended on the uniqueness of the property since November 2009; it was
   *   removed from Chromium by http://codereview.chromium.org/371029 .
   * Present in both GetUpdatesResponse and CommitMessage.
   * WARNING: This field used to be required before M60. Any client before this
   * will fail to deserialize if this field is missing.
   * </pre>
   *
   * <code>optional string name = 7;</code>
   */
  private void clearName() {
    bitField0_ = (bitField0_ & ~0x00000040);
    name_ = getDefaultInstance().getName();
  }
  /**
   * <pre>
   * The name of this item.
   * Historical note:
   *   Since November 2010, this value is no different from non_unique_name.
   *   Before then, server implementations would maintain a unique-within-parent
   *   value separate from its base, "non-unique" value.  Clients had not
   *   depended on the uniqueness of the property since November 2009; it was
   *   removed from Chromium by http://codereview.chromium.org/371029 .
   * Present in both GetUpdatesResponse and CommitMessage.
   * WARNING: This field used to be required before M60. Any client before this
   * will fail to deserialize if this field is missing.
   * </pre>
   *
   * <code>optional string name = 7;</code>
   */
  private void setNameBytes(
      com.google.protobuf.ByteString value) {
    if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000040;
    name_ = value.toStringUtf8();
  }

  public static final int NON_UNIQUE_NAME_FIELD_NUMBER = 8;
  private java.lang.String nonUniqueName_;
  /**
   * <pre>
   * The name of this item.  Same as |name|.
   * |non_unique_name| should take precedence over the |name| value if both
   * are supplied.  For efficiency, clients and servers should avoid setting
   * this redundant value.
   * Present in both GetUpdatesResponse and CommitMessage.
   * </pre>
   *
   * <code>optional string non_unique_name = 8;</code>
   */
  public boolean hasNonUniqueName() {
    return ((bitField0_ & 0x00000080) == 0x00000080);
  }
  /**
   * <pre>
   * The name of this item.  Same as |name|.
   * |non_unique_name| should take precedence over the |name| value if both
   * are supplied.  For efficiency, clients and servers should avoid setting
   * this redundant value.
   * Present in both GetUpdatesResponse and CommitMessage.
   * </pre>
   *
   * <code>optional string non_unique_name = 8;</code>
   */
  public java.lang.String getNonUniqueName() {
    return nonUniqueName_;
  }
  /**
   * <pre>
   * The name of this item.  Same as |name|.
   * |non_unique_name| should take precedence over the |name| value if both
   * are supplied.  For efficiency, clients and servers should avoid setting
   * this redundant value.
   * Present in both GetUpdatesResponse and CommitMessage.
   * </pre>
   *
   * <code>optional string non_unique_name = 8;</code>
   */
  public com.google.protobuf.ByteString
      getNonUniqueNameBytes() {
    return com.google.protobuf.ByteString.copyFromUtf8(nonUniqueName_);
  }
  /**
   * <pre>
   * The name of this item.  Same as |name|.
   * |non_unique_name| should take precedence over the |name| value if both
   * are supplied.  For efficiency, clients and servers should avoid setting
   * this redundant value.
   * Present in both GetUpdatesResponse and CommitMessage.
   * </pre>
   *
   * <code>optional string non_unique_name = 8;</code>
   */
  private void setNonUniqueName(
      java.lang.String value) {
    if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000080;
    nonUniqueName_ = value;
  }
  /**
   * <pre>
   * The name of this item.  Same as |name|.
   * |non_unique_name| should take precedence over the |name| value if both
   * are supplied.  For efficiency, clients and servers should avoid setting
   * this redundant value.
   * Present in both GetUpdatesResponse and CommitMessage.
   * </pre>
   *
   * <code>optional string non_unique_name = 8;</code>
   */
  private void clearNonUniqueName() {
    bitField0_ = (bitField0_ & ~0x00000080);
    nonUniqueName_ = getDefaultInstance().getNonUniqueName();
  }
  /**
   * <pre>
   * The name of this item.  Same as |name|.
   * |non_unique_name| should take precedence over the |name| value if both
   * are supplied.  For efficiency, clients and servers should avoid setting
   * this redundant value.
   * Present in both GetUpdatesResponse and CommitMessage.
   * </pre>
   *
   * <code>optional string non_unique_name = 8;</code>
   */
  private void setNonUniqueNameBytes(
      com.google.protobuf.ByteString value) {
    if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000080;
    nonUniqueName_ = value.toStringUtf8();
  }

  public static final int SERVER_DEFINED_UNIQUE_TAG_FIELD_NUMBER = 10;
  private java.lang.String serverDefinedUniqueTag_;
  /**
   * <pre>
   * If present, this tag identifies this item as being a uniquely
   * instanced item.  The server ensures that there is never more
   * than one entity in a user's store with the same tag value.
   * This value is used to identify and find e.g. the "Google Chrome" settings
   * folder without relying on it existing at a particular path, or having
   * a particular name, in the data store.
   * This variant of the tag is created by the server, so clients can't create
   * an item with a tag using this field.
   * Use client_defined_unique_tag if you want to create one from the client.
   * An item can't have both a client_defined_unique_tag and
   * a server_defined_unique_tag.
   * Present only in GetUpdatesResponse.
   * </pre>
   *
   * <code>optional string server_defined_unique_tag = 10;</code>
   */
  public boolean hasServerDefinedUniqueTag() {
    return ((bitField0_ & 0x00000100) == 0x00000100);
  }
  /**
   * <pre>
   * If present, this tag identifies this item as being a uniquely
   * instanced item.  The server ensures that there is never more
   * than one entity in a user's store with the same tag value.
   * This value is used to identify and find e.g. the "Google Chrome" settings
   * folder without relying on it existing at a particular path, or having
   * a particular name, in the data store.
   * This variant of the tag is created by the server, so clients can't create
   * an item with a tag using this field.
   * Use client_defined_unique_tag if you want to create one from the client.
   * An item can't have both a client_defined_unique_tag and
   * a server_defined_unique_tag.
   * Present only in GetUpdatesResponse.
   * </pre>
   *
   * <code>optional string server_defined_unique_tag = 10;</code>
   */
  public java.lang.String getServerDefinedUniqueTag() {
    return serverDefinedUniqueTag_;
  }
  /**
   * <pre>
   * If present, this tag identifies this item as being a uniquely
   * instanced item.  The server ensures that there is never more
   * than one entity in a user's store with the same tag value.
   * This value is used to identify and find e.g. the "Google Chrome" settings
   * folder without relying on it existing at a particular path, or having
   * a particular name, in the data store.
   * This variant of the tag is created by the server, so clients can't create
   * an item with a tag using this field.
   * Use client_defined_unique_tag if you want to create one from the client.
   * An item can't have both a client_defined_unique_tag and
   * a server_defined_unique_tag.
   * Present only in GetUpdatesResponse.
   * </pre>
   *
   * <code>optional string server_defined_unique_tag = 10;</code>
   */
  public com.google.protobuf.ByteString
      getServerDefinedUniqueTagBytes() {
    return com.google.protobuf.ByteString.copyFromUtf8(serverDefinedUniqueTag_);
  }
  /**
   * <pre>
   * If present, this tag identifies this item as being a uniquely
   * instanced item.  The server ensures that there is never more
   * than one entity in a user's store with the same tag value.
   * This value is used to identify and find e.g. the "Google Chrome" settings
   * folder without relying on it existing at a particular path, or having
   * a particular name, in the data store.
   * This variant of the tag is created by the server, so clients can't create
   * an item with a tag using this field.
   * Use client_defined_unique_tag if you want to create one from the client.
   * An item can't have both a client_defined_unique_tag and
   * a server_defined_unique_tag.
   * Present only in GetUpdatesResponse.
   * </pre>
   *
   * <code>optional string server_defined_unique_tag = 10;</code>
   */
  private void setServerDefinedUniqueTag(
      java.lang.String value) {
    if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000100;
    serverDefinedUniqueTag_ = value;
  }
  /**
   * <pre>
   * If present, this tag identifies this item as being a uniquely
   * instanced item.  The server ensures that there is never more
   * than one entity in a user's store with the same tag value.
   * This value is used to identify and find e.g. the "Google Chrome" settings
   * folder without relying on it existing at a particular path, or having
   * a particular name, in the data store.
   * This variant of the tag is created by the server, so clients can't create
   * an item with a tag using this field.
   * Use client_defined_unique_tag if you want to create one from the client.
   * An item can't have both a client_defined_unique_tag and
   * a server_defined_unique_tag.
   * Present only in GetUpdatesResponse.
   * </pre>
   *
   * <code>optional string server_defined_unique_tag = 10;</code>
   */
  private void clearServerDefinedUniqueTag() {
    bitField0_ = (bitField0_ & ~0x00000100);
    serverDefinedUniqueTag_ = getDefaultInstance().getServerDefinedUniqueTag();
  }
  /**
   * <pre>
   * If present, this tag identifies this item as being a uniquely
   * instanced item.  The server ensures that there is never more
   * than one entity in a user's store with the same tag value.
   * This value is used to identify and find e.g. the "Google Chrome" settings
   * folder without relying on it existing at a particular path, or having
   * a particular name, in the data store.
   * This variant of the tag is created by the server, so clients can't create
   * an item with a tag using this field.
   * Use client_defined_unique_tag if you want to create one from the client.
   * An item can't have both a client_defined_unique_tag and
   * a server_defined_unique_tag.
   * Present only in GetUpdatesResponse.
   * </pre>
   *
   * <code>optional string server_defined_unique_tag = 10;</code>
   */
  private void setServerDefinedUniqueTagBytes(
      com.google.protobuf.ByteString value) {
    if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000100;
    serverDefinedUniqueTag_ = value.toStringUtf8();
  }

  public static final int POSITION_IN_PARENT_FIELD_NUMBER = 15;
  private long positionInParent_;
  /**
   * <pre>
   * Supplies a numeric position for this item, relative to other items with the
   * same parent.  Deprecated in M26, though clients are still required to set
   * it.
   * Present in both GetUpdatesResponse and CommitMessage.
   * At one point this was used as an alternative / supplement to
   * the deprecated |insert_after_item_id|, but now it, too, has been
   * deprecated.
   * In order to maintain compatibility with older clients, newer clients should
   * still set this field.  Its value should be based on the first 8 bytes of
   * this item's |unique_position|.
   * Nerwer clients must also support the receipt of items that contain
   * |position_in_parent| but no |unique_position|.  They should locally convert
   * the given int64 position to a UniquePosition.
   * The conversion from int64 to UniquePosition is as follows:
   * The int64 value will have its sign bit flipped then placed in big endian
   * order as the first 8 bytes of the UniquePosition.  The subsequent bytes of
   * the UniquePosition will consist of the item's unique suffix.
   * Conversion from UniquePosition to int64 reverses this process: the first 8
   * bytes of the position are to be interpreted as a big endian int64 value
   * with its sign bit flipped.
   * </pre>
   *
   * <code>optional int64 position_in_parent = 15 [deprecated = true];</code>
   */
  @java.lang.Deprecated public boolean hasPositionInParent() {
    return ((bitField0_ & 0x00000200) == 0x00000200);
  }
  /**
   * <pre>
   * Supplies a numeric position for this item, relative to other items with the
   * same parent.  Deprecated in M26, though clients are still required to set
   * it.
   * Present in both GetUpdatesResponse and CommitMessage.
   * At one point this was used as an alternative / supplement to
   * the deprecated |insert_after_item_id|, but now it, too, has been
   * deprecated.
   * In order to maintain compatibility with older clients, newer clients should
   * still set this field.  Its value should be based on the first 8 bytes of
   * this item's |unique_position|.
   * Nerwer clients must also support the receipt of items that contain
   * |position_in_parent| but no |unique_position|.  They should locally convert
   * the given int64 position to a UniquePosition.
   * The conversion from int64 to UniquePosition is as follows:
   * The int64 value will have its sign bit flipped then placed in big endian
   * order as the first 8 bytes of the UniquePosition.  The subsequent bytes of
   * the UniquePosition will consist of the item's unique suffix.
   * Conversion from UniquePosition to int64 reverses this process: the first 8
   * bytes of the position are to be interpreted as a big endian int64 value
   * with its sign bit flipped.
   * </pre>
   *
   * <code>optional int64 position_in_parent = 15 [deprecated = true];</code>
   */
  @java.lang.Deprecated public long getPositionInParent() {
    return positionInParent_;
  }
  /**
   * <pre>
   * Supplies a numeric position for this item, relative to other items with the
   * same parent.  Deprecated in M26, though clients are still required to set
   * it.
   * Present in both GetUpdatesResponse and CommitMessage.
   * At one point this was used as an alternative / supplement to
   * the deprecated |insert_after_item_id|, but now it, too, has been
   * deprecated.
   * In order to maintain compatibility with older clients, newer clients should
   * still set this field.  Its value should be based on the first 8 bytes of
   * this item's |unique_position|.
   * Nerwer clients must also support the receipt of items that contain
   * |position_in_parent| but no |unique_position|.  They should locally convert
   * the given int64 position to a UniquePosition.
   * The conversion from int64 to UniquePosition is as follows:
   * The int64 value will have its sign bit flipped then placed in big endian
   * order as the first 8 bytes of the UniquePosition.  The subsequent bytes of
   * the UniquePosition will consist of the item's unique suffix.
   * Conversion from UniquePosition to int64 reverses this process: the first 8
   * bytes of the position are to be interpreted as a big endian int64 value
   * with its sign bit flipped.
   * </pre>
   *
   * <code>optional int64 position_in_parent = 15 [deprecated = true];</code>
   */
  private void setPositionInParent(long value) {
    bitField0_ |= 0x00000200;
    positionInParent_ = value;
  }
  /**
   * <pre>
   * Supplies a numeric position for this item, relative to other items with the
   * same parent.  Deprecated in M26, though clients are still required to set
   * it.
   * Present in both GetUpdatesResponse and CommitMessage.
   * At one point this was used as an alternative / supplement to
   * the deprecated |insert_after_item_id|, but now it, too, has been
   * deprecated.
   * In order to maintain compatibility with older clients, newer clients should
   * still set this field.  Its value should be based on the first 8 bytes of
   * this item's |unique_position|.
   * Nerwer clients must also support the receipt of items that contain
   * |position_in_parent| but no |unique_position|.  They should locally convert
   * the given int64 position to a UniquePosition.
   * The conversion from int64 to UniquePosition is as follows:
   * The int64 value will have its sign bit flipped then placed in big endian
   * order as the first 8 bytes of the UniquePosition.  The subsequent bytes of
   * the UniquePosition will consist of the item's unique suffix.
   * Conversion from UniquePosition to int64 reverses this process: the first 8
   * bytes of the position are to be interpreted as a big endian int64 value
   * with its sign bit flipped.
   * </pre>
   *
   * <code>optional int64 position_in_parent = 15 [deprecated = true];</code>
   */
  private void clearPositionInParent() {
    bitField0_ = (bitField0_ & ~0x00000200);
    positionInParent_ = 0L;
  }

  public static final int INSERT_AFTER_ITEM_ID_FIELD_NUMBER = 16;
  private java.lang.String insertAfterItemId_;
  /**
   * <pre>
   * Contains the ID of the element (under the same parent) after which this
   * element resides. An empty string indicates that the element is the first
   * element in the parent.  This value is used during commits to specify
   * a relative position for a position change.  In the context of
   * a GetUpdatesMessage, |position_in_parent| is used instead to
   * communicate position.
   * Present only in CommitMessage.
   * This is deprecated.  Clients are allowed to omit this as long as they
   * include |position_in_parent| instead.
   * </pre>
   *
   * <code>optional string insert_after_item_id = 16 [deprecated = true];</code>
   */
  @java.lang.Deprecated public boolean hasInsertAfterItemId() {
    return ((bitField0_ & 0x00000400) == 0x00000400);
  }
  /**
   * <pre>
   * Contains the ID of the element (under the same parent) after which this
   * element resides. An empty string indicates that the element is the first
   * element in the parent.  This value is used during commits to specify
   * a relative position for a position change.  In the context of
   * a GetUpdatesMessage, |position_in_parent| is used instead to
   * communicate position.
   * Present only in CommitMessage.
   * This is deprecated.  Clients are allowed to omit this as long as they
   * include |position_in_parent| instead.
   * </pre>
   *
   * <code>optional string insert_after_item_id = 16 [deprecated = true];</code>
   */
  @java.lang.Deprecated public java.lang.String getInsertAfterItemId() {
    return insertAfterItemId_;
  }
  /**
   * <pre>
   * Contains the ID of the element (under the same parent) after which this
   * element resides. An empty string indicates that the element is the first
   * element in the parent.  This value is used during commits to specify
   * a relative position for a position change.  In the context of
   * a GetUpdatesMessage, |position_in_parent| is used instead to
   * communicate position.
   * Present only in CommitMessage.
   * This is deprecated.  Clients are allowed to omit this as long as they
   * include |position_in_parent| instead.
   * </pre>
   *
   * <code>optional string insert_after_item_id = 16 [deprecated = true];</code>
   */
  @java.lang.Deprecated public com.google.protobuf.ByteString
      getInsertAfterItemIdBytes() {
    return com.google.protobuf.ByteString.copyFromUtf8(insertAfterItemId_);
  }
  /**
   * <pre>
   * Contains the ID of the element (under the same parent) after which this
   * element resides. An empty string indicates that the element is the first
   * element in the parent.  This value is used during commits to specify
   * a relative position for a position change.  In the context of
   * a GetUpdatesMessage, |position_in_parent| is used instead to
   * communicate position.
   * Present only in CommitMessage.
   * This is deprecated.  Clients are allowed to omit this as long as they
   * include |position_in_parent| instead.
   * </pre>
   *
   * <code>optional string insert_after_item_id = 16 [deprecated = true];</code>
   */
  private void setInsertAfterItemId(
      java.lang.String value) {
    if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000400;
    insertAfterItemId_ = value;
  }
  /**
   * <pre>
   * Contains the ID of the element (under the same parent) after which this
   * element resides. An empty string indicates that the element is the first
   * element in the parent.  This value is used during commits to specify
   * a relative position for a position change.  In the context of
   * a GetUpdatesMessage, |position_in_parent| is used instead to
   * communicate position.
   * Present only in CommitMessage.
   * This is deprecated.  Clients are allowed to omit this as long as they
   * include |position_in_parent| instead.
   * </pre>
   *
   * <code>optional string insert_after_item_id = 16 [deprecated = true];</code>
   */
  private void clearInsertAfterItemId() {
    bitField0_ = (bitField0_ & ~0x00000400);
    insertAfterItemId_ = getDefaultInstance().getInsertAfterItemId();
  }
  /**
   * <pre>
   * Contains the ID of the element (under the same parent) after which this
   * element resides. An empty string indicates that the element is the first
   * element in the parent.  This value is used during commits to specify
   * a relative position for a position change.  In the context of
   * a GetUpdatesMessage, |position_in_parent| is used instead to
   * communicate position.
   * Present only in CommitMessage.
   * This is deprecated.  Clients are allowed to omit this as long as they
   * include |position_in_parent| instead.
   * </pre>
   *
   * <code>optional string insert_after_item_id = 16 [deprecated = true];</code>
   */
  private void setInsertAfterItemIdBytes(
      com.google.protobuf.ByteString value) {
    if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000400;
    insertAfterItemId_ = value.toStringUtf8();
  }

  public static final int DELETED_FIELD_NUMBER = 18;
  private boolean deleted_;
  /**
   * <pre>
   * If true, indicates that this item has been (or should be) deleted.
   * Present in both GetUpdatesResponse and CommitMessage.
   * </pre>
   *
   * <code>optional bool deleted = 18 [default = false];</code>
   */
  public boolean hasDeleted() {
    return ((bitField0_ & 0x00000800) == 0x00000800);
  }
  /**
   * <pre>
   * If true, indicates that this item has been (or should be) deleted.
   * Present in both GetUpdatesResponse and CommitMessage.
   * </pre>
   *
   * <code>optional bool deleted = 18 [default = false];</code>
   */
  public boolean getDeleted() {
    return deleted_;
  }
  /**
   * <pre>
   * If true, indicates that this item has been (or should be) deleted.
   * Present in both GetUpdatesResponse and CommitMessage.
   * </pre>
   *
   * <code>optional bool deleted = 18 [default = false];</code>
   */
  private void setDeleted(boolean value) {
    bitField0_ |= 0x00000800;
    deleted_ = value;
  }
  /**
   * <pre>
   * If true, indicates that this item has been (or should be) deleted.
   * Present in both GetUpdatesResponse and CommitMessage.
   * </pre>
   *
   * <code>optional bool deleted = 18 [default = false];</code>
   */
  private void clearDeleted() {
    bitField0_ = (bitField0_ & ~0x00000800);
    deleted_ = false;
  }

  public static final int ORIGINATOR_CACHE_GUID_FIELD_NUMBER = 19;
  private java.lang.String originatorCacheGuid_;
  /**
   * <pre>
   * A GUID that identifies the the sync client who initially committed
   * this entity.  This value corresponds to |cache_guid| in CommitMessage.
   * This field, along with |originator_client_item_id|, can be used to
   * reunite the original with its official committed version in the case
   * where a client does not receive or process the commit response for
   * some reason.
   * Present only in GetUpdatesResponse.
   * This field is also used in determining the unique identifier used in
   * bookmarks' unique_position field.
   * </pre>
   *
   * <code>optional string originator_cache_guid = 19;</code>
   */
  public boolean hasOriginatorCacheGuid() {
    return ((bitField0_ & 0x00001000) == 0x00001000);
  }
  /**
   * <pre>
   * A GUID that identifies the the sync client who initially committed
   * this entity.  This value corresponds to |cache_guid| in CommitMessage.
   * This field, along with |originator_client_item_id|, can be used to
   * reunite the original with its official committed version in the case
   * where a client does not receive or process the commit response for
   * some reason.
   * Present only in GetUpdatesResponse.
   * This field is also used in determining the unique identifier used in
   * bookmarks' unique_position field.
   * </pre>
   *
   * <code>optional string originator_cache_guid = 19;</code>
   */
  public java.lang.String getOriginatorCacheGuid() {
    return originatorCacheGuid_;
  }
  /**
   * <pre>
   * A GUID that identifies the the sync client who initially committed
   * this entity.  This value corresponds to |cache_guid| in CommitMessage.
   * This field, along with |originator_client_item_id|, can be used to
   * reunite the original with its official committed version in the case
   * where a client does not receive or process the commit response for
   * some reason.
   * Present only in GetUpdatesResponse.
   * This field is also used in determining the unique identifier used in
   * bookmarks' unique_position field.
   * </pre>
   *
   * <code>optional string originator_cache_guid = 19;</code>
   */
  public com.google.protobuf.ByteString
      getOriginatorCacheGuidBytes() {
    return com.google.protobuf.ByteString.copyFromUtf8(originatorCacheGuid_);
  }
  /**
   * <pre>
   * A GUID that identifies the the sync client who initially committed
   * this entity.  This value corresponds to |cache_guid| in CommitMessage.
   * This field, along with |originator_client_item_id|, can be used to
   * reunite the original with its official committed version in the case
   * where a client does not receive or process the commit response for
   * some reason.
   * Present only in GetUpdatesResponse.
   * This field is also used in determining the unique identifier used in
   * bookmarks' unique_position field.
   * </pre>
   *
   * <code>optional string originator_cache_guid = 19;</code>
   */
  private void setOriginatorCacheGuid(
      java.lang.String value) {
    if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00001000;
    originatorCacheGuid_ = value;
  }
  /**
   * <pre>
   * A GUID that identifies the the sync client who initially committed
   * this entity.  This value corresponds to |cache_guid| in CommitMessage.
   * This field, along with |originator_client_item_id|, can be used to
   * reunite the original with its official committed version in the case
   * where a client does not receive or process the commit response for
   * some reason.
   * Present only in GetUpdatesResponse.
   * This field is also used in determining the unique identifier used in
   * bookmarks' unique_position field.
   * </pre>
   *
   * <code>optional string originator_cache_guid = 19;</code>
   */
  private void clearOriginatorCacheGuid() {
    bitField0_ = (bitField0_ & ~0x00001000);
    originatorCacheGuid_ = getDefaultInstance().getOriginatorCacheGuid();
  }
  /**
   * <pre>
   * A GUID that identifies the the sync client who initially committed
   * this entity.  This value corresponds to |cache_guid| in CommitMessage.
   * This field, along with |originator_client_item_id|, can be used to
   * reunite the original with its official committed version in the case
   * where a client does not receive or process the commit response for
   * some reason.
   * Present only in GetUpdatesResponse.
   * This field is also used in determining the unique identifier used in
   * bookmarks' unique_position field.
   * </pre>
   *
   * <code>optional string originator_cache_guid = 19;</code>
   */
  private void setOriginatorCacheGuidBytes(
      com.google.protobuf.ByteString value) {
    if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00001000;
    originatorCacheGuid_ = value.toStringUtf8();
  }

  public static final int ORIGINATOR_CLIENT_ITEM_ID_FIELD_NUMBER = 20;
  private java.lang.String originatorClientItemId_;
  /**
   * <pre>
   * The local item id of this entry from the client that initially
   * committed this entity. Typically a negative integer.
   * Present only in GetUpdatesResponse.
   * This field is also used in determinging the unique identifier used in
   * bookmarks' unique_position field.
   * </pre>
   *
   * <code>optional string originator_client_item_id = 20;</code>
   */
  public boolean hasOriginatorClientItemId() {
    return ((bitField0_ & 0x00002000) == 0x00002000);
  }
  /**
   * <pre>
   * The local item id of this entry from the client that initially
   * committed this entity. Typically a negative integer.
   * Present only in GetUpdatesResponse.
   * This field is also used in determinging the unique identifier used in
   * bookmarks' unique_position field.
   * </pre>
   *
   * <code>optional string originator_client_item_id = 20;</code>
   */
  public java.lang.String getOriginatorClientItemId() {
    return originatorClientItemId_;
  }
  /**
   * <pre>
   * The local item id of this entry from the client that initially
   * committed this entity. Typically a negative integer.
   * Present only in GetUpdatesResponse.
   * This field is also used in determinging the unique identifier used in
   * bookmarks' unique_position field.
   * </pre>
   *
   * <code>optional string originator_client_item_id = 20;</code>
   */
  public com.google.protobuf.ByteString
      getOriginatorClientItemIdBytes() {
    return com.google.protobuf.ByteString.copyFromUtf8(originatorClientItemId_);
  }
  /**
   * <pre>
   * The local item id of this entry from the client that initially
   * committed this entity. Typically a negative integer.
   * Present only in GetUpdatesResponse.
   * This field is also used in determinging the unique identifier used in
   * bookmarks' unique_position field.
   * </pre>
   *
   * <code>optional string originator_client_item_id = 20;</code>
   */
  private void setOriginatorClientItemId(
      java.lang.String value) {
    if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00002000;
    originatorClientItemId_ = value;
  }
  /**
   * <pre>
   * The local item id of this entry from the client that initially
   * committed this entity. Typically a negative integer.
   * Present only in GetUpdatesResponse.
   * This field is also used in determinging the unique identifier used in
   * bookmarks' unique_position field.
   * </pre>
   *
   * <code>optional string originator_client_item_id = 20;</code>
   */
  private void clearOriginatorClientItemId() {
    bitField0_ = (bitField0_ & ~0x00002000);
    originatorClientItemId_ = getDefaultInstance().getOriginatorClientItemId();
  }
  /**
   * <pre>
   * The local item id of this entry from the client that initially
   * committed this entity. Typically a negative integer.
   * Present only in GetUpdatesResponse.
   * This field is also used in determinging the unique identifier used in
   * bookmarks' unique_position field.
   * </pre>
   *
   * <code>optional string originator_client_item_id = 20;</code>
   */
  private void setOriginatorClientItemIdBytes(
      com.google.protobuf.ByteString value) {
    if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00002000;
    originatorClientItemId_ = value.toStringUtf8();
  }

  public static final int SPECIFICS_FIELD_NUMBER = 21;
  private org.chromium.components.sync.protocol.EntitySpecifics specifics_;
  /**
   * <pre>
   * Extensible container for datatype-specific data.
   * This became available in version 23 of the protocol.
   * </pre>
   *
   * <code>optional .sync_pb.EntitySpecifics specifics = 21;</code>
   */
  public boolean hasSpecifics() {
    return ((bitField0_ & 0x00004000) == 0x00004000);
  }
  /**
   * <pre>
   * Extensible container for datatype-specific data.
   * This became available in version 23 of the protocol.
   * </pre>
   *
   * <code>optional .sync_pb.EntitySpecifics specifics = 21;</code>
   */
  public org.chromium.components.sync.protocol.EntitySpecifics getSpecifics() {
    return specifics_ == null ? org.chromium.components.sync.protocol.EntitySpecifics.getDefaultInstance() : specifics_;
  }
  /**
   * <pre>
   * Extensible container for datatype-specific data.
   * This became available in version 23 of the protocol.
   * </pre>
   *
   * <code>optional .sync_pb.EntitySpecifics specifics = 21;</code>
   */
  private void setSpecifics(org.chromium.components.sync.protocol.EntitySpecifics value) {
    if (value == null) {
      throw new NullPointerException();
    }
    specifics_ = value;
    bitField0_ |= 0x00004000;
    }
  /**
   * <pre>
   * Extensible container for datatype-specific data.
   * This became available in version 23 of the protocol.
   * </pre>
   *
   * <code>optional .sync_pb.EntitySpecifics specifics = 21;</code>
   */
  private void setSpecifics(
      org.chromium.components.sync.protocol.EntitySpecifics.Builder builderForValue) {
    specifics_ = builderForValue.build();
    bitField0_ |= 0x00004000;
  }
  /**
   * <pre>
   * Extensible container for datatype-specific data.
   * This became available in version 23 of the protocol.
   * </pre>
   *
   * <code>optional .sync_pb.EntitySpecifics specifics = 21;</code>
   */
  private void mergeSpecifics(org.chromium.components.sync.protocol.EntitySpecifics value) {
    if (specifics_ != null &&
        specifics_ != org.chromium.components.sync.protocol.EntitySpecifics.getDefaultInstance()) {
      specifics_ =
        org.chromium.components.sync.protocol.EntitySpecifics.newBuilder(specifics_).mergeFrom(value).buildPartial();
    } else {
      specifics_ = value;
    }
    bitField0_ |= 0x00004000;
  }
  /**
   * <pre>
   * Extensible container for datatype-specific data.
   * This became available in version 23 of the protocol.
   * </pre>
   *
   * <code>optional .sync_pb.EntitySpecifics specifics = 21;</code>
   */
  private void clearSpecifics() {  specifics_ = null;
    bitField0_ = (bitField0_ & ~0x00004000);
  }

  public static final int FOLDER_FIELD_NUMBER = 22;
  private boolean folder_;
  /**
   * <pre>
   * Indicate whether this is a folder or not. Available in version 23+.
   * </pre>
   *
   * <code>optional bool folder = 22 [default = false];</code>
   */
  public boolean hasFolder() {
    return ((bitField0_ & 0x00008000) == 0x00008000);
  }
  /**
   * <pre>
   * Indicate whether this is a folder or not. Available in version 23+.
   * </pre>
   *
   * <code>optional bool folder = 22 [default = false];</code>
   */
  public boolean getFolder() {
    return folder_;
  }
  /**
   * <pre>
   * Indicate whether this is a folder or not. Available in version 23+.
   * </pre>
   *
   * <code>optional bool folder = 22 [default = false];</code>
   */
  private void setFolder(boolean value) {
    bitField0_ |= 0x00008000;
    folder_ = value;
  }
  /**
   * <pre>
   * Indicate whether this is a folder or not. Available in version 23+.
   * </pre>
   *
   * <code>optional bool folder = 22 [default = false];</code>
   */
  private void clearFolder() {
    bitField0_ = (bitField0_ & ~0x00008000);
    folder_ = false;
  }

  public static final int CLIENT_DEFINED_UNIQUE_TAG_FIELD_NUMBER = 23;
  private java.lang.String clientDefinedUniqueTag_;
  /**
   * <pre>
   * A client defined unique hash for this entity.
   * Similar to server_defined_unique_tag.
   * When initially committing an entity, a client can request that the entity
   * is unique per that account. To do so, the client should specify a
   * client_defined_unique_tag. At most one entity per tag value may exist.
   * per account. The server will enforce uniqueness on this tag
   * and fail attempts to create duplicates of this tag.
   * Will be returned in any updates for this entity.
   * The difference between server_defined_unique_tag and
   * client_defined_unique_tag is the creator of the entity. Server defined
   * tags are entities created by the server at account creation,
   * while client defined tags are entities created by the client at any time.
   * During GetUpdates, a sync entity update will come back with ONE of:
   * a) Originator and cache id - If client committed the item as non "unique"
   * b) Server tag - If server committed the item as unique
   * c) Client tag - If client committed the item as unique
   * May be present in CommitMessages for the initial creation of an entity.
   * If present in Commit updates for the entity, it will be ignored.
   * Available in version 24+.
   * May be returned in GetUpdatesMessage and sent up in CommitMessage.
   * </pre>
   *
   * <code>optional string client_defined_unique_tag = 23;</code>
   */
  public boolean hasClientDefinedUniqueTag() {
    return ((bitField0_ & 0x00010000) == 0x00010000);
  }
  /**
   * <pre>
   * A client defined unique hash for this entity.
   * Similar to server_defined_unique_tag.
   * When initially committing an entity, a client can request that the entity
   * is unique per that account. To do so, the client should specify a
   * client_defined_unique_tag. At most one entity per tag value may exist.
   * per account. The server will enforce uniqueness on this tag
   * and fail attempts to create duplicates of this tag.
   * Will be returned in any updates for this entity.
   * The difference between server_defined_unique_tag and
   * client_defined_unique_tag is the creator of the entity. Server defined
   * tags are entities created by the server at account creation,
   * while client defined tags are entities created by the client at any time.
   * During GetUpdates, a sync entity update will come back with ONE of:
   * a) Originator and cache id - If client committed the item as non "unique"
   * b) Server tag - If server committed the item as unique
   * c) Client tag - If client committed the item as unique
   * May be present in CommitMessages for the initial creation of an entity.
   * If present in Commit updates for the entity, it will be ignored.
   * Available in version 24+.
   * May be returned in GetUpdatesMessage and sent up in CommitMessage.
   * </pre>
   *
   * <code>optional string client_defined_unique_tag = 23;</code>
   */
  public java.lang.String getClientDefinedUniqueTag() {
    return clientDefinedUniqueTag_;
  }
  /**
   * <pre>
   * A client defined unique hash for this entity.
   * Similar to server_defined_unique_tag.
   * When initially committing an entity, a client can request that the entity
   * is unique per that account. To do so, the client should specify a
   * client_defined_unique_tag. At most one entity per tag value may exist.
   * per account. The server will enforce uniqueness on this tag
   * and fail attempts to create duplicates of this tag.
   * Will be returned in any updates for this entity.
   * The difference between server_defined_unique_tag and
   * client_defined_unique_tag is the creator of the entity. Server defined
   * tags are entities created by the server at account creation,
   * while client defined tags are entities created by the client at any time.
   * During GetUpdates, a sync entity update will come back with ONE of:
   * a) Originator and cache id - If client committed the item as non "unique"
   * b) Server tag - If server committed the item as unique
   * c) Client tag - If client committed the item as unique
   * May be present in CommitMessages for the initial creation of an entity.
   * If present in Commit updates for the entity, it will be ignored.
   * Available in version 24+.
   * May be returned in GetUpdatesMessage and sent up in CommitMessage.
   * </pre>
   *
   * <code>optional string client_defined_unique_tag = 23;</code>
   */
  public com.google.protobuf.ByteString
      getClientDefinedUniqueTagBytes() {
    return com.google.protobuf.ByteString.copyFromUtf8(clientDefinedUniqueTag_);
  }
  /**
   * <pre>
   * A client defined unique hash for this entity.
   * Similar to server_defined_unique_tag.
   * When initially committing an entity, a client can request that the entity
   * is unique per that account. To do so, the client should specify a
   * client_defined_unique_tag. At most one entity per tag value may exist.
   * per account. The server will enforce uniqueness on this tag
   * and fail attempts to create duplicates of this tag.
   * Will be returned in any updates for this entity.
   * The difference between server_defined_unique_tag and
   * client_defined_unique_tag is the creator of the entity. Server defined
   * tags are entities created by the server at account creation,
   * while client defined tags are entities created by the client at any time.
   * During GetUpdates, a sync entity update will come back with ONE of:
   * a) Originator and cache id - If client committed the item as non "unique"
   * b) Server tag - If server committed the item as unique
   * c) Client tag - If client committed the item as unique
   * May be present in CommitMessages for the initial creation of an entity.
   * If present in Commit updates for the entity, it will be ignored.
   * Available in version 24+.
   * May be returned in GetUpdatesMessage and sent up in CommitMessage.
   * </pre>
   *
   * <code>optional string client_defined_unique_tag = 23;</code>
   */
  private void setClientDefinedUniqueTag(
      java.lang.String value) {
    if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00010000;
    clientDefinedUniqueTag_ = value;
  }
  /**
   * <pre>
   * A client defined unique hash for this entity.
   * Similar to server_defined_unique_tag.
   * When initially committing an entity, a client can request that the entity
   * is unique per that account. To do so, the client should specify a
   * client_defined_unique_tag. At most one entity per tag value may exist.
   * per account. The server will enforce uniqueness on this tag
   * and fail attempts to create duplicates of this tag.
   * Will be returned in any updates for this entity.
   * The difference between server_defined_unique_tag and
   * client_defined_unique_tag is the creator of the entity. Server defined
   * tags are entities created by the server at account creation,
   * while client defined tags are entities created by the client at any time.
   * During GetUpdates, a sync entity update will come back with ONE of:
   * a) Originator and cache id - If client committed the item as non "unique"
   * b) Server tag - If server committed the item as unique
   * c) Client tag - If client committed the item as unique
   * May be present in CommitMessages for the initial creation of an entity.
   * If present in Commit updates for the entity, it will be ignored.
   * Available in version 24+.
   * May be returned in GetUpdatesMessage and sent up in CommitMessage.
   * </pre>
   *
   * <code>optional string client_defined_unique_tag = 23;</code>
   */
  private void clearClientDefinedUniqueTag() {
    bitField0_ = (bitField0_ & ~0x00010000);
    clientDefinedUniqueTag_ = getDefaultInstance().getClientDefinedUniqueTag();
  }
  /**
   * <pre>
   * A client defined unique hash for this entity.
   * Similar to server_defined_unique_tag.
   * When initially committing an entity, a client can request that the entity
   * is unique per that account. To do so, the client should specify a
   * client_defined_unique_tag. At most one entity per tag value may exist.
   * per account. The server will enforce uniqueness on this tag
   * and fail attempts to create duplicates of this tag.
   * Will be returned in any updates for this entity.
   * The difference between server_defined_unique_tag and
   * client_defined_unique_tag is the creator of the entity. Server defined
   * tags are entities created by the server at account creation,
   * while client defined tags are entities created by the client at any time.
   * During GetUpdates, a sync entity update will come back with ONE of:
   * a) Originator and cache id - If client committed the item as non "unique"
   * b) Server tag - If server committed the item as unique
   * c) Client tag - If client committed the item as unique
   * May be present in CommitMessages for the initial creation of an entity.
   * If present in Commit updates for the entity, it will be ignored.
   * Available in version 24+.
   * May be returned in GetUpdatesMessage and sent up in CommitMessage.
   * </pre>
   *
   * <code>optional string client_defined_unique_tag = 23;</code>
   */
  private void setClientDefinedUniqueTagBytes(
      com.google.protobuf.ByteString value) {
    if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00010000;
    clientDefinedUniqueTag_ = value.toStringUtf8();
  }

  public static final int ORDINAL_IN_PARENT_FIELD_NUMBER = 24;
  private com.google.protobuf.ByteString ordinalInParent_;
  /**
   * <pre>
   * This positioning system had a relatively short life.  It was made obsolete
   * by |unique_position| before either the client or server made much of an
   * attempt to support it.  In fact, no client ever read or set this field.
   * Deprecated in M26.
   * </pre>
   *
   * <code>optional bytes ordinal_in_parent = 24 [deprecated = true];</code>
   */
  @java.lang.Deprecated public boolean hasOrdinalInParent() {
    return ((bitField0_ & 0x00020000) == 0x00020000);
  }
  /**
   * <pre>
   * This positioning system had a relatively short life.  It was made obsolete
   * by |unique_position| before either the client or server made much of an
   * attempt to support it.  In fact, no client ever read or set this field.
   * Deprecated in M26.
   * </pre>
   *
   * <code>optional bytes ordinal_in_parent = 24 [deprecated = true];</code>
   */
  @java.lang.Deprecated public com.google.protobuf.ByteString getOrdinalInParent() {
    return ordinalInParent_;
  }
  /**
   * <pre>
   * This positioning system had a relatively short life.  It was made obsolete
   * by |unique_position| before either the client or server made much of an
   * attempt to support it.  In fact, no client ever read or set this field.
   * Deprecated in M26.
   * </pre>
   *
   * <code>optional bytes ordinal_in_parent = 24 [deprecated = true];</code>
   */
  private void setOrdinalInParent(com.google.protobuf.ByteString value) {
    if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00020000;
    ordinalInParent_ = value;
  }
  /**
   * <pre>
   * This positioning system had a relatively short life.  It was made obsolete
   * by |unique_position| before either the client or server made much of an
   * attempt to support it.  In fact, no client ever read or set this field.
   * Deprecated in M26.
   * </pre>
   *
   * <code>optional bytes ordinal_in_parent = 24 [deprecated = true];</code>
   */
  private void clearOrdinalInParent() {
    bitField0_ = (bitField0_ & ~0x00020000);
    ordinalInParent_ = getDefaultInstance().getOrdinalInParent();
  }

  public static final int UNIQUE_POSITION_FIELD_NUMBER = 25;
  private org.chromium.components.sync.protocol.UniquePosition uniquePosition_;
  /**
   * <pre>
   * This is the fourth attempt at positioning.
   * This field is present in both GetUpdatesResponse and CommitMessage, if the
   * item's type requires it and the client that wrote the item supports it (M26
   * or higher).  Clients must also be prepared to handle updates from clients
   * that do not set this field.
   * This field will not be set for items whose type ignores positioning.
   * Clients should not attempt to read this field on the receipt of an item of
   * a type that ignores positioning.
   * Refer to its definition in unique_position.proto for more information about
   * its internal representation.
   * </pre>
   *
   * <code>optional .sync_pb.UniquePosition unique_position = 25;</code>
   */
  public boolean hasUniquePosition() {
    return ((bitField0_ & 0x00040000) == 0x00040000);
  }
  /**
   * <pre>
   * This is the fourth attempt at positioning.
   * This field is present in both GetUpdatesResponse and CommitMessage, if the
   * item's type requires it and the client that wrote the item supports it (M26
   * or higher).  Clients must also be prepared to handle updates from clients
   * that do not set this field.
   * This field will not be set for items whose type ignores positioning.
   * Clients should not attempt to read this field on the receipt of an item of
   * a type that ignores positioning.
   * Refer to its definition in unique_position.proto for more information about
   * its internal representation.
   * </pre>
   *
   * <code>optional .sync_pb.UniquePosition unique_position = 25;</code>
   */
  public org.chromium.components.sync.protocol.UniquePosition getUniquePosition() {
    return uniquePosition_ == null ? org.chromium.components.sync.protocol.UniquePosition.getDefaultInstance() : uniquePosition_;
  }
  /**
   * <pre>
   * This is the fourth attempt at positioning.
   * This field is present in both GetUpdatesResponse and CommitMessage, if the
   * item's type requires it and the client that wrote the item supports it (M26
   * or higher).  Clients must also be prepared to handle updates from clients
   * that do not set this field.
   * This field will not be set for items whose type ignores positioning.
   * Clients should not attempt to read this field on the receipt of an item of
   * a type that ignores positioning.
   * Refer to its definition in unique_position.proto for more information about
   * its internal representation.
   * </pre>
   *
   * <code>optional .sync_pb.UniquePosition unique_position = 25;</code>
   */
  private void setUniquePosition(org.chromium.components.sync.protocol.UniquePosition value) {
    if (value == null) {
      throw new NullPointerException();
    }
    uniquePosition_ = value;
    bitField0_ |= 0x00040000;
    }
  /**
   * <pre>
   * This is the fourth attempt at positioning.
   * This field is present in both GetUpdatesResponse and CommitMessage, if the
   * item's type requires it and the client that wrote the item supports it (M26
   * or higher).  Clients must also be prepared to handle updates from clients
   * that do not set this field.
   * This field will not be set for items whose type ignores positioning.
   * Clients should not attempt to read this field on the receipt of an item of
   * a type that ignores positioning.
   * Refer to its definition in unique_position.proto for more information about
   * its internal representation.
   * </pre>
   *
   * <code>optional .sync_pb.UniquePosition unique_position = 25;</code>
   */
  private void setUniquePosition(
      org.chromium.components.sync.protocol.UniquePosition.Builder builderForValue) {
    uniquePosition_ = builderForValue.build();
    bitField0_ |= 0x00040000;
  }
  /**
   * <pre>
   * This is the fourth attempt at positioning.
   * This field is present in both GetUpdatesResponse and CommitMessage, if the
   * item's type requires it and the client that wrote the item supports it (M26
   * or higher).  Clients must also be prepared to handle updates from clients
   * that do not set this field.
   * This field will not be set for items whose type ignores positioning.
   * Clients should not attempt to read this field on the receipt of an item of
   * a type that ignores positioning.
   * Refer to its definition in unique_position.proto for more information about
   * its internal representation.
   * </pre>
   *
   * <code>optional .sync_pb.UniquePosition unique_position = 25;</code>
   */
  private void mergeUniquePosition(org.chromium.components.sync.protocol.UniquePosition value) {
    if (uniquePosition_ != null &&
        uniquePosition_ != org.chromium.components.sync.protocol.UniquePosition.getDefaultInstance()) {
      uniquePosition_ =
        org.chromium.components.sync.protocol.UniquePosition.newBuilder(uniquePosition_).mergeFrom(value).buildPartial();
    } else {
      uniquePosition_ = value;
    }
    bitField0_ |= 0x00040000;
  }
  /**
   * <pre>
   * This is the fourth attempt at positioning.
   * This field is present in both GetUpdatesResponse and CommitMessage, if the
   * item's type requires it and the client that wrote the item supports it (M26
   * or higher).  Clients must also be prepared to handle updates from clients
   * that do not set this field.
   * This field will not be set for items whose type ignores positioning.
   * Clients should not attempt to read this field on the receipt of an item of
   * a type that ignores positioning.
   * Refer to its definition in unique_position.proto for more information about
   * its internal representation.
   * </pre>
   *
   * <code>optional .sync_pb.UniquePosition unique_position = 25;</code>
   */
  private void clearUniquePosition() {  uniquePosition_ = null;
    bitField0_ = (bitField0_ & ~0x00040000);
  }

  public void writeTo(com.google.protobuf.CodedOutputStream output)
                      throws java.io.IOException {
    if (((bitField0_ & 0x00000001) == 0x00000001)) {
      output.writeString(1, getIdString());
    }
    if (((bitField0_ & 0x00000002) == 0x00000002)) {
      output.writeString(2, getParentIdString());
    }
    if (((bitField0_ & 0x00000004) == 0x00000004)) {
      output.writeString(3, getOldParentId());
    }
    if (((bitField0_ & 0x00000008) == 0x00000008)) {
      output.writeInt64(4, version_);
    }
    if (((bitField0_ & 0x00000010) == 0x00000010)) {
      output.writeInt64(5, mtime_);
    }
    if (((bitField0_ & 0x00000020) == 0x00000020)) {
      output.writeInt64(6, ctime_);
    }
    if (((bitField0_ & 0x00000040) == 0x00000040)) {
      output.writeString(7, getName());
    }
    if (((bitField0_ & 0x00000080) == 0x00000080)) {
      output.writeString(8, getNonUniqueName());
    }
    if (((bitField0_ & 0x00000100) == 0x00000100)) {
      output.writeString(10, getServerDefinedUniqueTag());
    }
    if (((bitField0_ & 0x00000200) == 0x00000200)) {
      output.writeInt64(15, positionInParent_);
    }
    if (((bitField0_ & 0x00000400) == 0x00000400)) {
      output.writeString(16, getInsertAfterItemId());
    }
    if (((bitField0_ & 0x00000800) == 0x00000800)) {
      output.writeBool(18, deleted_);
    }
    if (((bitField0_ & 0x00001000) == 0x00001000)) {
      output.writeString(19, getOriginatorCacheGuid());
    }
    if (((bitField0_ & 0x00002000) == 0x00002000)) {
      output.writeString(20, getOriginatorClientItemId());
    }
    if (((bitField0_ & 0x00004000) == 0x00004000)) {
      output.writeMessage(21, getSpecifics());
    }
    if (((bitField0_ & 0x00008000) == 0x00008000)) {
      output.writeBool(22, folder_);
    }
    if (((bitField0_ & 0x00010000) == 0x00010000)) {
      output.writeString(23, getClientDefinedUniqueTag());
    }
    if (((bitField0_ & 0x00020000) == 0x00020000)) {
      output.writeBytes(24, ordinalInParent_);
    }
    if (((bitField0_ & 0x00040000) == 0x00040000)) {
      output.writeMessage(25, getUniquePosition());
    }
    unknownFields.writeTo(output);
  }

  public int getSerializedSize() {
    int size = memoizedSerializedSize;
    if (size != -1) return size;

    size = 0;
    if (((bitField0_ & 0x00000001) == 0x00000001)) {
      size += com.google.protobuf.CodedOutputStream
        .computeStringSize(1, getIdString());
    }
    if (((bitField0_ & 0x00000002) == 0x00000002)) {
      size += com.google.protobuf.CodedOutputStream
        .computeStringSize(2, getParentIdString());
    }
    if (((bitField0_ & 0x00000004) == 0x00000004)) {
      size += com.google.protobuf.CodedOutputStream
        .computeStringSize(3, getOldParentId());
    }
    if (((bitField0_ & 0x00000008) == 0x00000008)) {
      size += com.google.protobuf.CodedOutputStream
        .computeInt64Size(4, version_);
    }
    if (((bitField0_ & 0x00000010) == 0x00000010)) {
      size += com.google.protobuf.CodedOutputStream
        .computeInt64Size(5, mtime_);
    }
    if (((bitField0_ & 0x00000020) == 0x00000020)) {
      size += com.google.protobuf.CodedOutputStream
        .computeInt64Size(6, ctime_);
    }
    if (((bitField0_ & 0x00000040) == 0x00000040)) {
      size += com.google.protobuf.CodedOutputStream
        .computeStringSize(7, getName());
    }
    if (((bitField0_ & 0x00000080) == 0x00000080)) {
      size += com.google.protobuf.CodedOutputStream
        .computeStringSize(8, getNonUniqueName());
    }
    if (((bitField0_ & 0x00000100) == 0x00000100)) {
      size += com.google.protobuf.CodedOutputStream
        .computeStringSize(10, getServerDefinedUniqueTag());
    }
    if (((bitField0_ & 0x00000200) == 0x00000200)) {
      size += com.google.protobuf.CodedOutputStream
        .computeInt64Size(15, positionInParent_);
    }
    if (((bitField0_ & 0x00000400) == 0x00000400)) {
      size += com.google.protobuf.CodedOutputStream
        .computeStringSize(16, getInsertAfterItemId());
    }
    if (((bitField0_ & 0x00000800) == 0x00000800)) {
      size += com.google.protobuf.CodedOutputStream
        .computeBoolSize(18, deleted_);
    }
    if (((bitField0_ & 0x00001000) == 0x00001000)) {
      size += com.google.protobuf.CodedOutputStream
        .computeStringSize(19, getOriginatorCacheGuid());
    }
    if (((bitField0_ & 0x00002000) == 0x00002000)) {
      size += com.google.protobuf.CodedOutputStream
        .computeStringSize(20, getOriginatorClientItemId());
    }
    if (((bitField0_ & 0x00004000) == 0x00004000)) {
      size += com.google.protobuf.CodedOutputStream
        .computeMessageSize(21, getSpecifics());
    }
    if (((bitField0_ & 0x00008000) == 0x00008000)) {
      size += com.google.protobuf.CodedOutputStream
        .computeBoolSize(22, folder_);
    }
    if (((bitField0_ & 0x00010000) == 0x00010000)) {
      size += com.google.protobuf.CodedOutputStream
        .computeStringSize(23, getClientDefinedUniqueTag());
    }
    if (((bitField0_ & 0x00020000) == 0x00020000)) {
      size += com.google.protobuf.CodedOutputStream
        .computeBytesSize(24, ordinalInParent_);
    }
    if (((bitField0_ & 0x00040000) == 0x00040000)) {
      size += com.google.protobuf.CodedOutputStream
        .computeMessageSize(25, getUniquePosition());
    }
    size += unknownFields.getSerializedSize();
    memoizedSerializedSize = size;
    return size;
  }

  public static org.chromium.components.sync.protocol.SyncEntity parseFrom(
      com.google.protobuf.ByteString data)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, data);
  }
  public static org.chromium.components.sync.protocol.SyncEntity parseFrom(
      com.google.protobuf.ByteString data,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, data, extensionRegistry);
  }
  public static org.chromium.components.sync.protocol.SyncEntity parseFrom(byte[] data)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, data);
  }
  public static org.chromium.components.sync.protocol.SyncEntity parseFrom(
      byte[] data,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, data, extensionRegistry);
  }
  public static org.chromium.components.sync.protocol.SyncEntity parseFrom(java.io.InputStream input)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, input);
  }
  public static org.chromium.components.sync.protocol.SyncEntity parseFrom(
      java.io.InputStream input,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, input, extensionRegistry);
  }
  public static org.chromium.components.sync.protocol.SyncEntity parseDelimitedFrom(java.io.InputStream input)
      throws java.io.IOException {
    return parseDelimitedFrom(DEFAULT_INSTANCE, input);
  }
  public static org.chromium.components.sync.protocol.SyncEntity parseDelimitedFrom(
      java.io.InputStream input,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws java.io.IOException {
    return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
  }
  public static org.chromium.components.sync.protocol.SyncEntity parseFrom(
      com.google.protobuf.CodedInputStream input)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, input);
  }
  public static org.chromium.components.sync.protocol.SyncEntity parseFrom(
      com.google.protobuf.CodedInputStream input,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, input, extensionRegistry);
  }

  public static Builder newBuilder() {
    return DEFAULT_INSTANCE.toBuilder();
  }
  public static Builder newBuilder(org.chromium.components.sync.protocol.SyncEntity prototype) {
    return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
  }

  /**
   * Protobuf type {@code sync_pb.SyncEntity}
   */
  public static final class Builder extends
      com.google.protobuf.GeneratedMessageLite.Builder<
        org.chromium.components.sync.protocol.SyncEntity, Builder> implements
      // @@protoc_insertion_point(builder_implements:sync_pb.SyncEntity)
      org.chromium.components.sync.protocol.SyncEntityOrBuilder {
    // Construct using org.chromium.components.sync.protocol.SyncEntity.newBuilder()
    private Builder() {
      super(DEFAULT_INSTANCE);
    }


    /**
     * <pre>
     * This item's identifier.  In a commit of a new item, this will be a
     * client-generated ID.  If the commit succeeds, the server will generate
     * a globally unique ID and return it to the committing client in the
     * CommitResponse.EntryResponse.  In the context of a GetUpdatesResponse,
     * |id_string| is always the server generated ID.  The original
     * client-generated ID is preserved in the |originator_client_id| field.
     * Present in both GetUpdatesResponse and CommitMessage.
     * </pre>
     *
     * <code>optional string id_string = 1;</code>
     */
    public boolean hasIdString() {
      return instance.hasIdString();
    }
    /**
     * <pre>
     * This item's identifier.  In a commit of a new item, this will be a
     * client-generated ID.  If the commit succeeds, the server will generate
     * a globally unique ID and return it to the committing client in the
     * CommitResponse.EntryResponse.  In the context of a GetUpdatesResponse,
     * |id_string| is always the server generated ID.  The original
     * client-generated ID is preserved in the |originator_client_id| field.
     * Present in both GetUpdatesResponse and CommitMessage.
     * </pre>
     *
     * <code>optional string id_string = 1;</code>
     */
    public java.lang.String getIdString() {
      return instance.getIdString();
    }
    /**
     * <pre>
     * This item's identifier.  In a commit of a new item, this will be a
     * client-generated ID.  If the commit succeeds, the server will generate
     * a globally unique ID and return it to the committing client in the
     * CommitResponse.EntryResponse.  In the context of a GetUpdatesResponse,
     * |id_string| is always the server generated ID.  The original
     * client-generated ID is preserved in the |originator_client_id| field.
     * Present in both GetUpdatesResponse and CommitMessage.
     * </pre>
     *
     * <code>optional string id_string = 1;</code>
     */
    public com.google.protobuf.ByteString
        getIdStringBytes() {
      return instance.getIdStringBytes();
    }
    /**
     * <pre>
     * This item's identifier.  In a commit of a new item, this will be a
     * client-generated ID.  If the commit succeeds, the server will generate
     * a globally unique ID and return it to the committing client in the
     * CommitResponse.EntryResponse.  In the context of a GetUpdatesResponse,
     * |id_string| is always the server generated ID.  The original
     * client-generated ID is preserved in the |originator_client_id| field.
     * Present in both GetUpdatesResponse and CommitMessage.
     * </pre>
     *
     * <code>optional string id_string = 1;</code>
     */
    public Builder setIdString(
        java.lang.String value) {
      copyOnWrite();
      instance.setIdString(value);
      return this;
    }
    /**
     * <pre>
     * This item's identifier.  In a commit of a new item, this will be a
     * client-generated ID.  If the commit succeeds, the server will generate
     * a globally unique ID and return it to the committing client in the
     * CommitResponse.EntryResponse.  In the context of a GetUpdatesResponse,
     * |id_string| is always the server generated ID.  The original
     * client-generated ID is preserved in the |originator_client_id| field.
     * Present in both GetUpdatesResponse and CommitMessage.
     * </pre>
     *
     * <code>optional string id_string = 1;</code>
     */
    public Builder clearIdString() {
      copyOnWrite();
      instance.clearIdString();
      return this;
    }
    /**
     * <pre>
     * This item's identifier.  In a commit of a new item, this will be a
     * client-generated ID.  If the commit succeeds, the server will generate
     * a globally unique ID and return it to the committing client in the
     * CommitResponse.EntryResponse.  In the context of a GetUpdatesResponse,
     * |id_string| is always the server generated ID.  The original
     * client-generated ID is preserved in the |originator_client_id| field.
     * Present in both GetUpdatesResponse and CommitMessage.
     * </pre>
     *
     * <code>optional string id_string = 1;</code>
     */
    public Builder setIdStringBytes(
        com.google.protobuf.ByteString value) {
      copyOnWrite();
      instance.setIdStringBytes(value);
      return this;
    }

    /**
     * <pre>
     * An id referencing this item's parent in the hierarchy.  In a
     * CommitMessage, it is accepted for this to be a client-generated temporary
     * ID if there was a new created item with that ID appearing earlier
     * in the message.  In all other situations, it is a server ID.
     * Present in both GetUpdatesResponse and CommitMessage.
     * </pre>
     *
     * <code>optional string parent_id_string = 2;</code>
     */
    public boolean hasParentIdString() {
      return instance.hasParentIdString();
    }
    /**
     * <pre>
     * An id referencing this item's parent in the hierarchy.  In a
     * CommitMessage, it is accepted for this to be a client-generated temporary
     * ID if there was a new created item with that ID appearing earlier
     * in the message.  In all other situations, it is a server ID.
     * Present in both GetUpdatesResponse and CommitMessage.
     * </pre>
     *
     * <code>optional string parent_id_string = 2;</code>
     */
    public java.lang.String getParentIdString() {
      return instance.getParentIdString();
    }
    /**
     * <pre>
     * An id referencing this item's parent in the hierarchy.  In a
     * CommitMessage, it is accepted for this to be a client-generated temporary
     * ID if there was a new created item with that ID appearing earlier
     * in the message.  In all other situations, it is a server ID.
     * Present in both GetUpdatesResponse and CommitMessage.
     * </pre>
     *
     * <code>optional string parent_id_string = 2;</code>
     */
    public com.google.protobuf.ByteString
        getParentIdStringBytes() {
      return instance.getParentIdStringBytes();
    }
    /**
     * <pre>
     * An id referencing this item's parent in the hierarchy.  In a
     * CommitMessage, it is accepted for this to be a client-generated temporary
     * ID if there was a new created item with that ID appearing earlier
     * in the message.  In all other situations, it is a server ID.
     * Present in both GetUpdatesResponse and CommitMessage.
     * </pre>
     *
     * <code>optional string parent_id_string = 2;</code>
     */
    public Builder setParentIdString(
        java.lang.String value) {
      copyOnWrite();
      instance.setParentIdString(value);
      return this;
    }
    /**
     * <pre>
     * An id referencing this item's parent in the hierarchy.  In a
     * CommitMessage, it is accepted for this to be a client-generated temporary
     * ID if there was a new created item with that ID appearing earlier
     * in the message.  In all other situations, it is a server ID.
     * Present in both GetUpdatesResponse and CommitMessage.
     * </pre>
     *
     * <code>optional string parent_id_string = 2;</code>
     */
    public Builder clearParentIdString() {
      copyOnWrite();
      instance.clearParentIdString();
      return this;
    }
    /**
     * <pre>
     * An id referencing this item's parent in the hierarchy.  In a
     * CommitMessage, it is accepted for this to be a client-generated temporary
     * ID if there was a new created item with that ID appearing earlier
     * in the message.  In all other situations, it is a server ID.
     * Present in both GetUpdatesResponse and CommitMessage.
     * </pre>
     *
     * <code>optional string parent_id_string = 2;</code>
     */
    public Builder setParentIdStringBytes(
        com.google.protobuf.ByteString value) {
      copyOnWrite();
      instance.setParentIdStringBytes(value);
      return this;
    }

    /**
     * <pre>
     * old_parent_id is only set in commits and indicates the old server
     * parent(s) to remove. When omitted, the old parent is the same as
     * the new.
     * Present only in CommitMessage.
     * </pre>
     *
     * <code>optional string old_parent_id = 3;</code>
     */
    public boolean hasOldParentId() {
      return instance.hasOldParentId();
    }
    /**
     * <pre>
     * old_parent_id is only set in commits and indicates the old server
     * parent(s) to remove. When omitted, the old parent is the same as
     * the new.
     * Present only in CommitMessage.
     * </pre>
     *
     * <code>optional string old_parent_id = 3;</code>
     */
    public java.lang.String getOldParentId() {
      return instance.getOldParentId();
    }
    /**
     * <pre>
     * old_parent_id is only set in commits and indicates the old server
     * parent(s) to remove. When omitted, the old parent is the same as
     * the new.
     * Present only in CommitMessage.
     * </pre>
     *
     * <code>optional string old_parent_id = 3;</code>
     */
    public com.google.protobuf.ByteString
        getOldParentIdBytes() {
      return instance.getOldParentIdBytes();
    }
    /**
     * <pre>
     * old_parent_id is only set in commits and indicates the old server
     * parent(s) to remove. When omitted, the old parent is the same as
     * the new.
     * Present only in CommitMessage.
     * </pre>
     *
     * <code>optional string old_parent_id = 3;</code>
     */
    public Builder setOldParentId(
        java.lang.String value) {
      copyOnWrite();
      instance.setOldParentId(value);
      return this;
    }
    /**
     * <pre>
     * old_parent_id is only set in commits and indicates the old server
     * parent(s) to remove. When omitted, the old parent is the same as
     * the new.
     * Present only in CommitMessage.
     * </pre>
     *
     * <code>optional string old_parent_id = 3;</code>
     */
    public Builder clearOldParentId() {
      copyOnWrite();
      instance.clearOldParentId();
      return this;
    }
    /**
     * <pre>
     * old_parent_id is only set in commits and indicates the old server
     * parent(s) to remove. When omitted, the old parent is the same as
     * the new.
     * Present only in CommitMessage.
     * </pre>
     *
     * <code>optional string old_parent_id = 3;</code>
     */
    public Builder setOldParentIdBytes(
        com.google.protobuf.ByteString value) {
      copyOnWrite();
      instance.setOldParentIdBytes(value);
      return this;
    }

    /**
     * <pre>
     * The version of this item -- a monotonically increasing value that is
     * maintained by for each item.  If zero in a CommitMessage, the server
     * will interpret this entity as a newly-created item and generate a
     * new server ID and an initial version number.  If nonzero in a
     * CommitMessage, this item is treated as an update to an existing item, and
     * the server will use |id_string| to locate the item.  Then, if the item's
     * current version on the server does not match |version|, the commit will
     * fail for that item.  The server will not update it, and will return
     * a result code of CONFLICT.  In a GetUpdatesResponse, |version| is
     * always positive and indentifies the revision of the item data being sent
     * to the client.
     * Present in both GetUpdatesResponse and CommitMessage.
     * WARNING: This field used to be required before M60. Any client before this
     * will fail to deserialize if this field is missing.
     * </pre>
     *
     * <code>optional int64 version = 4;</code>
     */
    public boolean hasVersion() {
      return instance.hasVersion();
    }
    /**
     * <pre>
     * The version of this item -- a monotonically increasing value that is
     * maintained by for each item.  If zero in a CommitMessage, the server
     * will interpret this entity as a newly-created item and generate a
     * new server ID and an initial version number.  If nonzero in a
     * CommitMessage, this item is treated as an update to an existing item, and
     * the server will use |id_string| to locate the item.  Then, if the item's
     * current version on the server does not match |version|, the commit will
     * fail for that item.  The server will not update it, and will return
     * a result code of CONFLICT.  In a GetUpdatesResponse, |version| is
     * always positive and indentifies the revision of the item data being sent
     * to the client.
     * Present in both GetUpdatesResponse and CommitMessage.
     * WARNING: This field used to be required before M60. Any client before this
     * will fail to deserialize if this field is missing.
     * </pre>
     *
     * <code>optional int64 version = 4;</code>
     */
    public long getVersion() {
      return instance.getVersion();
    }
    /**
     * <pre>
     * The version of this item -- a monotonically increasing value that is
     * maintained by for each item.  If zero in a CommitMessage, the server
     * will interpret this entity as a newly-created item and generate a
     * new server ID and an initial version number.  If nonzero in a
     * CommitMessage, this item is treated as an update to an existing item, and
     * the server will use |id_string| to locate the item.  Then, if the item's
     * current version on the server does not match |version|, the commit will
     * fail for that item.  The server will not update it, and will return
     * a result code of CONFLICT.  In a GetUpdatesResponse, |version| is
     * always positive and indentifies the revision of the item data being sent
     * to the client.
     * Present in both GetUpdatesResponse and CommitMessage.
     * WARNING: This field used to be required before M60. Any client before this
     * will fail to deserialize if this field is missing.
     * </pre>
     *
     * <code>optional int64 version = 4;</code>
     */
    public Builder setVersion(long value) {
      copyOnWrite();
      instance.setVersion(value);
      return this;
    }
    /**
     * <pre>
     * The version of this item -- a monotonically increasing value that is
     * maintained by for each item.  If zero in a CommitMessage, the server
     * will interpret this entity as a newly-created item and generate a
     * new server ID and an initial version number.  If nonzero in a
     * CommitMessage, this item is treated as an update to an existing item, and
     * the server will use |id_string| to locate the item.  Then, if the item's
     * current version on the server does not match |version|, the commit will
     * fail for that item.  The server will not update it, and will return
     * a result code of CONFLICT.  In a GetUpdatesResponse, |version| is
     * always positive and indentifies the revision of the item data being sent
     * to the client.
     * Present in both GetUpdatesResponse and CommitMessage.
     * WARNING: This field used to be required before M60. Any client before this
     * will fail to deserialize if this field is missing.
     * </pre>
     *
     * <code>optional int64 version = 4;</code>
     */
    public Builder clearVersion() {
      copyOnWrite();
      instance.clearVersion();
      return this;
    }

    /**
     * <pre>
     * Last modification time (in java time milliseconds)
     * Present in both GetUpdatesResponse and CommitMessage.
     * </pre>
     *
     * <code>optional int64 mtime = 5;</code>
     */
    public boolean hasMtime() {
      return instance.hasMtime();
    }
    /**
     * <pre>
     * Last modification time (in java time milliseconds)
     * Present in both GetUpdatesResponse and CommitMessage.
     * </pre>
     *
     * <code>optional int64 mtime = 5;</code>
     */
    public long getMtime() {
      return instance.getMtime();
    }
    /**
     * <pre>
     * Last modification time (in java time milliseconds)
     * Present in both GetUpdatesResponse and CommitMessage.
     * </pre>
     *
     * <code>optional int64 mtime = 5;</code>
     */
    public Builder setMtime(long value) {
      copyOnWrite();
      instance.setMtime(value);
      return this;
    }
    /**
     * <pre>
     * Last modification time (in java time milliseconds)
     * Present in both GetUpdatesResponse and CommitMessage.
     * </pre>
     *
     * <code>optional int64 mtime = 5;</code>
     */
    public Builder clearMtime() {
      copyOnWrite();
      instance.clearMtime();
      return this;
    }

    /**
     * <pre>
     * Creation time.
     * Present in both GetUpdatesResponse and CommitMessage.
     * </pre>
     *
     * <code>optional int64 ctime = 6;</code>
     */
    public boolean hasCtime() {
      return instance.hasCtime();
    }
    /**
     * <pre>
     * Creation time.
     * Present in both GetUpdatesResponse and CommitMessage.
     * </pre>
     *
     * <code>optional int64 ctime = 6;</code>
     */
    public long getCtime() {
      return instance.getCtime();
    }
    /**
     * <pre>
     * Creation time.
     * Present in both GetUpdatesResponse and CommitMessage.
     * </pre>
     *
     * <code>optional int64 ctime = 6;</code>
     */
    public Builder setCtime(long value) {
      copyOnWrite();
      instance.setCtime(value);
      return this;
    }
    /**
     * <pre>
     * Creation time.
     * Present in both GetUpdatesResponse and CommitMessage.
     * </pre>
     *
     * <code>optional int64 ctime = 6;</code>
     */
    public Builder clearCtime() {
      copyOnWrite();
      instance.clearCtime();
      return this;
    }

    /**
     * <pre>
     * The name of this item.
     * Historical note:
     *   Since November 2010, this value is no different from non_unique_name.
     *   Before then, server implementations would maintain a unique-within-parent
     *   value separate from its base, "non-unique" value.  Clients had not
     *   depended on the uniqueness of the property since November 2009; it was
     *   removed from Chromium by http://codereview.chromium.org/371029 .
     * Present in both GetUpdatesResponse and CommitMessage.
     * WARNING: This field used to be required before M60. Any client before this
     * will fail to deserialize if this field is missing.
     * </pre>
     *
     * <code>optional string name = 7;</code>
     */
    public boolean hasName() {
      return instance.hasName();
    }
    /**
     * <pre>
     * The name of this item.
     * Historical note:
     *   Since November 2010, this value is no different from non_unique_name.
     *   Before then, server implementations would maintain a unique-within-parent
     *   value separate from its base, "non-unique" value.  Clients had not
     *   depended on the uniqueness of the property since November 2009; it was
     *   removed from Chromium by http://codereview.chromium.org/371029 .
     * Present in both GetUpdatesResponse and CommitMessage.
     * WARNING: This field used to be required before M60. Any client before this
     * will fail to deserialize if this field is missing.
     * </pre>
     *
     * <code>optional string name = 7;</code>
     */
    public java.lang.String getName() {
      return instance.getName();
    }
    /**
     * <pre>
     * The name of this item.
     * Historical note:
     *   Since November 2010, this value is no different from non_unique_name.
     *   Before then, server implementations would maintain a unique-within-parent
     *   value separate from its base, "non-unique" value.  Clients had not
     *   depended on the uniqueness of the property since November 2009; it was
     *   removed from Chromium by http://codereview.chromium.org/371029 .
     * Present in both GetUpdatesResponse and CommitMessage.
     * WARNING: This field used to be required before M60. Any client before this
     * will fail to deserialize if this field is missing.
     * </pre>
     *
     * <code>optional string name = 7;</code>
     */
    public com.google.protobuf.ByteString
        getNameBytes() {
      return instance.getNameBytes();
    }
    /**
     * <pre>
     * The name of this item.
     * Historical note:
     *   Since November 2010, this value is no different from non_unique_name.
     *   Before then, server implementations would maintain a unique-within-parent
     *   value separate from its base, "non-unique" value.  Clients had not
     *   depended on the uniqueness of the property since November 2009; it was
     *   removed from Chromium by http://codereview.chromium.org/371029 .
     * Present in both GetUpdatesResponse and CommitMessage.
     * WARNING: This field used to be required before M60. Any client before this
     * will fail to deserialize if this field is missing.
     * </pre>
     *
     * <code>optional string name = 7;</code>
     */
    public Builder setName(
        java.lang.String value) {
      copyOnWrite();
      instance.setName(value);
      return this;
    }
    /**
     * <pre>
     * The name of this item.
     * Historical note:
     *   Since November 2010, this value is no different from non_unique_name.
     *   Before then, server implementations would maintain a unique-within-parent
     *   value separate from its base, "non-unique" value.  Clients had not
     *   depended on the uniqueness of the property since November 2009; it was
     *   removed from Chromium by http://codereview.chromium.org/371029 .
     * Present in both GetUpdatesResponse and CommitMessage.
     * WARNING: This field used to be required before M60. Any client before this
     * will fail to deserialize if this field is missing.
     * </pre>
     *
     * <code>optional string name = 7;</code>
     */
    public Builder clearName() {
      copyOnWrite();
      instance.clearName();
      return this;
    }
    /**
     * <pre>
     * The name of this item.
     * Historical note:
     *   Since November 2010, this value is no different from non_unique_name.
     *   Before then, server implementations would maintain a unique-within-parent
     *   value separate from its base, "non-unique" value.  Clients had not
     *   depended on the uniqueness of the property since November 2009; it was
     *   removed from Chromium by http://codereview.chromium.org/371029 .
     * Present in both GetUpdatesResponse and CommitMessage.
     * WARNING: This field used to be required before M60. Any client before this
     * will fail to deserialize if this field is missing.
     * </pre>
     *
     * <code>optional string name = 7;</code>
     */
    public Builder setNameBytes(
        com.google.protobuf.ByteString value) {
      copyOnWrite();
      instance.setNameBytes(value);
      return this;
    }

    /**
     * <pre>
     * The name of this item.  Same as |name|.
     * |non_unique_name| should take precedence over the |name| value if both
     * are supplied.  For efficiency, clients and servers should avoid setting
     * this redundant value.
     * Present in both GetUpdatesResponse and CommitMessage.
     * </pre>
     *
     * <code>optional string non_unique_name = 8;</code>
     */
    public boolean hasNonUniqueName() {
      return instance.hasNonUniqueName();
    }
    /**
     * <pre>
     * The name of this item.  Same as |name|.
     * |non_unique_name| should take precedence over the |name| value if both
     * are supplied.  For efficiency, clients and servers should avoid setting
     * this redundant value.
     * Present in both GetUpdatesResponse and CommitMessage.
     * </pre>
     *
     * <code>optional string non_unique_name = 8;</code>
     */
    public java.lang.String getNonUniqueName() {
      return instance.getNonUniqueName();
    }
    /**
     * <pre>
     * The name of this item.  Same as |name|.
     * |non_unique_name| should take precedence over the |name| value if both
     * are supplied.  For efficiency, clients and servers should avoid setting
     * this redundant value.
     * Present in both GetUpdatesResponse and CommitMessage.
     * </pre>
     *
     * <code>optional string non_unique_name = 8;</code>
     */
    public com.google.protobuf.ByteString
        getNonUniqueNameBytes() {
      return instance.getNonUniqueNameBytes();
    }
    /**
     * <pre>
     * The name of this item.  Same as |name|.
     * |non_unique_name| should take precedence over the |name| value if both
     * are supplied.  For efficiency, clients and servers should avoid setting
     * this redundant value.
     * Present in both GetUpdatesResponse and CommitMessage.
     * </pre>
     *
     * <code>optional string non_unique_name = 8;</code>
     */
    public Builder setNonUniqueName(
        java.lang.String value) {
      copyOnWrite();
      instance.setNonUniqueName(value);
      return this;
    }
    /**
     * <pre>
     * The name of this item.  Same as |name|.
     * |non_unique_name| should take precedence over the |name| value if both
     * are supplied.  For efficiency, clients and servers should avoid setting
     * this redundant value.
     * Present in both GetUpdatesResponse and CommitMessage.
     * </pre>
     *
     * <code>optional string non_unique_name = 8;</code>
     */
    public Builder clearNonUniqueName() {
      copyOnWrite();
      instance.clearNonUniqueName();
      return this;
    }
    /**
     * <pre>
     * The name of this item.  Same as |name|.
     * |non_unique_name| should take precedence over the |name| value if both
     * are supplied.  For efficiency, clients and servers should avoid setting
     * this redundant value.
     * Present in both GetUpdatesResponse and CommitMessage.
     * </pre>
     *
     * <code>optional string non_unique_name = 8;</code>
     */
    public Builder setNonUniqueNameBytes(
        com.google.protobuf.ByteString value) {
      copyOnWrite();
      instance.setNonUniqueNameBytes(value);
      return this;
    }

    /**
     * <pre>
     * If present, this tag identifies this item as being a uniquely
     * instanced item.  The server ensures that there is never more
     * than one entity in a user's store with the same tag value.
     * This value is used to identify and find e.g. the "Google Chrome" settings
     * folder without relying on it existing at a particular path, or having
     * a particular name, in the data store.
     * This variant of the tag is created by the server, so clients can't create
     * an item with a tag using this field.
     * Use client_defined_unique_tag if you want to create one from the client.
     * An item can't have both a client_defined_unique_tag and
     * a server_defined_unique_tag.
     * Present only in GetUpdatesResponse.
     * </pre>
     *
     * <code>optional string server_defined_unique_tag = 10;</code>
     */
    public boolean hasServerDefinedUniqueTag() {
      return instance.hasServerDefinedUniqueTag();
    }
    /**
     * <pre>
     * If present, this tag identifies this item as being a uniquely
     * instanced item.  The server ensures that there is never more
     * than one entity in a user's store with the same tag value.
     * This value is used to identify and find e.g. the "Google Chrome" settings
     * folder without relying on it existing at a particular path, or having
     * a particular name, in the data store.
     * This variant of the tag is created by the server, so clients can't create
     * an item with a tag using this field.
     * Use client_defined_unique_tag if you want to create one from the client.
     * An item can't have both a client_defined_unique_tag and
     * a server_defined_unique_tag.
     * Present only in GetUpdatesResponse.
     * </pre>
     *
     * <code>optional string server_defined_unique_tag = 10;</code>
     */
    public java.lang.String getServerDefinedUniqueTag() {
      return instance.getServerDefinedUniqueTag();
    }
    /**
     * <pre>
     * If present, this tag identifies this item as being a uniquely
     * instanced item.  The server ensures that there is never more
     * than one entity in a user's store with the same tag value.
     * This value is used to identify and find e.g. the "Google Chrome" settings
     * folder without relying on it existing at a particular path, or having
     * a particular name, in the data store.
     * This variant of the tag is created by the server, so clients can't create
     * an item with a tag using this field.
     * Use client_defined_unique_tag if you want to create one from the client.
     * An item can't have both a client_defined_unique_tag and
     * a server_defined_unique_tag.
     * Present only in GetUpdatesResponse.
     * </pre>
     *
     * <code>optional string server_defined_unique_tag = 10;</code>
     */
    public com.google.protobuf.ByteString
        getServerDefinedUniqueTagBytes() {
      return instance.getServerDefinedUniqueTagBytes();
    }
    /**
     * <pre>
     * If present, this tag identifies this item as being a uniquely
     * instanced item.  The server ensures that there is never more
     * than one entity in a user's store with the same tag value.
     * This value is used to identify and find e.g. the "Google Chrome" settings
     * folder without relying on it existing at a particular path, or having
     * a particular name, in the data store.
     * This variant of the tag is created by the server, so clients can't create
     * an item with a tag using this field.
     * Use client_defined_unique_tag if you want to create one from the client.
     * An item can't have both a client_defined_unique_tag and
     * a server_defined_unique_tag.
     * Present only in GetUpdatesResponse.
     * </pre>
     *
     * <code>optional string server_defined_unique_tag = 10;</code>
     */
    public Builder setServerDefinedUniqueTag(
        java.lang.String value) {
      copyOnWrite();
      instance.setServerDefinedUniqueTag(value);
      return this;
    }
    /**
     * <pre>
     * If present, this tag identifies this item as being a uniquely
     * instanced item.  The server ensures that there is never more
     * than one entity in a user's store with the same tag value.
     * This value is used to identify and find e.g. the "Google Chrome" settings
     * folder without relying on it existing at a particular path, or having
     * a particular name, in the data store.
     * This variant of the tag is created by the server, so clients can't create
     * an item with a tag using this field.
     * Use client_defined_unique_tag if you want to create one from the client.
     * An item can't have both a client_defined_unique_tag and
     * a server_defined_unique_tag.
     * Present only in GetUpdatesResponse.
     * </pre>
     *
     * <code>optional string server_defined_unique_tag = 10;</code>
     */
    public Builder clearServerDefinedUniqueTag() {
      copyOnWrite();
      instance.clearServerDefinedUniqueTag();
      return this;
    }
    /**
     * <pre>
     * If present, this tag identifies this item as being a uniquely
     * instanced item.  The server ensures that there is never more
     * than one entity in a user's store with the same tag value.
     * This value is used to identify and find e.g. the "Google Chrome" settings
     * folder without relying on it existing at a particular path, or having
     * a particular name, in the data store.
     * This variant of the tag is created by the server, so clients can't create
     * an item with a tag using this field.
     * Use client_defined_unique_tag if you want to create one from the client.
     * An item can't have both a client_defined_unique_tag and
     * a server_defined_unique_tag.
     * Present only in GetUpdatesResponse.
     * </pre>
     *
     * <code>optional string server_defined_unique_tag = 10;</code>
     */
    public Builder setServerDefinedUniqueTagBytes(
        com.google.protobuf.ByteString value) {
      copyOnWrite();
      instance.setServerDefinedUniqueTagBytes(value);
      return this;
    }

    /**
     * <pre>
     * Supplies a numeric position for this item, relative to other items with the
     * same parent.  Deprecated in M26, though clients are still required to set
     * it.
     * Present in both GetUpdatesResponse and CommitMessage.
     * At one point this was used as an alternative / supplement to
     * the deprecated |insert_after_item_id|, but now it, too, has been
     * deprecated.
     * In order to maintain compatibility with older clients, newer clients should
     * still set this field.  Its value should be based on the first 8 bytes of
     * this item's |unique_position|.
     * Nerwer clients must also support the receipt of items that contain
     * |position_in_parent| but no |unique_position|.  They should locally convert
     * the given int64 position to a UniquePosition.
     * The conversion from int64 to UniquePosition is as follows:
     * The int64 value will have its sign bit flipped then placed in big endian
     * order as the first 8 bytes of the UniquePosition.  The subsequent bytes of
     * the UniquePosition will consist of the item's unique suffix.
     * Conversion from UniquePosition to int64 reverses this process: the first 8
     * bytes of the position are to be interpreted as a big endian int64 value
     * with its sign bit flipped.
     * </pre>
     *
     * <code>optional int64 position_in_parent = 15 [deprecated = true];</code>
     */
    @java.lang.Deprecated public boolean hasPositionInParent() {
      return instance.hasPositionInParent();
    }
    /**
     * <pre>
     * Supplies a numeric position for this item, relative to other items with the
     * same parent.  Deprecated in M26, though clients are still required to set
     * it.
     * Present in both GetUpdatesResponse and CommitMessage.
     * At one point this was used as an alternative / supplement to
     * the deprecated |insert_after_item_id|, but now it, too, has been
     * deprecated.
     * In order to maintain compatibility with older clients, newer clients should
     * still set this field.  Its value should be based on the first 8 bytes of
     * this item's |unique_position|.
     * Nerwer clients must also support the receipt of items that contain
     * |position_in_parent| but no |unique_position|.  They should locally convert
     * the given int64 position to a UniquePosition.
     * The conversion from int64 to UniquePosition is as follows:
     * The int64 value will have its sign bit flipped then placed in big endian
     * order as the first 8 bytes of the UniquePosition.  The subsequent bytes of
     * the UniquePosition will consist of the item's unique suffix.
     * Conversion from UniquePosition to int64 reverses this process: the first 8
     * bytes of the position are to be interpreted as a big endian int64 value
     * with its sign bit flipped.
     * </pre>
     *
     * <code>optional int64 position_in_parent = 15 [deprecated = true];</code>
     */
    @java.lang.Deprecated public long getPositionInParent() {
      return instance.getPositionInParent();
    }
    /**
     * <pre>
     * Supplies a numeric position for this item, relative to other items with the
     * same parent.  Deprecated in M26, though clients are still required to set
     * it.
     * Present in both GetUpdatesResponse and CommitMessage.
     * At one point this was used as an alternative / supplement to
     * the deprecated |insert_after_item_id|, but now it, too, has been
     * deprecated.
     * In order to maintain compatibility with older clients, newer clients should
     * still set this field.  Its value should be based on the first 8 bytes of
     * this item's |unique_position|.
     * Nerwer clients must also support the receipt of items that contain
     * |position_in_parent| but no |unique_position|.  They should locally convert
     * the given int64 position to a UniquePosition.
     * The conversion from int64 to UniquePosition is as follows:
     * The int64 value will have its sign bit flipped then placed in big endian
     * order as the first 8 bytes of the UniquePosition.  The subsequent bytes of
     * the UniquePosition will consist of the item's unique suffix.
     * Conversion from UniquePosition to int64 reverses this process: the first 8
     * bytes of the position are to be interpreted as a big endian int64 value
     * with its sign bit flipped.
     * </pre>
     *
     * <code>optional int64 position_in_parent = 15 [deprecated = true];</code>
     */
    @java.lang.Deprecated public Builder setPositionInParent(long value) {
      copyOnWrite();
      instance.setPositionInParent(value);
      return this;
    }
    /**
     * <pre>
     * Supplies a numeric position for this item, relative to other items with the
     * same parent.  Deprecated in M26, though clients are still required to set
     * it.
     * Present in both GetUpdatesResponse and CommitMessage.
     * At one point this was used as an alternative / supplement to
     * the deprecated |insert_after_item_id|, but now it, too, has been
     * deprecated.
     * In order to maintain compatibility with older clients, newer clients should
     * still set this field.  Its value should be based on the first 8 bytes of
     * this item's |unique_position|.
     * Nerwer clients must also support the receipt of items that contain
     * |position_in_parent| but no |unique_position|.  They should locally convert
     * the given int64 position to a UniquePosition.
     * The conversion from int64 to UniquePosition is as follows:
     * The int64 value will have its sign bit flipped then placed in big endian
     * order as the first 8 bytes of the UniquePosition.  The subsequent bytes of
     * the UniquePosition will consist of the item's unique suffix.
     * Conversion from UniquePosition to int64 reverses this process: the first 8
     * bytes of the position are to be interpreted as a big endian int64 value
     * with its sign bit flipped.
     * </pre>
     *
     * <code>optional int64 position_in_parent = 15 [deprecated = true];</code>
     */
    @java.lang.Deprecated public Builder clearPositionInParent() {
      copyOnWrite();
      instance.clearPositionInParent();
      return this;
    }

    /**
     * <pre>
     * Contains the ID of the element (under the same parent) after which this
     * element resides. An empty string indicates that the element is the first
     * element in the parent.  This value is used during commits to specify
     * a relative position for a position change.  In the context of
     * a GetUpdatesMessage, |position_in_parent| is used instead to
     * communicate position.
     * Present only in CommitMessage.
     * This is deprecated.  Clients are allowed to omit this as long as they
     * include |position_in_parent| instead.
     * </pre>
     *
     * <code>optional string insert_after_item_id = 16 [deprecated = true];</code>
     */
    @java.lang.Deprecated public boolean hasInsertAfterItemId() {
      return instance.hasInsertAfterItemId();
    }
    /**
     * <pre>
     * Contains the ID of the element (under the same parent) after which this
     * element resides. An empty string indicates that the element is the first
     * element in the parent.  This value is used during commits to specify
     * a relative position for a position change.  In the context of
     * a GetUpdatesMessage, |position_in_parent| is used instead to
     * communicate position.
     * Present only in CommitMessage.
     * This is deprecated.  Clients are allowed to omit this as long as they
     * include |position_in_parent| instead.
     * </pre>
     *
     * <code>optional string insert_after_item_id = 16 [deprecated = true];</code>
     */
    @java.lang.Deprecated public java.lang.String getInsertAfterItemId() {
      return instance.getInsertAfterItemId();
    }
    /**
     * <pre>
     * Contains the ID of the element (under the same parent) after which this
     * element resides. An empty string indicates that the element is the first
     * element in the parent.  This value is used during commits to specify
     * a relative position for a position change.  In the context of
     * a GetUpdatesMessage, |position_in_parent| is used instead to
     * communicate position.
     * Present only in CommitMessage.
     * This is deprecated.  Clients are allowed to omit this as long as they
     * include |position_in_parent| instead.
     * </pre>
     *
     * <code>optional string insert_after_item_id = 16 [deprecated = true];</code>
     */
    @java.lang.Deprecated public com.google.protobuf.ByteString
        getInsertAfterItemIdBytes() {
      return instance.getInsertAfterItemIdBytes();
    }
    /**
     * <pre>
     * Contains the ID of the element (under the same parent) after which this
     * element resides. An empty string indicates that the element is the first
     * element in the parent.  This value is used during commits to specify
     * a relative position for a position change.  In the context of
     * a GetUpdatesMessage, |position_in_parent| is used instead to
     * communicate position.
     * Present only in CommitMessage.
     * This is deprecated.  Clients are allowed to omit this as long as they
     * include |position_in_parent| instead.
     * </pre>
     *
     * <code>optional string insert_after_item_id = 16 [deprecated = true];</code>
     */
    @java.lang.Deprecated public Builder setInsertAfterItemId(
        java.lang.String value) {
      copyOnWrite();
      instance.setInsertAfterItemId(value);
      return this;
    }
    /**
     * <pre>
     * Contains the ID of the element (under the same parent) after which this
     * element resides. An empty string indicates that the element is the first
     * element in the parent.  This value is used during commits to specify
     * a relative position for a position change.  In the context of
     * a GetUpdatesMessage, |position_in_parent| is used instead to
     * communicate position.
     * Present only in CommitMessage.
     * This is deprecated.  Clients are allowed to omit this as long as they
     * include |position_in_parent| instead.
     * </pre>
     *
     * <code>optional string insert_after_item_id = 16 [deprecated = true];</code>
     */
    @java.lang.Deprecated public Builder clearInsertAfterItemId() {
      copyOnWrite();
      instance.clearInsertAfterItemId();
      return this;
    }
    /**
     * <pre>
     * Contains the ID of the element (under the same parent) after which this
     * element resides. An empty string indicates that the element is the first
     * element in the parent.  This value is used during commits to specify
     * a relative position for a position change.  In the context of
     * a GetUpdatesMessage, |position_in_parent| is used instead to
     * communicate position.
     * Present only in CommitMessage.
     * This is deprecated.  Clients are allowed to omit this as long as they
     * include |position_in_parent| instead.
     * </pre>
     *
     * <code>optional string insert_after_item_id = 16 [deprecated = true];</code>
     */
    @java.lang.Deprecated public Builder setInsertAfterItemIdBytes(
        com.google.protobuf.ByteString value) {
      copyOnWrite();
      instance.setInsertAfterItemIdBytes(value);
      return this;
    }

    /**
     * <pre>
     * If true, indicates that this item has been (or should be) deleted.
     * Present in both GetUpdatesResponse and CommitMessage.
     * </pre>
     *
     * <code>optional bool deleted = 18 [default = false];</code>
     */
    public boolean hasDeleted() {
      return instance.hasDeleted();
    }
    /**
     * <pre>
     * If true, indicates that this item has been (or should be) deleted.
     * Present in both GetUpdatesResponse and CommitMessage.
     * </pre>
     *
     * <code>optional bool deleted = 18 [default = false];</code>
     */
    public boolean getDeleted() {
      return instance.getDeleted();
    }
    /**
     * <pre>
     * If true, indicates that this item has been (or should be) deleted.
     * Present in both GetUpdatesResponse and CommitMessage.
     * </pre>
     *
     * <code>optional bool deleted = 18 [default = false];</code>
     */
    public Builder setDeleted(boolean value) {
      copyOnWrite();
      instance.setDeleted(value);
      return this;
    }
    /**
     * <pre>
     * If true, indicates that this item has been (or should be) deleted.
     * Present in both GetUpdatesResponse and CommitMessage.
     * </pre>
     *
     * <code>optional bool deleted = 18 [default = false];</code>
     */
    public Builder clearDeleted() {
      copyOnWrite();
      instance.clearDeleted();
      return this;
    }

    /**
     * <pre>
     * A GUID that identifies the the sync client who initially committed
     * this entity.  This value corresponds to |cache_guid| in CommitMessage.
     * This field, along with |originator_client_item_id|, can be used to
     * reunite the original with its official committed version in the case
     * where a client does not receive or process the commit response for
     * some reason.
     * Present only in GetUpdatesResponse.
     * This field is also used in determining the unique identifier used in
     * bookmarks' unique_position field.
     * </pre>
     *
     * <code>optional string originator_cache_guid = 19;</code>
     */
    public boolean hasOriginatorCacheGuid() {
      return instance.hasOriginatorCacheGuid();
    }
    /**
     * <pre>
     * A GUID that identifies the the sync client who initially committed
     * this entity.  This value corresponds to |cache_guid| in CommitMessage.
     * This field, along with |originator_client_item_id|, can be used to
     * reunite the original with its official committed version in the case
     * where a client does not receive or process the commit response for
     * some reason.
     * Present only in GetUpdatesResponse.
     * This field is also used in determining the unique identifier used in
     * bookmarks' unique_position field.
     * </pre>
     *
     * <code>optional string originator_cache_guid = 19;</code>
     */
    public java.lang.String getOriginatorCacheGuid() {
      return instance.getOriginatorCacheGuid();
    }
    /**
     * <pre>
     * A GUID that identifies the the sync client who initially committed
     * this entity.  This value corresponds to |cache_guid| in CommitMessage.
     * This field, along with |originator_client_item_id|, can be used to
     * reunite the original with its official committed version in the case
     * where a client does not receive or process the commit response for
     * some reason.
     * Present only in GetUpdatesResponse.
     * This field is also used in determining the unique identifier used in
     * bookmarks' unique_position field.
     * </pre>
     *
     * <code>optional string originator_cache_guid = 19;</code>
     */
    public com.google.protobuf.ByteString
        getOriginatorCacheGuidBytes() {
      return instance.getOriginatorCacheGuidBytes();
    }
    /**
     * <pre>
     * A GUID that identifies the the sync client who initially committed
     * this entity.  This value corresponds to |cache_guid| in CommitMessage.
     * This field, along with |originator_client_item_id|, can be used to
     * reunite the original with its official committed version in the case
     * where a client does not receive or process the commit response for
     * some reason.
     * Present only in GetUpdatesResponse.
     * This field is also used in determining the unique identifier used in
     * bookmarks' unique_position field.
     * </pre>
     *
     * <code>optional string originator_cache_guid = 19;</code>
     */
    public Builder setOriginatorCacheGuid(
        java.lang.String value) {
      copyOnWrite();
      instance.setOriginatorCacheGuid(value);
      return this;
    }
    /**
     * <pre>
     * A GUID that identifies the the sync client who initially committed
     * this entity.  This value corresponds to |cache_guid| in CommitMessage.
     * This field, along with |originator_client_item_id|, can be used to
     * reunite the original with its official committed version in the case
     * where a client does not receive or process the commit response for
     * some reason.
     * Present only in GetUpdatesResponse.
     * This field is also used in determining the unique identifier used in
     * bookmarks' unique_position field.
     * </pre>
     *
     * <code>optional string originator_cache_guid = 19;</code>
     */
    public Builder clearOriginatorCacheGuid() {
      copyOnWrite();
      instance.clearOriginatorCacheGuid();
      return this;
    }
    /**
     * <pre>
     * A GUID that identifies the the sync client who initially committed
     * this entity.  This value corresponds to |cache_guid| in CommitMessage.
     * This field, along with |originator_client_item_id|, can be used to
     * reunite the original with its official committed version in the case
     * where a client does not receive or process the commit response for
     * some reason.
     * Present only in GetUpdatesResponse.
     * This field is also used in determining the unique identifier used in
     * bookmarks' unique_position field.
     * </pre>
     *
     * <code>optional string originator_cache_guid = 19;</code>
     */
    public Builder setOriginatorCacheGuidBytes(
        com.google.protobuf.ByteString value) {
      copyOnWrite();
      instance.setOriginatorCacheGuidBytes(value);
      return this;
    }

    /**
     * <pre>
     * The local item id of this entry from the client that initially
     * committed this entity. Typically a negative integer.
     * Present only in GetUpdatesResponse.
     * This field is also used in determinging the unique identifier used in
     * bookmarks' unique_position field.
     * </pre>
     *
     * <code>optional string originator_client_item_id = 20;</code>
     */
    public boolean hasOriginatorClientItemId() {
      return instance.hasOriginatorClientItemId();
    }
    /**
     * <pre>
     * The local item id of this entry from the client that initially
     * committed this entity. Typically a negative integer.
     * Present only in GetUpdatesResponse.
     * This field is also used in determinging the unique identifier used in
     * bookmarks' unique_position field.
     * </pre>
     *
     * <code>optional string originator_client_item_id = 20;</code>
     */
    public java.lang.String getOriginatorClientItemId() {
      return instance.getOriginatorClientItemId();
    }
    /**
     * <pre>
     * The local item id of this entry from the client that initially
     * committed this entity. Typically a negative integer.
     * Present only in GetUpdatesResponse.
     * This field is also used in determinging the unique identifier used in
     * bookmarks' unique_position field.
     * </pre>
     *
     * <code>optional string originator_client_item_id = 20;</code>
     */
    public com.google.protobuf.ByteString
        getOriginatorClientItemIdBytes() {
      return instance.getOriginatorClientItemIdBytes();
    }
    /**
     * <pre>
     * The local item id of this entry from the client that initially
     * committed this entity. Typically a negative integer.
     * Present only in GetUpdatesResponse.
     * This field is also used in determinging the unique identifier used in
     * bookmarks' unique_position field.
     * </pre>
     *
     * <code>optional string originator_client_item_id = 20;</code>
     */
    public Builder setOriginatorClientItemId(
        java.lang.String value) {
      copyOnWrite();
      instance.setOriginatorClientItemId(value);
      return this;
    }
    /**
     * <pre>
     * The local item id of this entry from the client that initially
     * committed this entity. Typically a negative integer.
     * Present only in GetUpdatesResponse.
     * This field is also used in determinging the unique identifier used in
     * bookmarks' unique_position field.
     * </pre>
     *
     * <code>optional string originator_client_item_id = 20;</code>
     */
    public Builder clearOriginatorClientItemId() {
      copyOnWrite();
      instance.clearOriginatorClientItemId();
      return this;
    }
    /**
     * <pre>
     * The local item id of this entry from the client that initially
     * committed this entity. Typically a negative integer.
     * Present only in GetUpdatesResponse.
     * This field is also used in determinging the unique identifier used in
     * bookmarks' unique_position field.
     * </pre>
     *
     * <code>optional string originator_client_item_id = 20;</code>
     */
    public Builder setOriginatorClientItemIdBytes(
        com.google.protobuf.ByteString value) {
      copyOnWrite();
      instance.setOriginatorClientItemIdBytes(value);
      return this;
    }

    /**
     * <pre>
     * Extensible container for datatype-specific data.
     * This became available in version 23 of the protocol.
     * </pre>
     *
     * <code>optional .sync_pb.EntitySpecifics specifics = 21;</code>
     */
    public boolean hasSpecifics() {
      return instance.hasSpecifics();
    }
    /**
     * <pre>
     * Extensible container for datatype-specific data.
     * This became available in version 23 of the protocol.
     * </pre>
     *
     * <code>optional .sync_pb.EntitySpecifics specifics = 21;</code>
     */
    public org.chromium.components.sync.protocol.EntitySpecifics getSpecifics() {
      return instance.getSpecifics();
    }
    /**
     * <pre>
     * Extensible container for datatype-specific data.
     * This became available in version 23 of the protocol.
     * </pre>
     *
     * <code>optional .sync_pb.EntitySpecifics specifics = 21;</code>
     */
    public Builder setSpecifics(org.chromium.components.sync.protocol.EntitySpecifics value) {
      copyOnWrite();
      instance.setSpecifics(value);
      return this;
      }
    /**
     * <pre>
     * Extensible container for datatype-specific data.
     * This became available in version 23 of the protocol.
     * </pre>
     *
     * <code>optional .sync_pb.EntitySpecifics specifics = 21;</code>
     */
    public Builder setSpecifics(
        org.chromium.components.sync.protocol.EntitySpecifics.Builder builderForValue) {
      copyOnWrite();
      instance.setSpecifics(builderForValue);
      return this;
    }
    /**
     * <pre>
     * Extensible container for datatype-specific data.
     * This became available in version 23 of the protocol.
     * </pre>
     *
     * <code>optional .sync_pb.EntitySpecifics specifics = 21;</code>
     */
    public Builder mergeSpecifics(org.chromium.components.sync.protocol.EntitySpecifics value) {
      copyOnWrite();
      instance.mergeSpecifics(value);
      return this;
    }
    /**
     * <pre>
     * Extensible container for datatype-specific data.
     * This became available in version 23 of the protocol.
     * </pre>
     *
     * <code>optional .sync_pb.EntitySpecifics specifics = 21;</code>
     */
    public Builder clearSpecifics() {  copyOnWrite();
      instance.clearSpecifics();
      return this;
    }

    /**
     * <pre>
     * Indicate whether this is a folder or not. Available in version 23+.
     * </pre>
     *
     * <code>optional bool folder = 22 [default = false];</code>
     */
    public boolean hasFolder() {
      return instance.hasFolder();
    }
    /**
     * <pre>
     * Indicate whether this is a folder or not. Available in version 23+.
     * </pre>
     *
     * <code>optional bool folder = 22 [default = false];</code>
     */
    public boolean getFolder() {
      return instance.getFolder();
    }
    /**
     * <pre>
     * Indicate whether this is a folder or not. Available in version 23+.
     * </pre>
     *
     * <code>optional bool folder = 22 [default = false];</code>
     */
    public Builder setFolder(boolean value) {
      copyOnWrite();
      instance.setFolder(value);
      return this;
    }
    /**
     * <pre>
     * Indicate whether this is a folder or not. Available in version 23+.
     * </pre>
     *
     * <code>optional bool folder = 22 [default = false];</code>
     */
    public Builder clearFolder() {
      copyOnWrite();
      instance.clearFolder();
      return this;
    }

    /**
     * <pre>
     * A client defined unique hash for this entity.
     * Similar to server_defined_unique_tag.
     * When initially committing an entity, a client can request that the entity
     * is unique per that account. To do so, the client should specify a
     * client_defined_unique_tag. At most one entity per tag value may exist.
     * per account. The server will enforce uniqueness on this tag
     * and fail attempts to create duplicates of this tag.
     * Will be returned in any updates for this entity.
     * The difference between server_defined_unique_tag and
     * client_defined_unique_tag is the creator of the entity. Server defined
     * tags are entities created by the server at account creation,
     * while client defined tags are entities created by the client at any time.
     * During GetUpdates, a sync entity update will come back with ONE of:
     * a) Originator and cache id - If client committed the item as non "unique"
     * b) Server tag - If server committed the item as unique
     * c) Client tag - If client committed the item as unique
     * May be present in CommitMessages for the initial creation of an entity.
     * If present in Commit updates for the entity, it will be ignored.
     * Available in version 24+.
     * May be returned in GetUpdatesMessage and sent up in CommitMessage.
     * </pre>
     *
     * <code>optional string client_defined_unique_tag = 23;</code>
     */
    public boolean hasClientDefinedUniqueTag() {
      return instance.hasClientDefinedUniqueTag();
    }
    /**
     * <pre>
     * A client defined unique hash for this entity.
     * Similar to server_defined_unique_tag.
     * When initially committing an entity, a client can request that the entity
     * is unique per that account. To do so, the client should specify a
     * client_defined_unique_tag. At most one entity per tag value may exist.
     * per account. The server will enforce uniqueness on this tag
     * and fail attempts to create duplicates of this tag.
     * Will be returned in any updates for this entity.
     * The difference between server_defined_unique_tag and
     * client_defined_unique_tag is the creator of the entity. Server defined
     * tags are entities created by the server at account creation,
     * while client defined tags are entities created by the client at any time.
     * During GetUpdates, a sync entity update will come back with ONE of:
     * a) Originator and cache id - If client committed the item as non "unique"
     * b) Server tag - If server committed the item as unique
     * c) Client tag - If client committed the item as unique
     * May be present in CommitMessages for the initial creation of an entity.
     * If present in Commit updates for the entity, it will be ignored.
     * Available in version 24+.
     * May be returned in GetUpdatesMessage and sent up in CommitMessage.
     * </pre>
     *
     * <code>optional string client_defined_unique_tag = 23;</code>
     */
    public java.lang.String getClientDefinedUniqueTag() {
      return instance.getClientDefinedUniqueTag();
    }
    /**
     * <pre>
     * A client defined unique hash for this entity.
     * Similar to server_defined_unique_tag.
     * When initially committing an entity, a client can request that the entity
     * is unique per that account. To do so, the client should specify a
     * client_defined_unique_tag. At most one entity per tag value may exist.
     * per account. The server will enforce uniqueness on this tag
     * and fail attempts to create duplicates of this tag.
     * Will be returned in any updates for this entity.
     * The difference between server_defined_unique_tag and
     * client_defined_unique_tag is the creator of the entity. Server defined
     * tags are entities created by the server at account creation,
     * while client defined tags are entities created by the client at any time.
     * During GetUpdates, a sync entity update will come back with ONE of:
     * a) Originator and cache id - If client committed the item as non "unique"
     * b) Server tag - If server committed the item as unique
     * c) Client tag - If client committed the item as unique
     * May be present in CommitMessages for the initial creation of an entity.
     * If present in Commit updates for the entity, it will be ignored.
     * Available in version 24+.
     * May be returned in GetUpdatesMessage and sent up in CommitMessage.
     * </pre>
     *
     * <code>optional string client_defined_unique_tag = 23;</code>
     */
    public com.google.protobuf.ByteString
        getClientDefinedUniqueTagBytes() {
      return instance.getClientDefinedUniqueTagBytes();
    }
    /**
     * <pre>
     * A client defined unique hash for this entity.
     * Similar to server_defined_unique_tag.
     * When initially committing an entity, a client can request that the entity
     * is unique per that account. To do so, the client should specify a
     * client_defined_unique_tag. At most one entity per tag value may exist.
     * per account. The server will enforce uniqueness on this tag
     * and fail attempts to create duplicates of this tag.
     * Will be returned in any updates for this entity.
     * The difference between server_defined_unique_tag and
     * client_defined_unique_tag is the creator of the entity. Server defined
     * tags are entities created by the server at account creation,
     * while client defined tags are entities created by the client at any time.
     * During GetUpdates, a sync entity update will come back with ONE of:
     * a) Originator and cache id - If client committed the item as non "unique"
     * b) Server tag - If server committed the item as unique
     * c) Client tag - If client committed the item as unique
     * May be present in CommitMessages for the initial creation of an entity.
     * If present in Commit updates for the entity, it will be ignored.
     * Available in version 24+.
     * May be returned in GetUpdatesMessage and sent up in CommitMessage.
     * </pre>
     *
     * <code>optional string client_defined_unique_tag = 23;</code>
     */
    public Builder setClientDefinedUniqueTag(
        java.lang.String value) {
      copyOnWrite();
      instance.setClientDefinedUniqueTag(value);
      return this;
    }
    /**
     * <pre>
     * A client defined unique hash for this entity.
     * Similar to server_defined_unique_tag.
     * When initially committing an entity, a client can request that the entity
     * is unique per that account. To do so, the client should specify a
     * client_defined_unique_tag. At most one entity per tag value may exist.
     * per account. The server will enforce uniqueness on this tag
     * and fail attempts to create duplicates of this tag.
     * Will be returned in any updates for this entity.
     * The difference between server_defined_unique_tag and
     * client_defined_unique_tag is the creator of the entity. Server defined
     * tags are entities created by the server at account creation,
     * while client defined tags are entities created by the client at any time.
     * During GetUpdates, a sync entity update will come back with ONE of:
     * a) Originator and cache id - If client committed the item as non "unique"
     * b) Server tag - If server committed the item as unique
     * c) Client tag - If client committed the item as unique
     * May be present in CommitMessages for the initial creation of an entity.
     * If present in Commit updates for the entity, it will be ignored.
     * Available in version 24+.
     * May be returned in GetUpdatesMessage and sent up in CommitMessage.
     * </pre>
     *
     * <code>optional string client_defined_unique_tag = 23;</code>
     */
    public Builder clearClientDefinedUniqueTag() {
      copyOnWrite();
      instance.clearClientDefinedUniqueTag();
      return this;
    }
    /**
     * <pre>
     * A client defined unique hash for this entity.
     * Similar to server_defined_unique_tag.
     * When initially committing an entity, a client can request that the entity
     * is unique per that account. To do so, the client should specify a
     * client_defined_unique_tag. At most one entity per tag value may exist.
     * per account. The server will enforce uniqueness on this tag
     * and fail attempts to create duplicates of this tag.
     * Will be returned in any updates for this entity.
     * The difference between server_defined_unique_tag and
     * client_defined_unique_tag is the creator of the entity. Server defined
     * tags are entities created by the server at account creation,
     * while client defined tags are entities created by the client at any time.
     * During GetUpdates, a sync entity update will come back with ONE of:
     * a) Originator and cache id - If client committed the item as non "unique"
     * b) Server tag - If server committed the item as unique
     * c) Client tag - If client committed the item as unique
     * May be present in CommitMessages for the initial creation of an entity.
     * If present in Commit updates for the entity, it will be ignored.
     * Available in version 24+.
     * May be returned in GetUpdatesMessage and sent up in CommitMessage.
     * </pre>
     *
     * <code>optional string client_defined_unique_tag = 23;</code>
     */
    public Builder setClientDefinedUniqueTagBytes(
        com.google.protobuf.ByteString value) {
      copyOnWrite();
      instance.setClientDefinedUniqueTagBytes(value);
      return this;
    }

    /**
     * <pre>
     * This positioning system had a relatively short life.  It was made obsolete
     * by |unique_position| before either the client or server made much of an
     * attempt to support it.  In fact, no client ever read or set this field.
     * Deprecated in M26.
     * </pre>
     *
     * <code>optional bytes ordinal_in_parent = 24 [deprecated = true];</code>
     */
    @java.lang.Deprecated public boolean hasOrdinalInParent() {
      return instance.hasOrdinalInParent();
    }
    /**
     * <pre>
     * This positioning system had a relatively short life.  It was made obsolete
     * by |unique_position| before either the client or server made much of an
     * attempt to support it.  In fact, no client ever read or set this field.
     * Deprecated in M26.
     * </pre>
     *
     * <code>optional bytes ordinal_in_parent = 24 [deprecated = true];</code>
     */
    @java.lang.Deprecated public com.google.protobuf.ByteString getOrdinalInParent() {
      return instance.getOrdinalInParent();
    }
    /**
     * <pre>
     * This positioning system had a relatively short life.  It was made obsolete
     * by |unique_position| before either the client or server made much of an
     * attempt to support it.  In fact, no client ever read or set this field.
     * Deprecated in M26.
     * </pre>
     *
     * <code>optional bytes ordinal_in_parent = 24 [deprecated = true];</code>
     */
    @java.lang.Deprecated public Builder setOrdinalInParent(com.google.protobuf.ByteString value) {
      copyOnWrite();
      instance.setOrdinalInParent(value);
      return this;
    }
    /**
     * <pre>
     * This positioning system had a relatively short life.  It was made obsolete
     * by |unique_position| before either the client or server made much of an
     * attempt to support it.  In fact, no client ever read or set this field.
     * Deprecated in M26.
     * </pre>
     *
     * <code>optional bytes ordinal_in_parent = 24 [deprecated = true];</code>
     */
    @java.lang.Deprecated public Builder clearOrdinalInParent() {
      copyOnWrite();
      instance.clearOrdinalInParent();
      return this;
    }

    /**
     * <pre>
     * This is the fourth attempt at positioning.
     * This field is present in both GetUpdatesResponse and CommitMessage, if the
     * item's type requires it and the client that wrote the item supports it (M26
     * or higher).  Clients must also be prepared to handle updates from clients
     * that do not set this field.
     * This field will not be set for items whose type ignores positioning.
     * Clients should not attempt to read this field on the receipt of an item of
     * a type that ignores positioning.
     * Refer to its definition in unique_position.proto for more information about
     * its internal representation.
     * </pre>
     *
     * <code>optional .sync_pb.UniquePosition unique_position = 25;</code>
     */
    public boolean hasUniquePosition() {
      return instance.hasUniquePosition();
    }
    /**
     * <pre>
     * This is the fourth attempt at positioning.
     * This field is present in both GetUpdatesResponse and CommitMessage, if the
     * item's type requires it and the client that wrote the item supports it (M26
     * or higher).  Clients must also be prepared to handle updates from clients
     * that do not set this field.
     * This field will not be set for items whose type ignores positioning.
     * Clients should not attempt to read this field on the receipt of an item of
     * a type that ignores positioning.
     * Refer to its definition in unique_position.proto for more information about
     * its internal representation.
     * </pre>
     *
     * <code>optional .sync_pb.UniquePosition unique_position = 25;</code>
     */
    public org.chromium.components.sync.protocol.UniquePosition getUniquePosition() {
      return instance.getUniquePosition();
    }
    /**
     * <pre>
     * This is the fourth attempt at positioning.
     * This field is present in both GetUpdatesResponse and CommitMessage, if the
     * item's type requires it and the client that wrote the item supports it (M26
     * or higher).  Clients must also be prepared to handle updates from clients
     * that do not set this field.
     * This field will not be set for items whose type ignores positioning.
     * Clients should not attempt to read this field on the receipt of an item of
     * a type that ignores positioning.
     * Refer to its definition in unique_position.proto for more information about
     * its internal representation.
     * </pre>
     *
     * <code>optional .sync_pb.UniquePosition unique_position = 25;</code>
     */
    public Builder setUniquePosition(org.chromium.components.sync.protocol.UniquePosition value) {
      copyOnWrite();
      instance.setUniquePosition(value);
      return this;
      }
    /**
     * <pre>
     * This is the fourth attempt at positioning.
     * This field is present in both GetUpdatesResponse and CommitMessage, if the
     * item's type requires it and the client that wrote the item supports it (M26
     * or higher).  Clients must also be prepared to handle updates from clients
     * that do not set this field.
     * This field will not be set for items whose type ignores positioning.
     * Clients should not attempt to read this field on the receipt of an item of
     * a type that ignores positioning.
     * Refer to its definition in unique_position.proto for more information about
     * its internal representation.
     * </pre>
     *
     * <code>optional .sync_pb.UniquePosition unique_position = 25;</code>
     */
    public Builder setUniquePosition(
        org.chromium.components.sync.protocol.UniquePosition.Builder builderForValue) {
      copyOnWrite();
      instance.setUniquePosition(builderForValue);
      return this;
    }
    /**
     * <pre>
     * This is the fourth attempt at positioning.
     * This field is present in both GetUpdatesResponse and CommitMessage, if the
     * item's type requires it and the client that wrote the item supports it (M26
     * or higher).  Clients must also be prepared to handle updates from clients
     * that do not set this field.
     * This field will not be set for items whose type ignores positioning.
     * Clients should not attempt to read this field on the receipt of an item of
     * a type that ignores positioning.
     * Refer to its definition in unique_position.proto for more information about
     * its internal representation.
     * </pre>
     *
     * <code>optional .sync_pb.UniquePosition unique_position = 25;</code>
     */
    public Builder mergeUniquePosition(org.chromium.components.sync.protocol.UniquePosition value) {
      copyOnWrite();
      instance.mergeUniquePosition(value);
      return this;
    }
    /**
     * <pre>
     * This is the fourth attempt at positioning.
     * This field is present in both GetUpdatesResponse and CommitMessage, if the
     * item's type requires it and the client that wrote the item supports it (M26
     * or higher).  Clients must also be prepared to handle updates from clients
     * that do not set this field.
     * This field will not be set for items whose type ignores positioning.
     * Clients should not attempt to read this field on the receipt of an item of
     * a type that ignores positioning.
     * Refer to its definition in unique_position.proto for more information about
     * its internal representation.
     * </pre>
     *
     * <code>optional .sync_pb.UniquePosition unique_position = 25;</code>
     */
    public Builder clearUniquePosition() {  copyOnWrite();
      instance.clearUniquePosition();
      return this;
    }

    // @@protoc_insertion_point(builder_scope:sync_pb.SyncEntity)
  }
  protected final Object dynamicMethod(
      com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
      Object arg0, Object arg1) {
    switch (method) {
      case NEW_MUTABLE_INSTANCE: {
        return new org.chromium.components.sync.protocol.SyncEntity();
      }
      case IS_INITIALIZED: {
        return DEFAULT_INSTANCE;
      }
      case MAKE_IMMUTABLE: {
        return null;
      }
      case NEW_BUILDER: {
        return new Builder();
      }
      case VISIT: {
        Visitor visitor = (Visitor) arg0;
        org.chromium.components.sync.protocol.SyncEntity other = (org.chromium.components.sync.protocol.SyncEntity) arg1;
        idString_ = visitor.visitString(
            hasIdString(), idString_,
            other.hasIdString(), other.idString_);
        parentIdString_ = visitor.visitString(
            hasParentIdString(), parentIdString_,
            other.hasParentIdString(), other.parentIdString_);
        oldParentId_ = visitor.visitString(
            hasOldParentId(), oldParentId_,
            other.hasOldParentId(), other.oldParentId_);
        version_ = visitor.visitLong(
            hasVersion(), version_,
            other.hasVersion(), other.version_);
        mtime_ = visitor.visitLong(
            hasMtime(), mtime_,
            other.hasMtime(), other.mtime_);
        ctime_ = visitor.visitLong(
            hasCtime(), ctime_,
            other.hasCtime(), other.ctime_);
        name_ = visitor.visitString(
            hasName(), name_,
            other.hasName(), other.name_);
        nonUniqueName_ = visitor.visitString(
            hasNonUniqueName(), nonUniqueName_,
            other.hasNonUniqueName(), other.nonUniqueName_);
        serverDefinedUniqueTag_ = visitor.visitString(
            hasServerDefinedUniqueTag(), serverDefinedUniqueTag_,
            other.hasServerDefinedUniqueTag(), other.serverDefinedUniqueTag_);
        positionInParent_ = visitor.visitLong(
            hasPositionInParent(), positionInParent_,
            other.hasPositionInParent(), other.positionInParent_);
        insertAfterItemId_ = visitor.visitString(
            hasInsertAfterItemId(), insertAfterItemId_,
            other.hasInsertAfterItemId(), other.insertAfterItemId_);
        deleted_ = visitor.visitBoolean(
            hasDeleted(), deleted_,
            other.hasDeleted(), other.deleted_);
        originatorCacheGuid_ = visitor.visitString(
            hasOriginatorCacheGuid(), originatorCacheGuid_,
            other.hasOriginatorCacheGuid(), other.originatorCacheGuid_);
        originatorClientItemId_ = visitor.visitString(
            hasOriginatorClientItemId(), originatorClientItemId_,
            other.hasOriginatorClientItemId(), other.originatorClientItemId_);
        specifics_ = visitor.visitMessage(specifics_, other.specifics_);
        folder_ = visitor.visitBoolean(
            hasFolder(), folder_,
            other.hasFolder(), other.folder_);
        clientDefinedUniqueTag_ = visitor.visitString(
            hasClientDefinedUniqueTag(), clientDefinedUniqueTag_,
            other.hasClientDefinedUniqueTag(), other.clientDefinedUniqueTag_);
        ordinalInParent_ = visitor.visitByteString(
            hasOrdinalInParent(), ordinalInParent_,
            other.hasOrdinalInParent(), other.ordinalInParent_);
        uniquePosition_ = visitor.visitMessage(uniquePosition_, other.uniquePosition_);
        if (visitor == com.google.protobuf.GeneratedMessageLite.MergeFromVisitor
            .INSTANCE) {
          bitField0_ |= other.bitField0_;
        }
        return this;
      }
      case MERGE_FROM_STREAM: {
        com.google.protobuf.CodedInputStream input =
            (com.google.protobuf.CodedInputStream) arg0;
        com.google.protobuf.ExtensionRegistryLite extensionRegistry =
            (com.google.protobuf.ExtensionRegistryLite) arg1;
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              default: {
                if (!parseUnknownField(tag, input)) {
                  done = true;
                }
                break;
              }
              case 10: {
                String s = input.readString();
                bitField0_ |= 0x00000001;
                idString_ = s;
                break;
              }
              case 18: {
                String s = input.readString();
                bitField0_ |= 0x00000002;
                parentIdString_ = s;
                break;
              }
              case 26: {
                String s = input.readString();
                bitField0_ |= 0x00000004;
                oldParentId_ = s;
                break;
              }
              case 32: {
                bitField0_ |= 0x00000008;
                version_ = input.readInt64();
                break;
              }
              case 40: {
                bitField0_ |= 0x00000010;
                mtime_ = input.readInt64();
                break;
              }
              case 48: {
                bitField0_ |= 0x00000020;
                ctime_ = input.readInt64();
                break;
              }
              case 58: {
                String s = input.readString();
                bitField0_ |= 0x00000040;
                name_ = s;
                break;
              }
              case 66: {
                String s = input.readString();
                bitField0_ |= 0x00000080;
                nonUniqueName_ = s;
                break;
              }
              case 82: {
                String s = input.readString();
                bitField0_ |= 0x00000100;
                serverDefinedUniqueTag_ = s;
                break;
              }
              case 120: {
                bitField0_ |= 0x00000200;
                positionInParent_ = input.readInt64();
                break;
              }
              case 130: {
                String s = input.readString();
                bitField0_ |= 0x00000400;
                insertAfterItemId_ = s;
                break;
              }
              case 144: {
                bitField0_ |= 0x00000800;
                deleted_ = input.readBool();
                break;
              }
              case 154: {
                String s = input.readString();
                bitField0_ |= 0x00001000;
                originatorCacheGuid_ = s;
                break;
              }
              case 162: {
                String s = input.readString();
                bitField0_ |= 0x00002000;
                originatorClientItemId_ = s;
                break;
              }
              case 170: {
                org.chromium.components.sync.protocol.EntitySpecifics.Builder subBuilder = null;
                if (((bitField0_ & 0x00004000) == 0x00004000)) {
                  subBuilder = specifics_.toBuilder();
                }
                specifics_ = input.readMessage(org.chromium.components.sync.protocol.EntitySpecifics.parser(), extensionRegistry);
                if (subBuilder != null) {
                  subBuilder.mergeFrom(specifics_);
                  specifics_ = subBuilder.buildPartial();
                }
                bitField0_ |= 0x00004000;
                break;
              }
              case 176: {
                bitField0_ |= 0x00008000;
                folder_ = input.readBool();
                break;
              }
              case 186: {
                String s = input.readString();
                bitField0_ |= 0x00010000;
                clientDefinedUniqueTag_ = s;
                break;
              }
              case 194: {
                bitField0_ |= 0x00020000;
                ordinalInParent_ = input.readBytes();
                break;
              }
              case 202: {
                org.chromium.components.sync.protocol.UniquePosition.Builder subBuilder = null;
                if (((bitField0_ & 0x00040000) == 0x00040000)) {
                  subBuilder = uniquePosition_.toBuilder();
                }
                uniquePosition_ = input.readMessage(org.chromium.components.sync.protocol.UniquePosition.parser(), extensionRegistry);
                if (subBuilder != null) {
                  subBuilder.mergeFrom(uniquePosition_);
                  uniquePosition_ = subBuilder.buildPartial();
                }
                bitField0_ |= 0x00040000;
                break;
              }
            }
          }
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw new RuntimeException(e.setUnfinishedMessage(this));
        } catch (java.io.IOException e) {
          throw new RuntimeException(
              new com.google.protobuf.InvalidProtocolBufferException(
                  e.getMessage()).setUnfinishedMessage(this));
        } finally {
        }
      }
      case GET_DEFAULT_INSTANCE: {
        return DEFAULT_INSTANCE;
      }
      case GET_PARSER: {
        if (PARSER == null) {    synchronized (org.chromium.components.sync.protocol.SyncEntity.class) {
            if (PARSER == null) {
              PARSER = new DefaultInstanceBasedParser(DEFAULT_INSTANCE);
            }
          }
        }
        return PARSER;
      }
    }
    throw new UnsupportedOperationException();
  }


  // @@protoc_insertion_point(class_scope:sync_pb.SyncEntity)
  private static final org.chromium.components.sync.protocol.SyncEntity DEFAULT_INSTANCE;
  static {
    DEFAULT_INSTANCE = new SyncEntity();
    DEFAULT_INSTANCE.makeImmutable();
  }

  public static org.chromium.components.sync.protocol.SyncEntity getDefaultInstance() {
    return DEFAULT_INSTANCE;
  }

  private static volatile com.google.protobuf.Parser<SyncEntity> PARSER;

  public static com.google.protobuf.Parser<SyncEntity> parser() {
    return DEFAULT_INSTANCE.getParserForType();
  }
}

