// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: nigori_specifics.proto

package org.chromium.components.sync.protocol;

/**
 * <pre>
 * Properties of nigori sync object.
 * </pre>
 *
 * Protobuf type {@code sync_pb.NigoriSpecifics}
 */
public  final class NigoriSpecifics extends
    com.google.protobuf.GeneratedMessageLite<
        NigoriSpecifics, NigoriSpecifics.Builder> implements
    // @@protoc_insertion_point(message_implements:sync_pb.NigoriSpecifics)
    NigoriSpecificsOrBuilder {
  private NigoriSpecifics() {
    passphraseType_ = 1;
    customPassphraseKeyDerivationSalt_ = "";
  }
  /**
   * <pre>
   * The state of the passphrase required to decrypt |encryption_keybag|.
   * </pre>
   *
   * Protobuf enum {@code sync_pb.NigoriSpecifics.PassphraseType}
   */
  public enum PassphraseType
      implements com.google.protobuf.Internal.EnumLite {
    /**
     * <pre>
     * Proto enums should begin with an 'unknown' value for switch statements,
     * unknown fields, etc.
     * </pre>
     *
     * <code>UNKNOWN = 0;</code>
     */
    UNKNOWN(0),
    /**
     * <pre>
     * Gaia-based encryption passphrase. Deprecated.
     * </pre>
     *
     * <code>IMPLICIT_PASSPHRASE = 1;</code>
     */
    IMPLICIT_PASSPHRASE(1),
    /**
     * <pre>
     * Keystore key encryption passphrase. Uses |keystore_bootstrap| to
     * decrypt |encryption_keybag|.
     * </pre>
     *
     * <code>KEYSTORE_PASSPHRASE = 2;</code>
     */
    KEYSTORE_PASSPHRASE(2),
    /**
     * <pre>
     * Previous Gaia-based passphrase frozen and treated as a custom passphrase.
     * </pre>
     *
     * <code>FROZEN_IMPLICIT_PASSPHRASE = 3;</code>
     */
    FROZEN_IMPLICIT_PASSPHRASE(3),
    /**
     * <pre>
     * User provided custom passphrase.
     * </pre>
     *
     * <code>CUSTOM_PASSPHRASE = 4;</code>
     */
    CUSTOM_PASSPHRASE(4),
    /**
     * <pre>
     * Encryption key provided by a trusted vault.
     * </pre>
     *
     * <code>TRUSTED_VAULT_PASSPHRASE = 5;</code>
     */
    TRUSTED_VAULT_PASSPHRASE(5),
    ;

    /**
     * <pre>
     * Proto enums should begin with an 'unknown' value for switch statements,
     * unknown fields, etc.
     * </pre>
     *
     * <code>UNKNOWN = 0;</code>
     */
    public static final int UNKNOWN_VALUE = 0;
    /**
     * <pre>
     * Gaia-based encryption passphrase. Deprecated.
     * </pre>
     *
     * <code>IMPLICIT_PASSPHRASE = 1;</code>
     */
    public static final int IMPLICIT_PASSPHRASE_VALUE = 1;
    /**
     * <pre>
     * Keystore key encryption passphrase. Uses |keystore_bootstrap| to
     * decrypt |encryption_keybag|.
     * </pre>
     *
     * <code>KEYSTORE_PASSPHRASE = 2;</code>
     */
    public static final int KEYSTORE_PASSPHRASE_VALUE = 2;
    /**
     * <pre>
     * Previous Gaia-based passphrase frozen and treated as a custom passphrase.
     * </pre>
     *
     * <code>FROZEN_IMPLICIT_PASSPHRASE = 3;</code>
     */
    public static final int FROZEN_IMPLICIT_PASSPHRASE_VALUE = 3;
    /**
     * <pre>
     * User provided custom passphrase.
     * </pre>
     *
     * <code>CUSTOM_PASSPHRASE = 4;</code>
     */
    public static final int CUSTOM_PASSPHRASE_VALUE = 4;
    /**
     * <pre>
     * Encryption key provided by a trusted vault.
     * </pre>
     *
     * <code>TRUSTED_VAULT_PASSPHRASE = 5;</code>
     */
    public static final int TRUSTED_VAULT_PASSPHRASE_VALUE = 5;


    public final int getNumber() {
      return value;
    }

    /**
     * @deprecated Use {@link #forNumber(int)} instead.
     */
    @java.lang.Deprecated
    public static PassphraseType valueOf(int value) {
      return forNumber(value);
    }

    public static PassphraseType forNumber(int value) {
      switch (value) {
        case 0: return UNKNOWN;
        case 1: return IMPLICIT_PASSPHRASE;
        case 2: return KEYSTORE_PASSPHRASE;
        case 3: return FROZEN_IMPLICIT_PASSPHRASE;
        case 4: return CUSTOM_PASSPHRASE;
        case 5: return TRUSTED_VAULT_PASSPHRASE;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<PassphraseType>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static final com.google.protobuf.Internal.EnumLiteMap<
        PassphraseType> internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<PassphraseType>() {
            public PassphraseType findValueByNumber(int number) {
              return PassphraseType.forNumber(number);
            }
          };

    private final int value;

    private PassphraseType(int value) {
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:sync_pb.NigoriSpecifics.PassphraseType)
  }

  /**
   * Protobuf enum {@code sync_pb.NigoriSpecifics.KeyDerivationMethod}
   */
  public enum KeyDerivationMethod
      implements com.google.protobuf.Internal.EnumLite {
    /**
     * <pre>
     * This comes from a &lt;= M69 client, who does not know about the field
     * (but implicitly uses PBKDF2_HMAC_SHA1_1003).
     * </pre>
     *
     * <code>UNSPECIFIED = 0;</code>
     */
    UNSPECIFIED(0),
    /**
     * <pre>
     * PBKDF2-HMAC-SHA1 with 1003 iterations and constant hardcoded salt. Was
     * implicitly used in &lt;= M69.
     * </pre>
     *
     * <code>PBKDF2_HMAC_SHA1_1003 = 1;</code>
     */
    PBKDF2_HMAC_SHA1_1003(1),
    /**
     * <pre>
     * scrypt with N = 2^13, r = 8, p = 11 and random salt. Was added in M70.
     * </pre>
     *
     * <code>SCRYPT_8192_8_11 = 2;</code>
     */
    SCRYPT_8192_8_11(2),
    ;

    /**
     * <pre>
     * This comes from a &lt;= M69 client, who does not know about the field
     * (but implicitly uses PBKDF2_HMAC_SHA1_1003).
     * </pre>
     *
     * <code>UNSPECIFIED = 0;</code>
     */
    public static final int UNSPECIFIED_VALUE = 0;
    /**
     * <pre>
     * PBKDF2-HMAC-SHA1 with 1003 iterations and constant hardcoded salt. Was
     * implicitly used in &lt;= M69.
     * </pre>
     *
     * <code>PBKDF2_HMAC_SHA1_1003 = 1;</code>
     */
    public static final int PBKDF2_HMAC_SHA1_1003_VALUE = 1;
    /**
     * <pre>
     * scrypt with N = 2^13, r = 8, p = 11 and random salt. Was added in M70.
     * </pre>
     *
     * <code>SCRYPT_8192_8_11 = 2;</code>
     */
    public static final int SCRYPT_8192_8_11_VALUE = 2;


    public final int getNumber() {
      return value;
    }

    /**
     * @deprecated Use {@link #forNumber(int)} instead.
     */
    @java.lang.Deprecated
    public static KeyDerivationMethod valueOf(int value) {
      return forNumber(value);
    }

    public static KeyDerivationMethod forNumber(int value) {
      switch (value) {
        case 0: return UNSPECIFIED;
        case 1: return PBKDF2_HMAC_SHA1_1003;
        case 2: return SCRYPT_8192_8_11;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<KeyDerivationMethod>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static final com.google.protobuf.Internal.EnumLiteMap<
        KeyDerivationMethod> internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<KeyDerivationMethod>() {
            public KeyDerivationMethod findValueByNumber(int number) {
              return KeyDerivationMethod.forNumber(number);
            }
          };

    private final int value;

    private KeyDerivationMethod(int value) {
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:sync_pb.NigoriSpecifics.KeyDerivationMethod)
  }

  private int bitField0_;
  private int bitField1_;
  public static final int ENCRYPTION_KEYBAG_FIELD_NUMBER = 1;
  private org.chromium.components.sync.protocol.EncryptedData encryptionKeybag_;
  /**
   * <code>optional .sync_pb.EncryptedData encryption_keybag = 1;</code>
   */
  public boolean hasEncryptionKeybag() {
    return ((bitField0_ & 0x00000001) == 0x00000001);
  }
  /**
   * <code>optional .sync_pb.EncryptedData encryption_keybag = 1;</code>
   */
  public org.chromium.components.sync.protocol.EncryptedData getEncryptionKeybag() {
    return encryptionKeybag_ == null ? org.chromium.components.sync.protocol.EncryptedData.getDefaultInstance() : encryptionKeybag_;
  }
  /**
   * <code>optional .sync_pb.EncryptedData encryption_keybag = 1;</code>
   */
  private void setEncryptionKeybag(org.chromium.components.sync.protocol.EncryptedData value) {
    if (value == null) {
      throw new NullPointerException();
    }
    encryptionKeybag_ = value;
    bitField0_ |= 0x00000001;
    }
  /**
   * <code>optional .sync_pb.EncryptedData encryption_keybag = 1;</code>
   */
  private void setEncryptionKeybag(
      org.chromium.components.sync.protocol.EncryptedData.Builder builderForValue) {
    encryptionKeybag_ = builderForValue.build();
    bitField0_ |= 0x00000001;
  }
  /**
   * <code>optional .sync_pb.EncryptedData encryption_keybag = 1;</code>
   */
  private void mergeEncryptionKeybag(org.chromium.components.sync.protocol.EncryptedData value) {
    if (encryptionKeybag_ != null &&
        encryptionKeybag_ != org.chromium.components.sync.protocol.EncryptedData.getDefaultInstance()) {
      encryptionKeybag_ =
        org.chromium.components.sync.protocol.EncryptedData.newBuilder(encryptionKeybag_).mergeFrom(value).buildPartial();
    } else {
      encryptionKeybag_ = value;
    }
    bitField0_ |= 0x00000001;
  }
  /**
   * <code>optional .sync_pb.EncryptedData encryption_keybag = 1;</code>
   */
  private void clearEncryptionKeybag() {  encryptionKeybag_ = null;
    bitField0_ = (bitField0_ & ~0x00000001);
  }

  public static final int KEYBAG_IS_FROZEN_FIELD_NUMBER = 2;
  private boolean keybagIsFrozen_;
  /**
   * <pre>
   * Once keystore migration is performed, we have to freeze the keybag so that
   * older clients (that don't support keystore encryption) do not attempt to
   * update the keybag.
   * Previously |using_explicit_passphrase|.
   * </pre>
   *
   * <code>optional bool keybag_is_frozen = 2;</code>
   */
  public boolean hasKeybagIsFrozen() {
    return ((bitField0_ & 0x00000002) == 0x00000002);
  }
  /**
   * <pre>
   * Once keystore migration is performed, we have to freeze the keybag so that
   * older clients (that don't support keystore encryption) do not attempt to
   * update the keybag.
   * Previously |using_explicit_passphrase|.
   * </pre>
   *
   * <code>optional bool keybag_is_frozen = 2;</code>
   */
  public boolean getKeybagIsFrozen() {
    return keybagIsFrozen_;
  }
  /**
   * <pre>
   * Once keystore migration is performed, we have to freeze the keybag so that
   * older clients (that don't support keystore encryption) do not attempt to
   * update the keybag.
   * Previously |using_explicit_passphrase|.
   * </pre>
   *
   * <code>optional bool keybag_is_frozen = 2;</code>
   */
  private void setKeybagIsFrozen(boolean value) {
    bitField0_ |= 0x00000002;
    keybagIsFrozen_ = value;
  }
  /**
   * <pre>
   * Once keystore migration is performed, we have to freeze the keybag so that
   * older clients (that don't support keystore encryption) do not attempt to
   * update the keybag.
   * Previously |using_explicit_passphrase|.
   * </pre>
   *
   * <code>optional bool keybag_is_frozen = 2;</code>
   */
  private void clearKeybagIsFrozen() {
    bitField0_ = (bitField0_ & ~0x00000002);
    keybagIsFrozen_ = false;
  }

  public static final int ENCRYPT_BOOKMARKS_FIELD_NUMBER = 13;
  private boolean encryptBookmarks_;
  /**
   * <pre>
   * Booleans corresponding to whether a datatype should be encrypted.
   * Passwords and Wi-Fi configurations are always encrypted, so we don't need
   * a field here.  History delete directives need to be consumable by the
   * server, and thus can't be encrypted.
   * </pre>
   *
   * <code>optional bool encrypt_bookmarks = 13;</code>
   */
  public boolean hasEncryptBookmarks() {
    return ((bitField0_ & 0x00000004) == 0x00000004);
  }
  /**
   * <pre>
   * Booleans corresponding to whether a datatype should be encrypted.
   * Passwords and Wi-Fi configurations are always encrypted, so we don't need
   * a field here.  History delete directives need to be consumable by the
   * server, and thus can't be encrypted.
   * </pre>
   *
   * <code>optional bool encrypt_bookmarks = 13;</code>
   */
  public boolean getEncryptBookmarks() {
    return encryptBookmarks_;
  }
  /**
   * <pre>
   * Booleans corresponding to whether a datatype should be encrypted.
   * Passwords and Wi-Fi configurations are always encrypted, so we don't need
   * a field here.  History delete directives need to be consumable by the
   * server, and thus can't be encrypted.
   * </pre>
   *
   * <code>optional bool encrypt_bookmarks = 13;</code>
   */
  private void setEncryptBookmarks(boolean value) {
    bitField0_ |= 0x00000004;
    encryptBookmarks_ = value;
  }
  /**
   * <pre>
   * Booleans corresponding to whether a datatype should be encrypted.
   * Passwords and Wi-Fi configurations are always encrypted, so we don't need
   * a field here.  History delete directives need to be consumable by the
   * server, and thus can't be encrypted.
   * </pre>
   *
   * <code>optional bool encrypt_bookmarks = 13;</code>
   */
  private void clearEncryptBookmarks() {
    bitField0_ = (bitField0_ & ~0x00000004);
    encryptBookmarks_ = false;
  }

  public static final int ENCRYPT_PREFERENCES_FIELD_NUMBER = 14;
  private boolean encryptPreferences_;
  /**
   * <code>optional bool encrypt_preferences = 14;</code>
   */
  public boolean hasEncryptPreferences() {
    return ((bitField0_ & 0x00000008) == 0x00000008);
  }
  /**
   * <code>optional bool encrypt_preferences = 14;</code>
   */
  public boolean getEncryptPreferences() {
    return encryptPreferences_;
  }
  /**
   * <code>optional bool encrypt_preferences = 14;</code>
   */
  private void setEncryptPreferences(boolean value) {
    bitField0_ |= 0x00000008;
    encryptPreferences_ = value;
  }
  /**
   * <code>optional bool encrypt_preferences = 14;</code>
   */
  private void clearEncryptPreferences() {
    bitField0_ = (bitField0_ & ~0x00000008);
    encryptPreferences_ = false;
  }

  public static final int ENCRYPT_AUTOFILL_PROFILE_FIELD_NUMBER = 15;
  private boolean encryptAutofillProfile_;
  /**
   * <code>optional bool encrypt_autofill_profile = 15;</code>
   */
  public boolean hasEncryptAutofillProfile() {
    return ((bitField0_ & 0x00000010) == 0x00000010);
  }
  /**
   * <code>optional bool encrypt_autofill_profile = 15;</code>
   */
  public boolean getEncryptAutofillProfile() {
    return encryptAutofillProfile_;
  }
  /**
   * <code>optional bool encrypt_autofill_profile = 15;</code>
   */
  private void setEncryptAutofillProfile(boolean value) {
    bitField0_ |= 0x00000010;
    encryptAutofillProfile_ = value;
  }
  /**
   * <code>optional bool encrypt_autofill_profile = 15;</code>
   */
  private void clearEncryptAutofillProfile() {
    bitField0_ = (bitField0_ & ~0x00000010);
    encryptAutofillProfile_ = false;
  }

  public static final int ENCRYPT_AUTOFILL_FIELD_NUMBER = 16;
  private boolean encryptAutofill_;
  /**
   * <code>optional bool encrypt_autofill = 16;</code>
   */
  public boolean hasEncryptAutofill() {
    return ((bitField0_ & 0x00000020) == 0x00000020);
  }
  /**
   * <code>optional bool encrypt_autofill = 16;</code>
   */
  public boolean getEncryptAutofill() {
    return encryptAutofill_;
  }
  /**
   * <code>optional bool encrypt_autofill = 16;</code>
   */
  private void setEncryptAutofill(boolean value) {
    bitField0_ |= 0x00000020;
    encryptAutofill_ = value;
  }
  /**
   * <code>optional bool encrypt_autofill = 16;</code>
   */
  private void clearEncryptAutofill() {
    bitField0_ = (bitField0_ & ~0x00000020);
    encryptAutofill_ = false;
  }

  public static final int ENCRYPT_THEMES_FIELD_NUMBER = 17;
  private boolean encryptThemes_;
  /**
   * <code>optional bool encrypt_themes = 17;</code>
   */
  public boolean hasEncryptThemes() {
    return ((bitField0_ & 0x00000040) == 0x00000040);
  }
  /**
   * <code>optional bool encrypt_themes = 17;</code>
   */
  public boolean getEncryptThemes() {
    return encryptThemes_;
  }
  /**
   * <code>optional bool encrypt_themes = 17;</code>
   */
  private void setEncryptThemes(boolean value) {
    bitField0_ |= 0x00000040;
    encryptThemes_ = value;
  }
  /**
   * <code>optional bool encrypt_themes = 17;</code>
   */
  private void clearEncryptThemes() {
    bitField0_ = (bitField0_ & ~0x00000040);
    encryptThemes_ = false;
  }

  public static final int ENCRYPT_TYPED_URLS_FIELD_NUMBER = 18;
  private boolean encryptTypedUrls_;
  /**
   * <code>optional bool encrypt_typed_urls = 18;</code>
   */
  public boolean hasEncryptTypedUrls() {
    return ((bitField0_ & 0x00000080) == 0x00000080);
  }
  /**
   * <code>optional bool encrypt_typed_urls = 18;</code>
   */
  public boolean getEncryptTypedUrls() {
    return encryptTypedUrls_;
  }
  /**
   * <code>optional bool encrypt_typed_urls = 18;</code>
   */
  private void setEncryptTypedUrls(boolean value) {
    bitField0_ |= 0x00000080;
    encryptTypedUrls_ = value;
  }
  /**
   * <code>optional bool encrypt_typed_urls = 18;</code>
   */
  private void clearEncryptTypedUrls() {
    bitField0_ = (bitField0_ & ~0x00000080);
    encryptTypedUrls_ = false;
  }

  public static final int ENCRYPT_EXTENSIONS_FIELD_NUMBER = 19;
  private boolean encryptExtensions_;
  /**
   * <code>optional bool encrypt_extensions = 19;</code>
   */
  public boolean hasEncryptExtensions() {
    return ((bitField0_ & 0x00000100) == 0x00000100);
  }
  /**
   * <code>optional bool encrypt_extensions = 19;</code>
   */
  public boolean getEncryptExtensions() {
    return encryptExtensions_;
  }
  /**
   * <code>optional bool encrypt_extensions = 19;</code>
   */
  private void setEncryptExtensions(boolean value) {
    bitField0_ |= 0x00000100;
    encryptExtensions_ = value;
  }
  /**
   * <code>optional bool encrypt_extensions = 19;</code>
   */
  private void clearEncryptExtensions() {
    bitField0_ = (bitField0_ & ~0x00000100);
    encryptExtensions_ = false;
  }

  public static final int ENCRYPT_SESSIONS_FIELD_NUMBER = 20;
  private boolean encryptSessions_;
  /**
   * <code>optional bool encrypt_sessions = 20;</code>
   */
  public boolean hasEncryptSessions() {
    return ((bitField0_ & 0x00000200) == 0x00000200);
  }
  /**
   * <code>optional bool encrypt_sessions = 20;</code>
   */
  public boolean getEncryptSessions() {
    return encryptSessions_;
  }
  /**
   * <code>optional bool encrypt_sessions = 20;</code>
   */
  private void setEncryptSessions(boolean value) {
    bitField0_ |= 0x00000200;
    encryptSessions_ = value;
  }
  /**
   * <code>optional bool encrypt_sessions = 20;</code>
   */
  private void clearEncryptSessions() {
    bitField0_ = (bitField0_ & ~0x00000200);
    encryptSessions_ = false;
  }

  public static final int ENCRYPT_APPS_FIELD_NUMBER = 21;
  private boolean encryptApps_;
  /**
   * <code>optional bool encrypt_apps = 21;</code>
   */
  public boolean hasEncryptApps() {
    return ((bitField0_ & 0x00000400) == 0x00000400);
  }
  /**
   * <code>optional bool encrypt_apps = 21;</code>
   */
  public boolean getEncryptApps() {
    return encryptApps_;
  }
  /**
   * <code>optional bool encrypt_apps = 21;</code>
   */
  private void setEncryptApps(boolean value) {
    bitField0_ |= 0x00000400;
    encryptApps_ = value;
  }
  /**
   * <code>optional bool encrypt_apps = 21;</code>
   */
  private void clearEncryptApps() {
    bitField0_ = (bitField0_ & ~0x00000400);
    encryptApps_ = false;
  }

  public static final int ENCRYPT_SEARCH_ENGINES_FIELD_NUMBER = 22;
  private boolean encryptSearchEngines_;
  /**
   * <code>optional bool encrypt_search_engines = 22;</code>
   */
  public boolean hasEncryptSearchEngines() {
    return ((bitField0_ & 0x00000800) == 0x00000800);
  }
  /**
   * <code>optional bool encrypt_search_engines = 22;</code>
   */
  public boolean getEncryptSearchEngines() {
    return encryptSearchEngines_;
  }
  /**
   * <code>optional bool encrypt_search_engines = 22;</code>
   */
  private void setEncryptSearchEngines(boolean value) {
    bitField0_ |= 0x00000800;
    encryptSearchEngines_ = value;
  }
  /**
   * <code>optional bool encrypt_search_engines = 22;</code>
   */
  private void clearEncryptSearchEngines() {
    bitField0_ = (bitField0_ & ~0x00000800);
    encryptSearchEngines_ = false;
  }

  public static final int ENCRYPT_EVERYTHING_FIELD_NUMBER = 24;
  private boolean encryptEverything_;
  /**
   * <pre>
   * If true, all current and future datatypes will be encrypted.
   * </pre>
   *
   * <code>optional bool encrypt_everything = 24;</code>
   */
  public boolean hasEncryptEverything() {
    return ((bitField0_ & 0x00001000) == 0x00001000);
  }
  /**
   * <pre>
   * If true, all current and future datatypes will be encrypted.
   * </pre>
   *
   * <code>optional bool encrypt_everything = 24;</code>
   */
  public boolean getEncryptEverything() {
    return encryptEverything_;
  }
  /**
   * <pre>
   * If true, all current and future datatypes will be encrypted.
   * </pre>
   *
   * <code>optional bool encrypt_everything = 24;</code>
   */
  private void setEncryptEverything(boolean value) {
    bitField0_ |= 0x00001000;
    encryptEverything_ = value;
  }
  /**
   * <pre>
   * If true, all current and future datatypes will be encrypted.
   * </pre>
   *
   * <code>optional bool encrypt_everything = 24;</code>
   */
  private void clearEncryptEverything() {
    bitField0_ = (bitField0_ & ~0x00001000);
    encryptEverything_ = false;
  }

  public static final int ENCRYPT_EXTENSION_SETTINGS_FIELD_NUMBER = 25;
  private boolean encryptExtensionSettings_;
  /**
   * <code>optional bool encrypt_extension_settings = 25;</code>
   */
  public boolean hasEncryptExtensionSettings() {
    return ((bitField0_ & 0x00002000) == 0x00002000);
  }
  /**
   * <code>optional bool encrypt_extension_settings = 25;</code>
   */
  public boolean getEncryptExtensionSettings() {
    return encryptExtensionSettings_;
  }
  /**
   * <code>optional bool encrypt_extension_settings = 25;</code>
   */
  private void setEncryptExtensionSettings(boolean value) {
    bitField0_ |= 0x00002000;
    encryptExtensionSettings_ = value;
  }
  /**
   * <code>optional bool encrypt_extension_settings = 25;</code>
   */
  private void clearEncryptExtensionSettings() {
    bitField0_ = (bitField0_ & ~0x00002000);
    encryptExtensionSettings_ = false;
  }

  public static final int ENCRYPT_APP_NOTIFICATIONS_FIELD_NUMBER = 26;
  private boolean encryptAppNotifications_;
  /**
   * <code>optional bool encrypt_app_notifications = 26 [deprecated = true];</code>
   */
  @java.lang.Deprecated public boolean hasEncryptAppNotifications() {
    return ((bitField0_ & 0x00004000) == 0x00004000);
  }
  /**
   * <code>optional bool encrypt_app_notifications = 26 [deprecated = true];</code>
   */
  @java.lang.Deprecated public boolean getEncryptAppNotifications() {
    return encryptAppNotifications_;
  }
  /**
   * <code>optional bool encrypt_app_notifications = 26 [deprecated = true];</code>
   */
  private void setEncryptAppNotifications(boolean value) {
    bitField0_ |= 0x00004000;
    encryptAppNotifications_ = value;
  }
  /**
   * <code>optional bool encrypt_app_notifications = 26 [deprecated = true];</code>
   */
  private void clearEncryptAppNotifications() {
    bitField0_ = (bitField0_ & ~0x00004000);
    encryptAppNotifications_ = false;
  }

  public static final int ENCRYPT_APP_SETTINGS_FIELD_NUMBER = 27;
  private boolean encryptAppSettings_;
  /**
   * <code>optional bool encrypt_app_settings = 27;</code>
   */
  public boolean hasEncryptAppSettings() {
    return ((bitField0_ & 0x00008000) == 0x00008000);
  }
  /**
   * <code>optional bool encrypt_app_settings = 27;</code>
   */
  public boolean getEncryptAppSettings() {
    return encryptAppSettings_;
  }
  /**
   * <code>optional bool encrypt_app_settings = 27;</code>
   */
  private void setEncryptAppSettings(boolean value) {
    bitField0_ |= 0x00008000;
    encryptAppSettings_ = value;
  }
  /**
   * <code>optional bool encrypt_app_settings = 27;</code>
   */
  private void clearEncryptAppSettings() {
    bitField0_ = (bitField0_ & ~0x00008000);
    encryptAppSettings_ = false;
  }

  public static final int SYNC_TAB_FAVICONS_FIELD_NUMBER = 29;
  private boolean syncTabFavicons_;
  /**
   * <pre>
   * Enable syncing favicons as part of tab sync.
   * </pre>
   *
   * <code>optional bool sync_tab_favicons = 29;</code>
   */
  public boolean hasSyncTabFavicons() {
    return ((bitField0_ & 0x00010000) == 0x00010000);
  }
  /**
   * <pre>
   * Enable syncing favicons as part of tab sync.
   * </pre>
   *
   * <code>optional bool sync_tab_favicons = 29;</code>
   */
  public boolean getSyncTabFavicons() {
    return syncTabFavicons_;
  }
  /**
   * <pre>
   * Enable syncing favicons as part of tab sync.
   * </pre>
   *
   * <code>optional bool sync_tab_favicons = 29;</code>
   */
  private void setSyncTabFavicons(boolean value) {
    bitField0_ |= 0x00010000;
    syncTabFavicons_ = value;
  }
  /**
   * <pre>
   * Enable syncing favicons as part of tab sync.
   * </pre>
   *
   * <code>optional bool sync_tab_favicons = 29;</code>
   */
  private void clearSyncTabFavicons() {
    bitField0_ = (bitField0_ & ~0x00010000);
    syncTabFavicons_ = false;
  }

  public static final int PASSPHRASE_TYPE_FIELD_NUMBER = 30;
  private int passphraseType_;
  /**
   * <pre>
   * An |int| field is used instead of enum PassphraseType so we can better
   * handle unknown values coming from later versions. Prior to M77, this was an
   * enum so old clients will assume IMPLICIT_PASSPHRASE for values greater than
   * 4.
   * </pre>
   *
   * <code>optional int32 passphrase_type = 30 [default = 1];</code>
   */
  public boolean hasPassphraseType() {
    return ((bitField0_ & 0x00020000) == 0x00020000);
  }
  /**
   * <pre>
   * An |int| field is used instead of enum PassphraseType so we can better
   * handle unknown values coming from later versions. Prior to M77, this was an
   * enum so old clients will assume IMPLICIT_PASSPHRASE for values greater than
   * 4.
   * </pre>
   *
   * <code>optional int32 passphrase_type = 30 [default = 1];</code>
   */
  public int getPassphraseType() {
    return passphraseType_;
  }
  /**
   * <pre>
   * An |int| field is used instead of enum PassphraseType so we can better
   * handle unknown values coming from later versions. Prior to M77, this was an
   * enum so old clients will assume IMPLICIT_PASSPHRASE for values greater than
   * 4.
   * </pre>
   *
   * <code>optional int32 passphrase_type = 30 [default = 1];</code>
   */
  private void setPassphraseType(int value) {
    bitField0_ |= 0x00020000;
    passphraseType_ = value;
  }
  /**
   * <pre>
   * An |int| field is used instead of enum PassphraseType so we can better
   * handle unknown values coming from later versions. Prior to M77, this was an
   * enum so old clients will assume IMPLICIT_PASSPHRASE for values greater than
   * 4.
   * </pre>
   *
   * <code>optional int32 passphrase_type = 30 [default = 1];</code>
   */
  private void clearPassphraseType() {
    bitField0_ = (bitField0_ & ~0x00020000);
    passphraseType_ = 1;
  }

  public static final int KEYSTORE_DECRYPTOR_TOKEN_FIELD_NUMBER = 31;
  private org.chromium.components.sync.protocol.EncryptedData keystoreDecryptorToken_;
  /**
   * <pre>
   * The keystore decryptor token blob. Encrypted with the keystore key, and
   * contains the encryption key used to decrypt |encryption_keybag|.
   * Only set if passphrase_state == KEYSTORE_PASSPHRASE.
   * </pre>
   *
   * <code>optional .sync_pb.EncryptedData keystore_decryptor_token = 31;</code>
   */
  public boolean hasKeystoreDecryptorToken() {
    return ((bitField0_ & 0x00040000) == 0x00040000);
  }
  /**
   * <pre>
   * The keystore decryptor token blob. Encrypted with the keystore key, and
   * contains the encryption key used to decrypt |encryption_keybag|.
   * Only set if passphrase_state == KEYSTORE_PASSPHRASE.
   * </pre>
   *
   * <code>optional .sync_pb.EncryptedData keystore_decryptor_token = 31;</code>
   */
  public org.chromium.components.sync.protocol.EncryptedData getKeystoreDecryptorToken() {
    return keystoreDecryptorToken_ == null ? org.chromium.components.sync.protocol.EncryptedData.getDefaultInstance() : keystoreDecryptorToken_;
  }
  /**
   * <pre>
   * The keystore decryptor token blob. Encrypted with the keystore key, and
   * contains the encryption key used to decrypt |encryption_keybag|.
   * Only set if passphrase_state == KEYSTORE_PASSPHRASE.
   * </pre>
   *
   * <code>optional .sync_pb.EncryptedData keystore_decryptor_token = 31;</code>
   */
  private void setKeystoreDecryptorToken(org.chromium.components.sync.protocol.EncryptedData value) {
    if (value == null) {
      throw new NullPointerException();
    }
    keystoreDecryptorToken_ = value;
    bitField0_ |= 0x00040000;
    }
  /**
   * <pre>
   * The keystore decryptor token blob. Encrypted with the keystore key, and
   * contains the encryption key used to decrypt |encryption_keybag|.
   * Only set if passphrase_state == KEYSTORE_PASSPHRASE.
   * </pre>
   *
   * <code>optional .sync_pb.EncryptedData keystore_decryptor_token = 31;</code>
   */
  private void setKeystoreDecryptorToken(
      org.chromium.components.sync.protocol.EncryptedData.Builder builderForValue) {
    keystoreDecryptorToken_ = builderForValue.build();
    bitField0_ |= 0x00040000;
  }
  /**
   * <pre>
   * The keystore decryptor token blob. Encrypted with the keystore key, and
   * contains the encryption key used to decrypt |encryption_keybag|.
   * Only set if passphrase_state == KEYSTORE_PASSPHRASE.
   * </pre>
   *
   * <code>optional .sync_pb.EncryptedData keystore_decryptor_token = 31;</code>
   */
  private void mergeKeystoreDecryptorToken(org.chromium.components.sync.protocol.EncryptedData value) {
    if (keystoreDecryptorToken_ != null &&
        keystoreDecryptorToken_ != org.chromium.components.sync.protocol.EncryptedData.getDefaultInstance()) {
      keystoreDecryptorToken_ =
        org.chromium.components.sync.protocol.EncryptedData.newBuilder(keystoreDecryptorToken_).mergeFrom(value).buildPartial();
    } else {
      keystoreDecryptorToken_ = value;
    }
    bitField0_ |= 0x00040000;
  }
  /**
   * <pre>
   * The keystore decryptor token blob. Encrypted with the keystore key, and
   * contains the encryption key used to decrypt |encryption_keybag|.
   * Only set if passphrase_state == KEYSTORE_PASSPHRASE.
   * </pre>
   *
   * <code>optional .sync_pb.EncryptedData keystore_decryptor_token = 31;</code>
   */
  private void clearKeystoreDecryptorToken() {  keystoreDecryptorToken_ = null;
    bitField0_ = (bitField0_ & ~0x00040000);
  }

  public static final int KEYSTORE_MIGRATION_TIME_FIELD_NUMBER = 32;
  private long keystoreMigrationTime_;
  /**
   * <pre>
   * The time (in epoch milliseconds) at which the keystore migration was
   * performed.
   * </pre>
   *
   * <code>optional int64 keystore_migration_time = 32;</code>
   */
  public boolean hasKeystoreMigrationTime() {
    return ((bitField0_ & 0x00080000) == 0x00080000);
  }
  /**
   * <pre>
   * The time (in epoch milliseconds) at which the keystore migration was
   * performed.
   * </pre>
   *
   * <code>optional int64 keystore_migration_time = 32;</code>
   */
  public long getKeystoreMigrationTime() {
    return keystoreMigrationTime_;
  }
  /**
   * <pre>
   * The time (in epoch milliseconds) at which the keystore migration was
   * performed.
   * </pre>
   *
   * <code>optional int64 keystore_migration_time = 32;</code>
   */
  private void setKeystoreMigrationTime(long value) {
    bitField0_ |= 0x00080000;
    keystoreMigrationTime_ = value;
  }
  /**
   * <pre>
   * The time (in epoch milliseconds) at which the keystore migration was
   * performed.
   * </pre>
   *
   * <code>optional int64 keystore_migration_time = 32;</code>
   */
  private void clearKeystoreMigrationTime() {
    bitField0_ = (bitField0_ & ~0x00080000);
    keystoreMigrationTime_ = 0L;
  }

  public static final int CUSTOM_PASSPHRASE_TIME_FIELD_NUMBER = 33;
  private long customPassphraseTime_;
  /**
   * <pre>
   * The time (in epoch milliseconds) at which a custom passphrase was set.
   * Note: this field may not be set if the custom passphrase was applied before
   * this field was introduced.
   * </pre>
   *
   * <code>optional int64 custom_passphrase_time = 33;</code>
   */
  public boolean hasCustomPassphraseTime() {
    return ((bitField0_ & 0x00100000) == 0x00100000);
  }
  /**
   * <pre>
   * The time (in epoch milliseconds) at which a custom passphrase was set.
   * Note: this field may not be set if the custom passphrase was applied before
   * this field was introduced.
   * </pre>
   *
   * <code>optional int64 custom_passphrase_time = 33;</code>
   */
  public long getCustomPassphraseTime() {
    return customPassphraseTime_;
  }
  /**
   * <pre>
   * The time (in epoch milliseconds) at which a custom passphrase was set.
   * Note: this field may not be set if the custom passphrase was applied before
   * this field was introduced.
   * </pre>
   *
   * <code>optional int64 custom_passphrase_time = 33;</code>
   */
  private void setCustomPassphraseTime(long value) {
    bitField0_ |= 0x00100000;
    customPassphraseTime_ = value;
  }
  /**
   * <pre>
   * The time (in epoch milliseconds) at which a custom passphrase was set.
   * Note: this field may not be set if the custom passphrase was applied before
   * this field was introduced.
   * </pre>
   *
   * <code>optional int64 custom_passphrase_time = 33;</code>
   */
  private void clearCustomPassphraseTime() {
    bitField0_ = (bitField0_ & ~0x00100000);
    customPassphraseTime_ = 0L;
  }

  public static final int ENCRYPT_DICTIONARY_FIELD_NUMBER = 34;
  private boolean encryptDictionary_;
  /**
   * <pre>
   * Boolean corresponding to whether custom spelling dictionary should be
   * encrypted.
   * </pre>
   *
   * <code>optional bool encrypt_dictionary = 34;</code>
   */
  public boolean hasEncryptDictionary() {
    return ((bitField0_ & 0x00200000) == 0x00200000);
  }
  /**
   * <pre>
   * Boolean corresponding to whether custom spelling dictionary should be
   * encrypted.
   * </pre>
   *
   * <code>optional bool encrypt_dictionary = 34;</code>
   */
  public boolean getEncryptDictionary() {
    return encryptDictionary_;
  }
  /**
   * <pre>
   * Boolean corresponding to whether custom spelling dictionary should be
   * encrypted.
   * </pre>
   *
   * <code>optional bool encrypt_dictionary = 34;</code>
   */
  private void setEncryptDictionary(boolean value) {
    bitField0_ |= 0x00200000;
    encryptDictionary_ = value;
  }
  /**
   * <pre>
   * Boolean corresponding to whether custom spelling dictionary should be
   * encrypted.
   * </pre>
   *
   * <code>optional bool encrypt_dictionary = 34;</code>
   */
  private void clearEncryptDictionary() {
    bitField0_ = (bitField0_ & ~0x00200000);
    encryptDictionary_ = false;
  }

  public static final int ENCRYPT_FAVICON_IMAGES_FIELD_NUMBER = 35;
  private boolean encryptFaviconImages_;
  /**
   * <pre>
   * Boolean corresponding to Whether to encrypt favicons data or not.
   * </pre>
   *
   * <code>optional bool encrypt_favicon_images = 35;</code>
   */
  public boolean hasEncryptFaviconImages() {
    return ((bitField0_ & 0x00400000) == 0x00400000);
  }
  /**
   * <pre>
   * Boolean corresponding to Whether to encrypt favicons data or not.
   * </pre>
   *
   * <code>optional bool encrypt_favicon_images = 35;</code>
   */
  public boolean getEncryptFaviconImages() {
    return encryptFaviconImages_;
  }
  /**
   * <pre>
   * Boolean corresponding to Whether to encrypt favicons data or not.
   * </pre>
   *
   * <code>optional bool encrypt_favicon_images = 35;</code>
   */
  private void setEncryptFaviconImages(boolean value) {
    bitField0_ |= 0x00400000;
    encryptFaviconImages_ = value;
  }
  /**
   * <pre>
   * Boolean corresponding to Whether to encrypt favicons data or not.
   * </pre>
   *
   * <code>optional bool encrypt_favicon_images = 35;</code>
   */
  private void clearEncryptFaviconImages() {
    bitField0_ = (bitField0_ & ~0x00400000);
    encryptFaviconImages_ = false;
  }

  public static final int ENCRYPT_FAVICON_TRACKING_FIELD_NUMBER = 36;
  private boolean encryptFaviconTracking_;
  /**
   * <code>optional bool encrypt_favicon_tracking = 36;</code>
   */
  public boolean hasEncryptFaviconTracking() {
    return ((bitField0_ & 0x00800000) == 0x00800000);
  }
  /**
   * <code>optional bool encrypt_favicon_tracking = 36;</code>
   */
  public boolean getEncryptFaviconTracking() {
    return encryptFaviconTracking_;
  }
  /**
   * <code>optional bool encrypt_favicon_tracking = 36;</code>
   */
  private void setEncryptFaviconTracking(boolean value) {
    bitField0_ |= 0x00800000;
    encryptFaviconTracking_ = value;
  }
  /**
   * <code>optional bool encrypt_favicon_tracking = 36;</code>
   */
  private void clearEncryptFaviconTracking() {
    bitField0_ = (bitField0_ & ~0x00800000);
    encryptFaviconTracking_ = false;
  }

  public static final int ENCRYPT_APP_LIST_FIELD_NUMBER = 38;
  private boolean encryptAppList_;
  /**
   * <pre>
   * Boolean corresponding to whether app list items should be encrypted.
   * </pre>
   *
   * <code>optional bool encrypt_app_list = 38;</code>
   */
  public boolean hasEncryptAppList() {
    return ((bitField0_ & 0x01000000) == 0x01000000);
  }
  /**
   * <pre>
   * Boolean corresponding to whether app list items should be encrypted.
   * </pre>
   *
   * <code>optional bool encrypt_app_list = 38;</code>
   */
  public boolean getEncryptAppList() {
    return encryptAppList_;
  }
  /**
   * <pre>
   * Boolean corresponding to whether app list items should be encrypted.
   * </pre>
   *
   * <code>optional bool encrypt_app_list = 38;</code>
   */
  private void setEncryptAppList(boolean value) {
    bitField0_ |= 0x01000000;
    encryptAppList_ = value;
  }
  /**
   * <pre>
   * Boolean corresponding to whether app list items should be encrypted.
   * </pre>
   *
   * <code>optional bool encrypt_app_list = 38;</code>
   */
  private void clearEncryptAppList() {
    bitField0_ = (bitField0_ & ~0x01000000);
    encryptAppList_ = false;
  }

  public static final int ENCRYPT_AUTOFILL_WALLET_METADATA_FIELD_NUMBER = 39;
  private boolean encryptAutofillWalletMetadata_;
  /**
   * <pre>
   * Boolean corresponding to whether usage count and last use date of Wallet
   * data should be encrypted.
   * </pre>
   *
   * <code>optional bool encrypt_autofill_wallet_metadata = 39;</code>
   */
  public boolean hasEncryptAutofillWalletMetadata() {
    return ((bitField0_ & 0x02000000) == 0x02000000);
  }
  /**
   * <pre>
   * Boolean corresponding to whether usage count and last use date of Wallet
   * data should be encrypted.
   * </pre>
   *
   * <code>optional bool encrypt_autofill_wallet_metadata = 39;</code>
   */
  public boolean getEncryptAutofillWalletMetadata() {
    return encryptAutofillWalletMetadata_;
  }
  /**
   * <pre>
   * Boolean corresponding to whether usage count and last use date of Wallet
   * data should be encrypted.
   * </pre>
   *
   * <code>optional bool encrypt_autofill_wallet_metadata = 39;</code>
   */
  private void setEncryptAutofillWalletMetadata(boolean value) {
    bitField0_ |= 0x02000000;
    encryptAutofillWalletMetadata_ = value;
  }
  /**
   * <pre>
   * Boolean corresponding to whether usage count and last use date of Wallet
   * data should be encrypted.
   * </pre>
   *
   * <code>optional bool encrypt_autofill_wallet_metadata = 39;</code>
   */
  private void clearEncryptAutofillWalletMetadata() {
    bitField0_ = (bitField0_ & ~0x02000000);
    encryptAutofillWalletMetadata_ = false;
  }

  public static final int SERVER_ONLY_WAS_MISSING_KEYSTORE_MIGRATION_TIME_FIELD_NUMBER = 40;
  private boolean serverOnlyWasMissingKeystoreMigrationTime_;
  /**
   * <pre>
   * Boolean indicating whether this node was originally missing a
   * |keystore_migration_time| field value, and was fixed on the server by
   * giving the field a value.
   * THIS FIELD SHOULD ONLY BE SET BY THE SERVER.
   * </pre>
   *
   * <code>optional bool server_only_was_missing_keystore_migration_time = 40;</code>
   */
  public boolean hasServerOnlyWasMissingKeystoreMigrationTime() {
    return ((bitField0_ & 0x04000000) == 0x04000000);
  }
  /**
   * <pre>
   * Boolean indicating whether this node was originally missing a
   * |keystore_migration_time| field value, and was fixed on the server by
   * giving the field a value.
   * THIS FIELD SHOULD ONLY BE SET BY THE SERVER.
   * </pre>
   *
   * <code>optional bool server_only_was_missing_keystore_migration_time = 40;</code>
   */
  public boolean getServerOnlyWasMissingKeystoreMigrationTime() {
    return serverOnlyWasMissingKeystoreMigrationTime_;
  }
  /**
   * <pre>
   * Boolean indicating whether this node was originally missing a
   * |keystore_migration_time| field value, and was fixed on the server by
   * giving the field a value.
   * THIS FIELD SHOULD ONLY BE SET BY THE SERVER.
   * </pre>
   *
   * <code>optional bool server_only_was_missing_keystore_migration_time = 40;</code>
   */
  private void setServerOnlyWasMissingKeystoreMigrationTime(boolean value) {
    bitField0_ |= 0x04000000;
    serverOnlyWasMissingKeystoreMigrationTime_ = value;
  }
  /**
   * <pre>
   * Boolean indicating whether this node was originally missing a
   * |keystore_migration_time| field value, and was fixed on the server by
   * giving the field a value.
   * THIS FIELD SHOULD ONLY BE SET BY THE SERVER.
   * </pre>
   *
   * <code>optional bool server_only_was_missing_keystore_migration_time = 40;</code>
   */
  private void clearServerOnlyWasMissingKeystoreMigrationTime() {
    bitField0_ = (bitField0_ & ~0x04000000);
    serverOnlyWasMissingKeystoreMigrationTime_ = false;
  }

  public static final int ENCRYPT_ARC_PACKAGE_FIELD_NUMBER = 41;
  private boolean encryptArcPackage_;
  /**
   * <pre>
   * Boolean corresponding to whether arc pakcage items should be encrypted.
   * </pre>
   *
   * <code>optional bool encrypt_arc_package = 41;</code>
   */
  public boolean hasEncryptArcPackage() {
    return ((bitField0_ & 0x08000000) == 0x08000000);
  }
  /**
   * <pre>
   * Boolean corresponding to whether arc pakcage items should be encrypted.
   * </pre>
   *
   * <code>optional bool encrypt_arc_package = 41;</code>
   */
  public boolean getEncryptArcPackage() {
    return encryptArcPackage_;
  }
  /**
   * <pre>
   * Boolean corresponding to whether arc pakcage items should be encrypted.
   * </pre>
   *
   * <code>optional bool encrypt_arc_package = 41;</code>
   */
  private void setEncryptArcPackage(boolean value) {
    bitField0_ |= 0x08000000;
    encryptArcPackage_ = value;
  }
  /**
   * <pre>
   * Boolean corresponding to whether arc pakcage items should be encrypted.
   * </pre>
   *
   * <code>optional bool encrypt_arc_package = 41;</code>
   */
  private void clearEncryptArcPackage() {
    bitField0_ = (bitField0_ & ~0x08000000);
    encryptArcPackage_ = false;
  }

  public static final int ENCRYPT_PRINTERS_FIELD_NUMBER = 42;
  private boolean encryptPrinters_;
  /**
   * <pre>
   * Boolean corresponding to whether printer items should be encrypted.
   * </pre>
   *
   * <code>optional bool encrypt_printers = 42;</code>
   */
  public boolean hasEncryptPrinters() {
    return ((bitField0_ & 0x10000000) == 0x10000000);
  }
  /**
   * <pre>
   * Boolean corresponding to whether printer items should be encrypted.
   * </pre>
   *
   * <code>optional bool encrypt_printers = 42;</code>
   */
  public boolean getEncryptPrinters() {
    return encryptPrinters_;
  }
  /**
   * <pre>
   * Boolean corresponding to whether printer items should be encrypted.
   * </pre>
   *
   * <code>optional bool encrypt_printers = 42;</code>
   */
  private void setEncryptPrinters(boolean value) {
    bitField0_ |= 0x10000000;
    encryptPrinters_ = value;
  }
  /**
   * <pre>
   * Boolean corresponding to whether printer items should be encrypted.
   * </pre>
   *
   * <code>optional bool encrypt_printers = 42;</code>
   */
  private void clearEncryptPrinters() {
    bitField0_ = (bitField0_ & ~0x10000000);
    encryptPrinters_ = false;
  }

  public static final int ENCRYPT_READING_LIST_FIELD_NUMBER = 43;
  private boolean encryptReadingList_;
  /**
   * <pre>
   * Boolean corresponding to whether reading list items should be encrypted.
   * </pre>
   *
   * <code>optional bool encrypt_reading_list = 43;</code>
   */
  public boolean hasEncryptReadingList() {
    return ((bitField0_ & 0x20000000) == 0x20000000);
  }
  /**
   * <pre>
   * Boolean corresponding to whether reading list items should be encrypted.
   * </pre>
   *
   * <code>optional bool encrypt_reading_list = 43;</code>
   */
  public boolean getEncryptReadingList() {
    return encryptReadingList_;
  }
  /**
   * <pre>
   * Boolean corresponding to whether reading list items should be encrypted.
   * </pre>
   *
   * <code>optional bool encrypt_reading_list = 43;</code>
   */
  private void setEncryptReadingList(boolean value) {
    bitField0_ |= 0x20000000;
    encryptReadingList_ = value;
  }
  /**
   * <pre>
   * Boolean corresponding to whether reading list items should be encrypted.
   * </pre>
   *
   * <code>optional bool encrypt_reading_list = 43;</code>
   */
  private void clearEncryptReadingList() {
    bitField0_ = (bitField0_ & ~0x20000000);
    encryptReadingList_ = false;
  }

  public static final int CUSTOM_PASSPHRASE_KEY_DERIVATION_METHOD_FIELD_NUMBER = 45;
  private int customPassphraseKeyDerivationMethod_;
  /**
   * <pre>
   * ID of the method used to derive the encryption key from a custom
   * passphrase. Should be set only when |passphrase_type| is CUSTOM_PASSPHRASE
   * and only based on CustomPassphraseKeyDerivationMethod. This field has been
   * added in M70. All previous versions just ignore it, attempt to use
   * PBKDF2_HMAC_SHA1_1003 and, thus, reject any passphrase if a different
   * method has been used. The default corresponds to UNSPECIFIED. An |int|
   * field is used so we can detect unknown values coming from later versions.
   * </pre>
   *
   * <code>optional int32 custom_passphrase_key_derivation_method = 45 [default = 0];</code>
   */
  public boolean hasCustomPassphraseKeyDerivationMethod() {
    return ((bitField0_ & 0x40000000) == 0x40000000);
  }
  /**
   * <pre>
   * ID of the method used to derive the encryption key from a custom
   * passphrase. Should be set only when |passphrase_type| is CUSTOM_PASSPHRASE
   * and only based on CustomPassphraseKeyDerivationMethod. This field has been
   * added in M70. All previous versions just ignore it, attempt to use
   * PBKDF2_HMAC_SHA1_1003 and, thus, reject any passphrase if a different
   * method has been used. The default corresponds to UNSPECIFIED. An |int|
   * field is used so we can detect unknown values coming from later versions.
   * </pre>
   *
   * <code>optional int32 custom_passphrase_key_derivation_method = 45 [default = 0];</code>
   */
  public int getCustomPassphraseKeyDerivationMethod() {
    return customPassphraseKeyDerivationMethod_;
  }
  /**
   * <pre>
   * ID of the method used to derive the encryption key from a custom
   * passphrase. Should be set only when |passphrase_type| is CUSTOM_PASSPHRASE
   * and only based on CustomPassphraseKeyDerivationMethod. This field has been
   * added in M70. All previous versions just ignore it, attempt to use
   * PBKDF2_HMAC_SHA1_1003 and, thus, reject any passphrase if a different
   * method has been used. The default corresponds to UNSPECIFIED. An |int|
   * field is used so we can detect unknown values coming from later versions.
   * </pre>
   *
   * <code>optional int32 custom_passphrase_key_derivation_method = 45 [default = 0];</code>
   */
  private void setCustomPassphraseKeyDerivationMethod(int value) {
    bitField0_ |= 0x40000000;
    customPassphraseKeyDerivationMethod_ = value;
  }
  /**
   * <pre>
   * ID of the method used to derive the encryption key from a custom
   * passphrase. Should be set only when |passphrase_type| is CUSTOM_PASSPHRASE
   * and only based on CustomPassphraseKeyDerivationMethod. This field has been
   * added in M70. All previous versions just ignore it, attempt to use
   * PBKDF2_HMAC_SHA1_1003 and, thus, reject any passphrase if a different
   * method has been used. The default corresponds to UNSPECIFIED. An |int|
   * field is used so we can detect unknown values coming from later versions.
   * </pre>
   *
   * <code>optional int32 custom_passphrase_key_derivation_method = 45 [default = 0];</code>
   */
  private void clearCustomPassphraseKeyDerivationMethod() {
    bitField0_ = (bitField0_ & ~0x40000000);
    customPassphraseKeyDerivationMethod_ = 0;
  }

  public static final int CUSTOM_PASSPHRASE_KEY_DERIVATION_SALT_FIELD_NUMBER = 46;
  private java.lang.String customPassphraseKeyDerivationSalt_;
  /**
   * <pre>
   * Base64-encoded salt used for the derivation of the key from the custom
   * passphrase. Valid only if custom_passphrase_key_derivation_method ==
   * SCRYPT_8192_8_11, ignored in other cases.
   * </pre>
   *
   * <code>optional string custom_passphrase_key_derivation_salt = 46;</code>
   */
  public boolean hasCustomPassphraseKeyDerivationSalt() {
    return ((bitField0_ & 0x80000000) == 0x80000000);
  }
  /**
   * <pre>
   * Base64-encoded salt used for the derivation of the key from the custom
   * passphrase. Valid only if custom_passphrase_key_derivation_method ==
   * SCRYPT_8192_8_11, ignored in other cases.
   * </pre>
   *
   * <code>optional string custom_passphrase_key_derivation_salt = 46;</code>
   */
  public java.lang.String getCustomPassphraseKeyDerivationSalt() {
    return customPassphraseKeyDerivationSalt_;
  }
  /**
   * <pre>
   * Base64-encoded salt used for the derivation of the key from the custom
   * passphrase. Valid only if custom_passphrase_key_derivation_method ==
   * SCRYPT_8192_8_11, ignored in other cases.
   * </pre>
   *
   * <code>optional string custom_passphrase_key_derivation_salt = 46;</code>
   */
  public com.google.protobuf.ByteString
      getCustomPassphraseKeyDerivationSaltBytes() {
    return com.google.protobuf.ByteString.copyFromUtf8(customPassphraseKeyDerivationSalt_);
  }
  /**
   * <pre>
   * Base64-encoded salt used for the derivation of the key from the custom
   * passphrase. Valid only if custom_passphrase_key_derivation_method ==
   * SCRYPT_8192_8_11, ignored in other cases.
   * </pre>
   *
   * <code>optional string custom_passphrase_key_derivation_salt = 46;</code>
   */
  private void setCustomPassphraseKeyDerivationSalt(
      java.lang.String value) {
    if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x80000000;
    customPassphraseKeyDerivationSalt_ = value;
  }
  /**
   * <pre>
   * Base64-encoded salt used for the derivation of the key from the custom
   * passphrase. Valid only if custom_passphrase_key_derivation_method ==
   * SCRYPT_8192_8_11, ignored in other cases.
   * </pre>
   *
   * <code>optional string custom_passphrase_key_derivation_salt = 46;</code>
   */
  private void clearCustomPassphraseKeyDerivationSalt() {
    bitField0_ = (bitField0_ & ~0x80000000);
    customPassphraseKeyDerivationSalt_ = getDefaultInstance().getCustomPassphraseKeyDerivationSalt();
  }
  /**
   * <pre>
   * Base64-encoded salt used for the derivation of the key from the custom
   * passphrase. Valid only if custom_passphrase_key_derivation_method ==
   * SCRYPT_8192_8_11, ignored in other cases.
   * </pre>
   *
   * <code>optional string custom_passphrase_key_derivation_salt = 46;</code>
   */
  private void setCustomPassphraseKeyDerivationSaltBytes(
      com.google.protobuf.ByteString value) {
    if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x80000000;
    customPassphraseKeyDerivationSalt_ = value.toStringUtf8();
  }

  public static final int ENCRYPT_SEND_TAB_TO_SELF_FIELD_NUMBER = 47;
  private boolean encryptSendTabToSelf_;
  /**
   * <pre>
   * Boolean corresponding to whether send tab should be encrypted.
   * </pre>
   *
   * <code>optional bool encrypt_send_tab_to_self = 47;</code>
   */
  public boolean hasEncryptSendTabToSelf() {
    return ((bitField1_ & 0x00000001) == 0x00000001);
  }
  /**
   * <pre>
   * Boolean corresponding to whether send tab should be encrypted.
   * </pre>
   *
   * <code>optional bool encrypt_send_tab_to_self = 47;</code>
   */
  public boolean getEncryptSendTabToSelf() {
    return encryptSendTabToSelf_;
  }
  /**
   * <pre>
   * Boolean corresponding to whether send tab should be encrypted.
   * </pre>
   *
   * <code>optional bool encrypt_send_tab_to_self = 47;</code>
   */
  private void setEncryptSendTabToSelf(boolean value) {
    bitField1_ |= 0x00000001;
    encryptSendTabToSelf_ = value;
  }
  /**
   * <pre>
   * Boolean corresponding to whether send tab should be encrypted.
   * </pre>
   *
   * <code>optional bool encrypt_send_tab_to_self = 47;</code>
   */
  private void clearEncryptSendTabToSelf() {
    bitField1_ = (bitField1_ & ~0x00000001);
    encryptSendTabToSelf_ = false;
  }

  public static final int ENCRYPT_WEB_APPS_FIELD_NUMBER = 48;
  private boolean encryptWebApps_;
  /**
   * <pre>
   * Boolean corresponding to whether Web Apps data should be encrypted.
   * </pre>
   *
   * <code>optional bool encrypt_web_apps = 48;</code>
   */
  public boolean hasEncryptWebApps() {
    return ((bitField1_ & 0x00000002) == 0x00000002);
  }
  /**
   * <pre>
   * Boolean corresponding to whether Web Apps data should be encrypted.
   * </pre>
   *
   * <code>optional bool encrypt_web_apps = 48;</code>
   */
  public boolean getEncryptWebApps() {
    return encryptWebApps_;
  }
  /**
   * <pre>
   * Boolean corresponding to whether Web Apps data should be encrypted.
   * </pre>
   *
   * <code>optional bool encrypt_web_apps = 48;</code>
   */
  private void setEncryptWebApps(boolean value) {
    bitField1_ |= 0x00000002;
    encryptWebApps_ = value;
  }
  /**
   * <pre>
   * Boolean corresponding to whether Web Apps data should be encrypted.
   * </pre>
   *
   * <code>optional bool encrypt_web_apps = 48;</code>
   */
  private void clearEncryptWebApps() {
    bitField1_ = (bitField1_ & ~0x00000002);
    encryptWebApps_ = false;
  }

  public static final int ENCRYPT_OS_PREFERENCES_FIELD_NUMBER = 49;
  private boolean encryptOsPreferences_;
  /**
   * <pre>
   * Boolean corresponding to whether OS preferences should be encrypted.
   * </pre>
   *
   * <code>optional bool encrypt_os_preferences = 49;</code>
   */
  public boolean hasEncryptOsPreferences() {
    return ((bitField1_ & 0x00000004) == 0x00000004);
  }
  /**
   * <pre>
   * Boolean corresponding to whether OS preferences should be encrypted.
   * </pre>
   *
   * <code>optional bool encrypt_os_preferences = 49;</code>
   */
  public boolean getEncryptOsPreferences() {
    return encryptOsPreferences_;
  }
  /**
   * <pre>
   * Boolean corresponding to whether OS preferences should be encrypted.
   * </pre>
   *
   * <code>optional bool encrypt_os_preferences = 49;</code>
   */
  private void setEncryptOsPreferences(boolean value) {
    bitField1_ |= 0x00000004;
    encryptOsPreferences_ = value;
  }
  /**
   * <pre>
   * Boolean corresponding to whether OS preferences should be encrypted.
   * </pre>
   *
   * <code>optional bool encrypt_os_preferences = 49;</code>
   */
  private void clearEncryptOsPreferences() {
    bitField1_ = (bitField1_ & ~0x00000004);
    encryptOsPreferences_ = false;
  }

  public void writeTo(com.google.protobuf.CodedOutputStream output)
                      throws java.io.IOException {
    if (((bitField0_ & 0x00000001) == 0x00000001)) {
      output.writeMessage(1, getEncryptionKeybag());
    }
    if (((bitField0_ & 0x00000002) == 0x00000002)) {
      output.writeBool(2, keybagIsFrozen_);
    }
    if (((bitField0_ & 0x00000004) == 0x00000004)) {
      output.writeBool(13, encryptBookmarks_);
    }
    if (((bitField0_ & 0x00000008) == 0x00000008)) {
      output.writeBool(14, encryptPreferences_);
    }
    if (((bitField0_ & 0x00000010) == 0x00000010)) {
      output.writeBool(15, encryptAutofillProfile_);
    }
    if (((bitField0_ & 0x00000020) == 0x00000020)) {
      output.writeBool(16, encryptAutofill_);
    }
    if (((bitField0_ & 0x00000040) == 0x00000040)) {
      output.writeBool(17, encryptThemes_);
    }
    if (((bitField0_ & 0x00000080) == 0x00000080)) {
      output.writeBool(18, encryptTypedUrls_);
    }
    if (((bitField0_ & 0x00000100) == 0x00000100)) {
      output.writeBool(19, encryptExtensions_);
    }
    if (((bitField0_ & 0x00000200) == 0x00000200)) {
      output.writeBool(20, encryptSessions_);
    }
    if (((bitField0_ & 0x00000400) == 0x00000400)) {
      output.writeBool(21, encryptApps_);
    }
    if (((bitField0_ & 0x00000800) == 0x00000800)) {
      output.writeBool(22, encryptSearchEngines_);
    }
    if (((bitField0_ & 0x00001000) == 0x00001000)) {
      output.writeBool(24, encryptEverything_);
    }
    if (((bitField0_ & 0x00002000) == 0x00002000)) {
      output.writeBool(25, encryptExtensionSettings_);
    }
    if (((bitField0_ & 0x00004000) == 0x00004000)) {
      output.writeBool(26, encryptAppNotifications_);
    }
    if (((bitField0_ & 0x00008000) == 0x00008000)) {
      output.writeBool(27, encryptAppSettings_);
    }
    if (((bitField0_ & 0x00010000) == 0x00010000)) {
      output.writeBool(29, syncTabFavicons_);
    }
    if (((bitField0_ & 0x00020000) == 0x00020000)) {
      output.writeInt32(30, passphraseType_);
    }
    if (((bitField0_ & 0x00040000) == 0x00040000)) {
      output.writeMessage(31, getKeystoreDecryptorToken());
    }
    if (((bitField0_ & 0x00080000) == 0x00080000)) {
      output.writeInt64(32, keystoreMigrationTime_);
    }
    if (((bitField0_ & 0x00100000) == 0x00100000)) {
      output.writeInt64(33, customPassphraseTime_);
    }
    if (((bitField0_ & 0x00200000) == 0x00200000)) {
      output.writeBool(34, encryptDictionary_);
    }
    if (((bitField0_ & 0x00400000) == 0x00400000)) {
      output.writeBool(35, encryptFaviconImages_);
    }
    if (((bitField0_ & 0x00800000) == 0x00800000)) {
      output.writeBool(36, encryptFaviconTracking_);
    }
    if (((bitField0_ & 0x01000000) == 0x01000000)) {
      output.writeBool(38, encryptAppList_);
    }
    if (((bitField0_ & 0x02000000) == 0x02000000)) {
      output.writeBool(39, encryptAutofillWalletMetadata_);
    }
    if (((bitField0_ & 0x04000000) == 0x04000000)) {
      output.writeBool(40, serverOnlyWasMissingKeystoreMigrationTime_);
    }
    if (((bitField0_ & 0x08000000) == 0x08000000)) {
      output.writeBool(41, encryptArcPackage_);
    }
    if (((bitField0_ & 0x10000000) == 0x10000000)) {
      output.writeBool(42, encryptPrinters_);
    }
    if (((bitField0_ & 0x20000000) == 0x20000000)) {
      output.writeBool(43, encryptReadingList_);
    }
    if (((bitField0_ & 0x40000000) == 0x40000000)) {
      output.writeInt32(45, customPassphraseKeyDerivationMethod_);
    }
    if (((bitField0_ & 0x80000000) == 0x80000000)) {
      output.writeString(46, getCustomPassphraseKeyDerivationSalt());
    }
    if (((bitField1_ & 0x00000001) == 0x00000001)) {
      output.writeBool(47, encryptSendTabToSelf_);
    }
    if (((bitField1_ & 0x00000002) == 0x00000002)) {
      output.writeBool(48, encryptWebApps_);
    }
    if (((bitField1_ & 0x00000004) == 0x00000004)) {
      output.writeBool(49, encryptOsPreferences_);
    }
    unknownFields.writeTo(output);
  }

  public int getSerializedSize() {
    int size = memoizedSerializedSize;
    if (size != -1) return size;

    size = 0;
    if (((bitField0_ & 0x00000001) == 0x00000001)) {
      size += com.google.protobuf.CodedOutputStream
        .computeMessageSize(1, getEncryptionKeybag());
    }
    if (((bitField0_ & 0x00000002) == 0x00000002)) {
      size += com.google.protobuf.CodedOutputStream
        .computeBoolSize(2, keybagIsFrozen_);
    }
    if (((bitField0_ & 0x00000004) == 0x00000004)) {
      size += com.google.protobuf.CodedOutputStream
        .computeBoolSize(13, encryptBookmarks_);
    }
    if (((bitField0_ & 0x00000008) == 0x00000008)) {
      size += com.google.protobuf.CodedOutputStream
        .computeBoolSize(14, encryptPreferences_);
    }
    if (((bitField0_ & 0x00000010) == 0x00000010)) {
      size += com.google.protobuf.CodedOutputStream
        .computeBoolSize(15, encryptAutofillProfile_);
    }
    if (((bitField0_ & 0x00000020) == 0x00000020)) {
      size += com.google.protobuf.CodedOutputStream
        .computeBoolSize(16, encryptAutofill_);
    }
    if (((bitField0_ & 0x00000040) == 0x00000040)) {
      size += com.google.protobuf.CodedOutputStream
        .computeBoolSize(17, encryptThemes_);
    }
    if (((bitField0_ & 0x00000080) == 0x00000080)) {
      size += com.google.protobuf.CodedOutputStream
        .computeBoolSize(18, encryptTypedUrls_);
    }
    if (((bitField0_ & 0x00000100) == 0x00000100)) {
      size += com.google.protobuf.CodedOutputStream
        .computeBoolSize(19, encryptExtensions_);
    }
    if (((bitField0_ & 0x00000200) == 0x00000200)) {
      size += com.google.protobuf.CodedOutputStream
        .computeBoolSize(20, encryptSessions_);
    }
    if (((bitField0_ & 0x00000400) == 0x00000400)) {
      size += com.google.protobuf.CodedOutputStream
        .computeBoolSize(21, encryptApps_);
    }
    if (((bitField0_ & 0x00000800) == 0x00000800)) {
      size += com.google.protobuf.CodedOutputStream
        .computeBoolSize(22, encryptSearchEngines_);
    }
    if (((bitField0_ & 0x00001000) == 0x00001000)) {
      size += com.google.protobuf.CodedOutputStream
        .computeBoolSize(24, encryptEverything_);
    }
    if (((bitField0_ & 0x00002000) == 0x00002000)) {
      size += com.google.protobuf.CodedOutputStream
        .computeBoolSize(25, encryptExtensionSettings_);
    }
    if (((bitField0_ & 0x00004000) == 0x00004000)) {
      size += com.google.protobuf.CodedOutputStream
        .computeBoolSize(26, encryptAppNotifications_);
    }
    if (((bitField0_ & 0x00008000) == 0x00008000)) {
      size += com.google.protobuf.CodedOutputStream
        .computeBoolSize(27, encryptAppSettings_);
    }
    if (((bitField0_ & 0x00010000) == 0x00010000)) {
      size += com.google.protobuf.CodedOutputStream
        .computeBoolSize(29, syncTabFavicons_);
    }
    if (((bitField0_ & 0x00020000) == 0x00020000)) {
      size += com.google.protobuf.CodedOutputStream
        .computeInt32Size(30, passphraseType_);
    }
    if (((bitField0_ & 0x00040000) == 0x00040000)) {
      size += com.google.protobuf.CodedOutputStream
        .computeMessageSize(31, getKeystoreDecryptorToken());
    }
    if (((bitField0_ & 0x00080000) == 0x00080000)) {
      size += com.google.protobuf.CodedOutputStream
        .computeInt64Size(32, keystoreMigrationTime_);
    }
    if (((bitField0_ & 0x00100000) == 0x00100000)) {
      size += com.google.protobuf.CodedOutputStream
        .computeInt64Size(33, customPassphraseTime_);
    }
    if (((bitField0_ & 0x00200000) == 0x00200000)) {
      size += com.google.protobuf.CodedOutputStream
        .computeBoolSize(34, encryptDictionary_);
    }
    if (((bitField0_ & 0x00400000) == 0x00400000)) {
      size += com.google.protobuf.CodedOutputStream
        .computeBoolSize(35, encryptFaviconImages_);
    }
    if (((bitField0_ & 0x00800000) == 0x00800000)) {
      size += com.google.protobuf.CodedOutputStream
        .computeBoolSize(36, encryptFaviconTracking_);
    }
    if (((bitField0_ & 0x01000000) == 0x01000000)) {
      size += com.google.protobuf.CodedOutputStream
        .computeBoolSize(38, encryptAppList_);
    }
    if (((bitField0_ & 0x02000000) == 0x02000000)) {
      size += com.google.protobuf.CodedOutputStream
        .computeBoolSize(39, encryptAutofillWalletMetadata_);
    }
    if (((bitField0_ & 0x04000000) == 0x04000000)) {
      size += com.google.protobuf.CodedOutputStream
        .computeBoolSize(40, serverOnlyWasMissingKeystoreMigrationTime_);
    }
    if (((bitField0_ & 0x08000000) == 0x08000000)) {
      size += com.google.protobuf.CodedOutputStream
        .computeBoolSize(41, encryptArcPackage_);
    }
    if (((bitField0_ & 0x10000000) == 0x10000000)) {
      size += com.google.protobuf.CodedOutputStream
        .computeBoolSize(42, encryptPrinters_);
    }
    if (((bitField0_ & 0x20000000) == 0x20000000)) {
      size += com.google.protobuf.CodedOutputStream
        .computeBoolSize(43, encryptReadingList_);
    }
    if (((bitField0_ & 0x40000000) == 0x40000000)) {
      size += com.google.protobuf.CodedOutputStream
        .computeInt32Size(45, customPassphraseKeyDerivationMethod_);
    }
    if (((bitField0_ & 0x80000000) == 0x80000000)) {
      size += com.google.protobuf.CodedOutputStream
        .computeStringSize(46, getCustomPassphraseKeyDerivationSalt());
    }
    if (((bitField1_ & 0x00000001) == 0x00000001)) {
      size += com.google.protobuf.CodedOutputStream
        .computeBoolSize(47, encryptSendTabToSelf_);
    }
    if (((bitField1_ & 0x00000002) == 0x00000002)) {
      size += com.google.protobuf.CodedOutputStream
        .computeBoolSize(48, encryptWebApps_);
    }
    if (((bitField1_ & 0x00000004) == 0x00000004)) {
      size += com.google.protobuf.CodedOutputStream
        .computeBoolSize(49, encryptOsPreferences_);
    }
    size += unknownFields.getSerializedSize();
    memoizedSerializedSize = size;
    return size;
  }

  public static org.chromium.components.sync.protocol.NigoriSpecifics parseFrom(
      com.google.protobuf.ByteString data)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, data);
  }
  public static org.chromium.components.sync.protocol.NigoriSpecifics parseFrom(
      com.google.protobuf.ByteString data,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, data, extensionRegistry);
  }
  public static org.chromium.components.sync.protocol.NigoriSpecifics parseFrom(byte[] data)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, data);
  }
  public static org.chromium.components.sync.protocol.NigoriSpecifics parseFrom(
      byte[] data,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, data, extensionRegistry);
  }
  public static org.chromium.components.sync.protocol.NigoriSpecifics parseFrom(java.io.InputStream input)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, input);
  }
  public static org.chromium.components.sync.protocol.NigoriSpecifics parseFrom(
      java.io.InputStream input,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, input, extensionRegistry);
  }
  public static org.chromium.components.sync.protocol.NigoriSpecifics parseDelimitedFrom(java.io.InputStream input)
      throws java.io.IOException {
    return parseDelimitedFrom(DEFAULT_INSTANCE, input);
  }
  public static org.chromium.components.sync.protocol.NigoriSpecifics parseDelimitedFrom(
      java.io.InputStream input,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws java.io.IOException {
    return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
  }
  public static org.chromium.components.sync.protocol.NigoriSpecifics parseFrom(
      com.google.protobuf.CodedInputStream input)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, input);
  }
  public static org.chromium.components.sync.protocol.NigoriSpecifics parseFrom(
      com.google.protobuf.CodedInputStream input,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, input, extensionRegistry);
  }

  public static Builder newBuilder() {
    return DEFAULT_INSTANCE.toBuilder();
  }
  public static Builder newBuilder(org.chromium.components.sync.protocol.NigoriSpecifics prototype) {
    return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
  }

  /**
   * <pre>
   * Properties of nigori sync object.
   * </pre>
   *
   * Protobuf type {@code sync_pb.NigoriSpecifics}
   */
  public static final class Builder extends
      com.google.protobuf.GeneratedMessageLite.Builder<
        org.chromium.components.sync.protocol.NigoriSpecifics, Builder> implements
      // @@protoc_insertion_point(builder_implements:sync_pb.NigoriSpecifics)
      org.chromium.components.sync.protocol.NigoriSpecificsOrBuilder {
    // Construct using org.chromium.components.sync.protocol.NigoriSpecifics.newBuilder()
    private Builder() {
      super(DEFAULT_INSTANCE);
    }


    /**
     * <code>optional .sync_pb.EncryptedData encryption_keybag = 1;</code>
     */
    public boolean hasEncryptionKeybag() {
      return instance.hasEncryptionKeybag();
    }
    /**
     * <code>optional .sync_pb.EncryptedData encryption_keybag = 1;</code>
     */
    public org.chromium.components.sync.protocol.EncryptedData getEncryptionKeybag() {
      return instance.getEncryptionKeybag();
    }
    /**
     * <code>optional .sync_pb.EncryptedData encryption_keybag = 1;</code>
     */
    public Builder setEncryptionKeybag(org.chromium.components.sync.protocol.EncryptedData value) {
      copyOnWrite();
      instance.setEncryptionKeybag(value);
      return this;
      }
    /**
     * <code>optional .sync_pb.EncryptedData encryption_keybag = 1;</code>
     */
    public Builder setEncryptionKeybag(
        org.chromium.components.sync.protocol.EncryptedData.Builder builderForValue) {
      copyOnWrite();
      instance.setEncryptionKeybag(builderForValue);
      return this;
    }
    /**
     * <code>optional .sync_pb.EncryptedData encryption_keybag = 1;</code>
     */
    public Builder mergeEncryptionKeybag(org.chromium.components.sync.protocol.EncryptedData value) {
      copyOnWrite();
      instance.mergeEncryptionKeybag(value);
      return this;
    }
    /**
     * <code>optional .sync_pb.EncryptedData encryption_keybag = 1;</code>
     */
    public Builder clearEncryptionKeybag() {  copyOnWrite();
      instance.clearEncryptionKeybag();
      return this;
    }

    /**
     * <pre>
     * Once keystore migration is performed, we have to freeze the keybag so that
     * older clients (that don't support keystore encryption) do not attempt to
     * update the keybag.
     * Previously |using_explicit_passphrase|.
     * </pre>
     *
     * <code>optional bool keybag_is_frozen = 2;</code>
     */
    public boolean hasKeybagIsFrozen() {
      return instance.hasKeybagIsFrozen();
    }
    /**
     * <pre>
     * Once keystore migration is performed, we have to freeze the keybag so that
     * older clients (that don't support keystore encryption) do not attempt to
     * update the keybag.
     * Previously |using_explicit_passphrase|.
     * </pre>
     *
     * <code>optional bool keybag_is_frozen = 2;</code>
     */
    public boolean getKeybagIsFrozen() {
      return instance.getKeybagIsFrozen();
    }
    /**
     * <pre>
     * Once keystore migration is performed, we have to freeze the keybag so that
     * older clients (that don't support keystore encryption) do not attempt to
     * update the keybag.
     * Previously |using_explicit_passphrase|.
     * </pre>
     *
     * <code>optional bool keybag_is_frozen = 2;</code>
     */
    public Builder setKeybagIsFrozen(boolean value) {
      copyOnWrite();
      instance.setKeybagIsFrozen(value);
      return this;
    }
    /**
     * <pre>
     * Once keystore migration is performed, we have to freeze the keybag so that
     * older clients (that don't support keystore encryption) do not attempt to
     * update the keybag.
     * Previously |using_explicit_passphrase|.
     * </pre>
     *
     * <code>optional bool keybag_is_frozen = 2;</code>
     */
    public Builder clearKeybagIsFrozen() {
      copyOnWrite();
      instance.clearKeybagIsFrozen();
      return this;
    }

    /**
     * <pre>
     * Booleans corresponding to whether a datatype should be encrypted.
     * Passwords and Wi-Fi configurations are always encrypted, so we don't need
     * a field here.  History delete directives need to be consumable by the
     * server, and thus can't be encrypted.
     * </pre>
     *
     * <code>optional bool encrypt_bookmarks = 13;</code>
     */
    public boolean hasEncryptBookmarks() {
      return instance.hasEncryptBookmarks();
    }
    /**
     * <pre>
     * Booleans corresponding to whether a datatype should be encrypted.
     * Passwords and Wi-Fi configurations are always encrypted, so we don't need
     * a field here.  History delete directives need to be consumable by the
     * server, and thus can't be encrypted.
     * </pre>
     *
     * <code>optional bool encrypt_bookmarks = 13;</code>
     */
    public boolean getEncryptBookmarks() {
      return instance.getEncryptBookmarks();
    }
    /**
     * <pre>
     * Booleans corresponding to whether a datatype should be encrypted.
     * Passwords and Wi-Fi configurations are always encrypted, so we don't need
     * a field here.  History delete directives need to be consumable by the
     * server, and thus can't be encrypted.
     * </pre>
     *
     * <code>optional bool encrypt_bookmarks = 13;</code>
     */
    public Builder setEncryptBookmarks(boolean value) {
      copyOnWrite();
      instance.setEncryptBookmarks(value);
      return this;
    }
    /**
     * <pre>
     * Booleans corresponding to whether a datatype should be encrypted.
     * Passwords and Wi-Fi configurations are always encrypted, so we don't need
     * a field here.  History delete directives need to be consumable by the
     * server, and thus can't be encrypted.
     * </pre>
     *
     * <code>optional bool encrypt_bookmarks = 13;</code>
     */
    public Builder clearEncryptBookmarks() {
      copyOnWrite();
      instance.clearEncryptBookmarks();
      return this;
    }

    /**
     * <code>optional bool encrypt_preferences = 14;</code>
     */
    public boolean hasEncryptPreferences() {
      return instance.hasEncryptPreferences();
    }
    /**
     * <code>optional bool encrypt_preferences = 14;</code>
     */
    public boolean getEncryptPreferences() {
      return instance.getEncryptPreferences();
    }
    /**
     * <code>optional bool encrypt_preferences = 14;</code>
     */
    public Builder setEncryptPreferences(boolean value) {
      copyOnWrite();
      instance.setEncryptPreferences(value);
      return this;
    }
    /**
     * <code>optional bool encrypt_preferences = 14;</code>
     */
    public Builder clearEncryptPreferences() {
      copyOnWrite();
      instance.clearEncryptPreferences();
      return this;
    }

    /**
     * <code>optional bool encrypt_autofill_profile = 15;</code>
     */
    public boolean hasEncryptAutofillProfile() {
      return instance.hasEncryptAutofillProfile();
    }
    /**
     * <code>optional bool encrypt_autofill_profile = 15;</code>
     */
    public boolean getEncryptAutofillProfile() {
      return instance.getEncryptAutofillProfile();
    }
    /**
     * <code>optional bool encrypt_autofill_profile = 15;</code>
     */
    public Builder setEncryptAutofillProfile(boolean value) {
      copyOnWrite();
      instance.setEncryptAutofillProfile(value);
      return this;
    }
    /**
     * <code>optional bool encrypt_autofill_profile = 15;</code>
     */
    public Builder clearEncryptAutofillProfile() {
      copyOnWrite();
      instance.clearEncryptAutofillProfile();
      return this;
    }

    /**
     * <code>optional bool encrypt_autofill = 16;</code>
     */
    public boolean hasEncryptAutofill() {
      return instance.hasEncryptAutofill();
    }
    /**
     * <code>optional bool encrypt_autofill = 16;</code>
     */
    public boolean getEncryptAutofill() {
      return instance.getEncryptAutofill();
    }
    /**
     * <code>optional bool encrypt_autofill = 16;</code>
     */
    public Builder setEncryptAutofill(boolean value) {
      copyOnWrite();
      instance.setEncryptAutofill(value);
      return this;
    }
    /**
     * <code>optional bool encrypt_autofill = 16;</code>
     */
    public Builder clearEncryptAutofill() {
      copyOnWrite();
      instance.clearEncryptAutofill();
      return this;
    }

    /**
     * <code>optional bool encrypt_themes = 17;</code>
     */
    public boolean hasEncryptThemes() {
      return instance.hasEncryptThemes();
    }
    /**
     * <code>optional bool encrypt_themes = 17;</code>
     */
    public boolean getEncryptThemes() {
      return instance.getEncryptThemes();
    }
    /**
     * <code>optional bool encrypt_themes = 17;</code>
     */
    public Builder setEncryptThemes(boolean value) {
      copyOnWrite();
      instance.setEncryptThemes(value);
      return this;
    }
    /**
     * <code>optional bool encrypt_themes = 17;</code>
     */
    public Builder clearEncryptThemes() {
      copyOnWrite();
      instance.clearEncryptThemes();
      return this;
    }

    /**
     * <code>optional bool encrypt_typed_urls = 18;</code>
     */
    public boolean hasEncryptTypedUrls() {
      return instance.hasEncryptTypedUrls();
    }
    /**
     * <code>optional bool encrypt_typed_urls = 18;</code>
     */
    public boolean getEncryptTypedUrls() {
      return instance.getEncryptTypedUrls();
    }
    /**
     * <code>optional bool encrypt_typed_urls = 18;</code>
     */
    public Builder setEncryptTypedUrls(boolean value) {
      copyOnWrite();
      instance.setEncryptTypedUrls(value);
      return this;
    }
    /**
     * <code>optional bool encrypt_typed_urls = 18;</code>
     */
    public Builder clearEncryptTypedUrls() {
      copyOnWrite();
      instance.clearEncryptTypedUrls();
      return this;
    }

    /**
     * <code>optional bool encrypt_extensions = 19;</code>
     */
    public boolean hasEncryptExtensions() {
      return instance.hasEncryptExtensions();
    }
    /**
     * <code>optional bool encrypt_extensions = 19;</code>
     */
    public boolean getEncryptExtensions() {
      return instance.getEncryptExtensions();
    }
    /**
     * <code>optional bool encrypt_extensions = 19;</code>
     */
    public Builder setEncryptExtensions(boolean value) {
      copyOnWrite();
      instance.setEncryptExtensions(value);
      return this;
    }
    /**
     * <code>optional bool encrypt_extensions = 19;</code>
     */
    public Builder clearEncryptExtensions() {
      copyOnWrite();
      instance.clearEncryptExtensions();
      return this;
    }

    /**
     * <code>optional bool encrypt_sessions = 20;</code>
     */
    public boolean hasEncryptSessions() {
      return instance.hasEncryptSessions();
    }
    /**
     * <code>optional bool encrypt_sessions = 20;</code>
     */
    public boolean getEncryptSessions() {
      return instance.getEncryptSessions();
    }
    /**
     * <code>optional bool encrypt_sessions = 20;</code>
     */
    public Builder setEncryptSessions(boolean value) {
      copyOnWrite();
      instance.setEncryptSessions(value);
      return this;
    }
    /**
     * <code>optional bool encrypt_sessions = 20;</code>
     */
    public Builder clearEncryptSessions() {
      copyOnWrite();
      instance.clearEncryptSessions();
      return this;
    }

    /**
     * <code>optional bool encrypt_apps = 21;</code>
     */
    public boolean hasEncryptApps() {
      return instance.hasEncryptApps();
    }
    /**
     * <code>optional bool encrypt_apps = 21;</code>
     */
    public boolean getEncryptApps() {
      return instance.getEncryptApps();
    }
    /**
     * <code>optional bool encrypt_apps = 21;</code>
     */
    public Builder setEncryptApps(boolean value) {
      copyOnWrite();
      instance.setEncryptApps(value);
      return this;
    }
    /**
     * <code>optional bool encrypt_apps = 21;</code>
     */
    public Builder clearEncryptApps() {
      copyOnWrite();
      instance.clearEncryptApps();
      return this;
    }

    /**
     * <code>optional bool encrypt_search_engines = 22;</code>
     */
    public boolean hasEncryptSearchEngines() {
      return instance.hasEncryptSearchEngines();
    }
    /**
     * <code>optional bool encrypt_search_engines = 22;</code>
     */
    public boolean getEncryptSearchEngines() {
      return instance.getEncryptSearchEngines();
    }
    /**
     * <code>optional bool encrypt_search_engines = 22;</code>
     */
    public Builder setEncryptSearchEngines(boolean value) {
      copyOnWrite();
      instance.setEncryptSearchEngines(value);
      return this;
    }
    /**
     * <code>optional bool encrypt_search_engines = 22;</code>
     */
    public Builder clearEncryptSearchEngines() {
      copyOnWrite();
      instance.clearEncryptSearchEngines();
      return this;
    }

    /**
     * <pre>
     * If true, all current and future datatypes will be encrypted.
     * </pre>
     *
     * <code>optional bool encrypt_everything = 24;</code>
     */
    public boolean hasEncryptEverything() {
      return instance.hasEncryptEverything();
    }
    /**
     * <pre>
     * If true, all current and future datatypes will be encrypted.
     * </pre>
     *
     * <code>optional bool encrypt_everything = 24;</code>
     */
    public boolean getEncryptEverything() {
      return instance.getEncryptEverything();
    }
    /**
     * <pre>
     * If true, all current and future datatypes will be encrypted.
     * </pre>
     *
     * <code>optional bool encrypt_everything = 24;</code>
     */
    public Builder setEncryptEverything(boolean value) {
      copyOnWrite();
      instance.setEncryptEverything(value);
      return this;
    }
    /**
     * <pre>
     * If true, all current and future datatypes will be encrypted.
     * </pre>
     *
     * <code>optional bool encrypt_everything = 24;</code>
     */
    public Builder clearEncryptEverything() {
      copyOnWrite();
      instance.clearEncryptEverything();
      return this;
    }

    /**
     * <code>optional bool encrypt_extension_settings = 25;</code>
     */
    public boolean hasEncryptExtensionSettings() {
      return instance.hasEncryptExtensionSettings();
    }
    /**
     * <code>optional bool encrypt_extension_settings = 25;</code>
     */
    public boolean getEncryptExtensionSettings() {
      return instance.getEncryptExtensionSettings();
    }
    /**
     * <code>optional bool encrypt_extension_settings = 25;</code>
     */
    public Builder setEncryptExtensionSettings(boolean value) {
      copyOnWrite();
      instance.setEncryptExtensionSettings(value);
      return this;
    }
    /**
     * <code>optional bool encrypt_extension_settings = 25;</code>
     */
    public Builder clearEncryptExtensionSettings() {
      copyOnWrite();
      instance.clearEncryptExtensionSettings();
      return this;
    }

    /**
     * <code>optional bool encrypt_app_notifications = 26 [deprecated = true];</code>
     */
    @java.lang.Deprecated public boolean hasEncryptAppNotifications() {
      return instance.hasEncryptAppNotifications();
    }
    /**
     * <code>optional bool encrypt_app_notifications = 26 [deprecated = true];</code>
     */
    @java.lang.Deprecated public boolean getEncryptAppNotifications() {
      return instance.getEncryptAppNotifications();
    }
    /**
     * <code>optional bool encrypt_app_notifications = 26 [deprecated = true];</code>
     */
    @java.lang.Deprecated public Builder setEncryptAppNotifications(boolean value) {
      copyOnWrite();
      instance.setEncryptAppNotifications(value);
      return this;
    }
    /**
     * <code>optional bool encrypt_app_notifications = 26 [deprecated = true];</code>
     */
    @java.lang.Deprecated public Builder clearEncryptAppNotifications() {
      copyOnWrite();
      instance.clearEncryptAppNotifications();
      return this;
    }

    /**
     * <code>optional bool encrypt_app_settings = 27;</code>
     */
    public boolean hasEncryptAppSettings() {
      return instance.hasEncryptAppSettings();
    }
    /**
     * <code>optional bool encrypt_app_settings = 27;</code>
     */
    public boolean getEncryptAppSettings() {
      return instance.getEncryptAppSettings();
    }
    /**
     * <code>optional bool encrypt_app_settings = 27;</code>
     */
    public Builder setEncryptAppSettings(boolean value) {
      copyOnWrite();
      instance.setEncryptAppSettings(value);
      return this;
    }
    /**
     * <code>optional bool encrypt_app_settings = 27;</code>
     */
    public Builder clearEncryptAppSettings() {
      copyOnWrite();
      instance.clearEncryptAppSettings();
      return this;
    }

    /**
     * <pre>
     * Enable syncing favicons as part of tab sync.
     * </pre>
     *
     * <code>optional bool sync_tab_favicons = 29;</code>
     */
    public boolean hasSyncTabFavicons() {
      return instance.hasSyncTabFavicons();
    }
    /**
     * <pre>
     * Enable syncing favicons as part of tab sync.
     * </pre>
     *
     * <code>optional bool sync_tab_favicons = 29;</code>
     */
    public boolean getSyncTabFavicons() {
      return instance.getSyncTabFavicons();
    }
    /**
     * <pre>
     * Enable syncing favicons as part of tab sync.
     * </pre>
     *
     * <code>optional bool sync_tab_favicons = 29;</code>
     */
    public Builder setSyncTabFavicons(boolean value) {
      copyOnWrite();
      instance.setSyncTabFavicons(value);
      return this;
    }
    /**
     * <pre>
     * Enable syncing favicons as part of tab sync.
     * </pre>
     *
     * <code>optional bool sync_tab_favicons = 29;</code>
     */
    public Builder clearSyncTabFavicons() {
      copyOnWrite();
      instance.clearSyncTabFavicons();
      return this;
    }

    /**
     * <pre>
     * An |int| field is used instead of enum PassphraseType so we can better
     * handle unknown values coming from later versions. Prior to M77, this was an
     * enum so old clients will assume IMPLICIT_PASSPHRASE for values greater than
     * 4.
     * </pre>
     *
     * <code>optional int32 passphrase_type = 30 [default = 1];</code>
     */
    public boolean hasPassphraseType() {
      return instance.hasPassphraseType();
    }
    /**
     * <pre>
     * An |int| field is used instead of enum PassphraseType so we can better
     * handle unknown values coming from later versions. Prior to M77, this was an
     * enum so old clients will assume IMPLICIT_PASSPHRASE for values greater than
     * 4.
     * </pre>
     *
     * <code>optional int32 passphrase_type = 30 [default = 1];</code>
     */
    public int getPassphraseType() {
      return instance.getPassphraseType();
    }
    /**
     * <pre>
     * An |int| field is used instead of enum PassphraseType so we can better
     * handle unknown values coming from later versions. Prior to M77, this was an
     * enum so old clients will assume IMPLICIT_PASSPHRASE for values greater than
     * 4.
     * </pre>
     *
     * <code>optional int32 passphrase_type = 30 [default = 1];</code>
     */
    public Builder setPassphraseType(int value) {
      copyOnWrite();
      instance.setPassphraseType(value);
      return this;
    }
    /**
     * <pre>
     * An |int| field is used instead of enum PassphraseType so we can better
     * handle unknown values coming from later versions. Prior to M77, this was an
     * enum so old clients will assume IMPLICIT_PASSPHRASE for values greater than
     * 4.
     * </pre>
     *
     * <code>optional int32 passphrase_type = 30 [default = 1];</code>
     */
    public Builder clearPassphraseType() {
      copyOnWrite();
      instance.clearPassphraseType();
      return this;
    }

    /**
     * <pre>
     * The keystore decryptor token blob. Encrypted with the keystore key, and
     * contains the encryption key used to decrypt |encryption_keybag|.
     * Only set if passphrase_state == KEYSTORE_PASSPHRASE.
     * </pre>
     *
     * <code>optional .sync_pb.EncryptedData keystore_decryptor_token = 31;</code>
     */
    public boolean hasKeystoreDecryptorToken() {
      return instance.hasKeystoreDecryptorToken();
    }
    /**
     * <pre>
     * The keystore decryptor token blob. Encrypted with the keystore key, and
     * contains the encryption key used to decrypt |encryption_keybag|.
     * Only set if passphrase_state == KEYSTORE_PASSPHRASE.
     * </pre>
     *
     * <code>optional .sync_pb.EncryptedData keystore_decryptor_token = 31;</code>
     */
    public org.chromium.components.sync.protocol.EncryptedData getKeystoreDecryptorToken() {
      return instance.getKeystoreDecryptorToken();
    }
    /**
     * <pre>
     * The keystore decryptor token blob. Encrypted with the keystore key, and
     * contains the encryption key used to decrypt |encryption_keybag|.
     * Only set if passphrase_state == KEYSTORE_PASSPHRASE.
     * </pre>
     *
     * <code>optional .sync_pb.EncryptedData keystore_decryptor_token = 31;</code>
     */
    public Builder setKeystoreDecryptorToken(org.chromium.components.sync.protocol.EncryptedData value) {
      copyOnWrite();
      instance.setKeystoreDecryptorToken(value);
      return this;
      }
    /**
     * <pre>
     * The keystore decryptor token blob. Encrypted with the keystore key, and
     * contains the encryption key used to decrypt |encryption_keybag|.
     * Only set if passphrase_state == KEYSTORE_PASSPHRASE.
     * </pre>
     *
     * <code>optional .sync_pb.EncryptedData keystore_decryptor_token = 31;</code>
     */
    public Builder setKeystoreDecryptorToken(
        org.chromium.components.sync.protocol.EncryptedData.Builder builderForValue) {
      copyOnWrite();
      instance.setKeystoreDecryptorToken(builderForValue);
      return this;
    }
    /**
     * <pre>
     * The keystore decryptor token blob. Encrypted with the keystore key, and
     * contains the encryption key used to decrypt |encryption_keybag|.
     * Only set if passphrase_state == KEYSTORE_PASSPHRASE.
     * </pre>
     *
     * <code>optional .sync_pb.EncryptedData keystore_decryptor_token = 31;</code>
     */
    public Builder mergeKeystoreDecryptorToken(org.chromium.components.sync.protocol.EncryptedData value) {
      copyOnWrite();
      instance.mergeKeystoreDecryptorToken(value);
      return this;
    }
    /**
     * <pre>
     * The keystore decryptor token blob. Encrypted with the keystore key, and
     * contains the encryption key used to decrypt |encryption_keybag|.
     * Only set if passphrase_state == KEYSTORE_PASSPHRASE.
     * </pre>
     *
     * <code>optional .sync_pb.EncryptedData keystore_decryptor_token = 31;</code>
     */
    public Builder clearKeystoreDecryptorToken() {  copyOnWrite();
      instance.clearKeystoreDecryptorToken();
      return this;
    }

    /**
     * <pre>
     * The time (in epoch milliseconds) at which the keystore migration was
     * performed.
     * </pre>
     *
     * <code>optional int64 keystore_migration_time = 32;</code>
     */
    public boolean hasKeystoreMigrationTime() {
      return instance.hasKeystoreMigrationTime();
    }
    /**
     * <pre>
     * The time (in epoch milliseconds) at which the keystore migration was
     * performed.
     * </pre>
     *
     * <code>optional int64 keystore_migration_time = 32;</code>
     */
    public long getKeystoreMigrationTime() {
      return instance.getKeystoreMigrationTime();
    }
    /**
     * <pre>
     * The time (in epoch milliseconds) at which the keystore migration was
     * performed.
     * </pre>
     *
     * <code>optional int64 keystore_migration_time = 32;</code>
     */
    public Builder setKeystoreMigrationTime(long value) {
      copyOnWrite();
      instance.setKeystoreMigrationTime(value);
      return this;
    }
    /**
     * <pre>
     * The time (in epoch milliseconds) at which the keystore migration was
     * performed.
     * </pre>
     *
     * <code>optional int64 keystore_migration_time = 32;</code>
     */
    public Builder clearKeystoreMigrationTime() {
      copyOnWrite();
      instance.clearKeystoreMigrationTime();
      return this;
    }

    /**
     * <pre>
     * The time (in epoch milliseconds) at which a custom passphrase was set.
     * Note: this field may not be set if the custom passphrase was applied before
     * this field was introduced.
     * </pre>
     *
     * <code>optional int64 custom_passphrase_time = 33;</code>
     */
    public boolean hasCustomPassphraseTime() {
      return instance.hasCustomPassphraseTime();
    }
    /**
     * <pre>
     * The time (in epoch milliseconds) at which a custom passphrase was set.
     * Note: this field may not be set if the custom passphrase was applied before
     * this field was introduced.
     * </pre>
     *
     * <code>optional int64 custom_passphrase_time = 33;</code>
     */
    public long getCustomPassphraseTime() {
      return instance.getCustomPassphraseTime();
    }
    /**
     * <pre>
     * The time (in epoch milliseconds) at which a custom passphrase was set.
     * Note: this field may not be set if the custom passphrase was applied before
     * this field was introduced.
     * </pre>
     *
     * <code>optional int64 custom_passphrase_time = 33;</code>
     */
    public Builder setCustomPassphraseTime(long value) {
      copyOnWrite();
      instance.setCustomPassphraseTime(value);
      return this;
    }
    /**
     * <pre>
     * The time (in epoch milliseconds) at which a custom passphrase was set.
     * Note: this field may not be set if the custom passphrase was applied before
     * this field was introduced.
     * </pre>
     *
     * <code>optional int64 custom_passphrase_time = 33;</code>
     */
    public Builder clearCustomPassphraseTime() {
      copyOnWrite();
      instance.clearCustomPassphraseTime();
      return this;
    }

    /**
     * <pre>
     * Boolean corresponding to whether custom spelling dictionary should be
     * encrypted.
     * </pre>
     *
     * <code>optional bool encrypt_dictionary = 34;</code>
     */
    public boolean hasEncryptDictionary() {
      return instance.hasEncryptDictionary();
    }
    /**
     * <pre>
     * Boolean corresponding to whether custom spelling dictionary should be
     * encrypted.
     * </pre>
     *
     * <code>optional bool encrypt_dictionary = 34;</code>
     */
    public boolean getEncryptDictionary() {
      return instance.getEncryptDictionary();
    }
    /**
     * <pre>
     * Boolean corresponding to whether custom spelling dictionary should be
     * encrypted.
     * </pre>
     *
     * <code>optional bool encrypt_dictionary = 34;</code>
     */
    public Builder setEncryptDictionary(boolean value) {
      copyOnWrite();
      instance.setEncryptDictionary(value);
      return this;
    }
    /**
     * <pre>
     * Boolean corresponding to whether custom spelling dictionary should be
     * encrypted.
     * </pre>
     *
     * <code>optional bool encrypt_dictionary = 34;</code>
     */
    public Builder clearEncryptDictionary() {
      copyOnWrite();
      instance.clearEncryptDictionary();
      return this;
    }

    /**
     * <pre>
     * Boolean corresponding to Whether to encrypt favicons data or not.
     * </pre>
     *
     * <code>optional bool encrypt_favicon_images = 35;</code>
     */
    public boolean hasEncryptFaviconImages() {
      return instance.hasEncryptFaviconImages();
    }
    /**
     * <pre>
     * Boolean corresponding to Whether to encrypt favicons data or not.
     * </pre>
     *
     * <code>optional bool encrypt_favicon_images = 35;</code>
     */
    public boolean getEncryptFaviconImages() {
      return instance.getEncryptFaviconImages();
    }
    /**
     * <pre>
     * Boolean corresponding to Whether to encrypt favicons data or not.
     * </pre>
     *
     * <code>optional bool encrypt_favicon_images = 35;</code>
     */
    public Builder setEncryptFaviconImages(boolean value) {
      copyOnWrite();
      instance.setEncryptFaviconImages(value);
      return this;
    }
    /**
     * <pre>
     * Boolean corresponding to Whether to encrypt favicons data or not.
     * </pre>
     *
     * <code>optional bool encrypt_favicon_images = 35;</code>
     */
    public Builder clearEncryptFaviconImages() {
      copyOnWrite();
      instance.clearEncryptFaviconImages();
      return this;
    }

    /**
     * <code>optional bool encrypt_favicon_tracking = 36;</code>
     */
    public boolean hasEncryptFaviconTracking() {
      return instance.hasEncryptFaviconTracking();
    }
    /**
     * <code>optional bool encrypt_favicon_tracking = 36;</code>
     */
    public boolean getEncryptFaviconTracking() {
      return instance.getEncryptFaviconTracking();
    }
    /**
     * <code>optional bool encrypt_favicon_tracking = 36;</code>
     */
    public Builder setEncryptFaviconTracking(boolean value) {
      copyOnWrite();
      instance.setEncryptFaviconTracking(value);
      return this;
    }
    /**
     * <code>optional bool encrypt_favicon_tracking = 36;</code>
     */
    public Builder clearEncryptFaviconTracking() {
      copyOnWrite();
      instance.clearEncryptFaviconTracking();
      return this;
    }

    /**
     * <pre>
     * Boolean corresponding to whether app list items should be encrypted.
     * </pre>
     *
     * <code>optional bool encrypt_app_list = 38;</code>
     */
    public boolean hasEncryptAppList() {
      return instance.hasEncryptAppList();
    }
    /**
     * <pre>
     * Boolean corresponding to whether app list items should be encrypted.
     * </pre>
     *
     * <code>optional bool encrypt_app_list = 38;</code>
     */
    public boolean getEncryptAppList() {
      return instance.getEncryptAppList();
    }
    /**
     * <pre>
     * Boolean corresponding to whether app list items should be encrypted.
     * </pre>
     *
     * <code>optional bool encrypt_app_list = 38;</code>
     */
    public Builder setEncryptAppList(boolean value) {
      copyOnWrite();
      instance.setEncryptAppList(value);
      return this;
    }
    /**
     * <pre>
     * Boolean corresponding to whether app list items should be encrypted.
     * </pre>
     *
     * <code>optional bool encrypt_app_list = 38;</code>
     */
    public Builder clearEncryptAppList() {
      copyOnWrite();
      instance.clearEncryptAppList();
      return this;
    }

    /**
     * <pre>
     * Boolean corresponding to whether usage count and last use date of Wallet
     * data should be encrypted.
     * </pre>
     *
     * <code>optional bool encrypt_autofill_wallet_metadata = 39;</code>
     */
    public boolean hasEncryptAutofillWalletMetadata() {
      return instance.hasEncryptAutofillWalletMetadata();
    }
    /**
     * <pre>
     * Boolean corresponding to whether usage count and last use date of Wallet
     * data should be encrypted.
     * </pre>
     *
     * <code>optional bool encrypt_autofill_wallet_metadata = 39;</code>
     */
    public boolean getEncryptAutofillWalletMetadata() {
      return instance.getEncryptAutofillWalletMetadata();
    }
    /**
     * <pre>
     * Boolean corresponding to whether usage count and last use date of Wallet
     * data should be encrypted.
     * </pre>
     *
     * <code>optional bool encrypt_autofill_wallet_metadata = 39;</code>
     */
    public Builder setEncryptAutofillWalletMetadata(boolean value) {
      copyOnWrite();
      instance.setEncryptAutofillWalletMetadata(value);
      return this;
    }
    /**
     * <pre>
     * Boolean corresponding to whether usage count and last use date of Wallet
     * data should be encrypted.
     * </pre>
     *
     * <code>optional bool encrypt_autofill_wallet_metadata = 39;</code>
     */
    public Builder clearEncryptAutofillWalletMetadata() {
      copyOnWrite();
      instance.clearEncryptAutofillWalletMetadata();
      return this;
    }

    /**
     * <pre>
     * Boolean indicating whether this node was originally missing a
     * |keystore_migration_time| field value, and was fixed on the server by
     * giving the field a value.
     * THIS FIELD SHOULD ONLY BE SET BY THE SERVER.
     * </pre>
     *
     * <code>optional bool server_only_was_missing_keystore_migration_time = 40;</code>
     */
    public boolean hasServerOnlyWasMissingKeystoreMigrationTime() {
      return instance.hasServerOnlyWasMissingKeystoreMigrationTime();
    }
    /**
     * <pre>
     * Boolean indicating whether this node was originally missing a
     * |keystore_migration_time| field value, and was fixed on the server by
     * giving the field a value.
     * THIS FIELD SHOULD ONLY BE SET BY THE SERVER.
     * </pre>
     *
     * <code>optional bool server_only_was_missing_keystore_migration_time = 40;</code>
     */
    public boolean getServerOnlyWasMissingKeystoreMigrationTime() {
      return instance.getServerOnlyWasMissingKeystoreMigrationTime();
    }
    /**
     * <pre>
     * Boolean indicating whether this node was originally missing a
     * |keystore_migration_time| field value, and was fixed on the server by
     * giving the field a value.
     * THIS FIELD SHOULD ONLY BE SET BY THE SERVER.
     * </pre>
     *
     * <code>optional bool server_only_was_missing_keystore_migration_time = 40;</code>
     */
    public Builder setServerOnlyWasMissingKeystoreMigrationTime(boolean value) {
      copyOnWrite();
      instance.setServerOnlyWasMissingKeystoreMigrationTime(value);
      return this;
    }
    /**
     * <pre>
     * Boolean indicating whether this node was originally missing a
     * |keystore_migration_time| field value, and was fixed on the server by
     * giving the field a value.
     * THIS FIELD SHOULD ONLY BE SET BY THE SERVER.
     * </pre>
     *
     * <code>optional bool server_only_was_missing_keystore_migration_time = 40;</code>
     */
    public Builder clearServerOnlyWasMissingKeystoreMigrationTime() {
      copyOnWrite();
      instance.clearServerOnlyWasMissingKeystoreMigrationTime();
      return this;
    }

    /**
     * <pre>
     * Boolean corresponding to whether arc pakcage items should be encrypted.
     * </pre>
     *
     * <code>optional bool encrypt_arc_package = 41;</code>
     */
    public boolean hasEncryptArcPackage() {
      return instance.hasEncryptArcPackage();
    }
    /**
     * <pre>
     * Boolean corresponding to whether arc pakcage items should be encrypted.
     * </pre>
     *
     * <code>optional bool encrypt_arc_package = 41;</code>
     */
    public boolean getEncryptArcPackage() {
      return instance.getEncryptArcPackage();
    }
    /**
     * <pre>
     * Boolean corresponding to whether arc pakcage items should be encrypted.
     * </pre>
     *
     * <code>optional bool encrypt_arc_package = 41;</code>
     */
    public Builder setEncryptArcPackage(boolean value) {
      copyOnWrite();
      instance.setEncryptArcPackage(value);
      return this;
    }
    /**
     * <pre>
     * Boolean corresponding to whether arc pakcage items should be encrypted.
     * </pre>
     *
     * <code>optional bool encrypt_arc_package = 41;</code>
     */
    public Builder clearEncryptArcPackage() {
      copyOnWrite();
      instance.clearEncryptArcPackage();
      return this;
    }

    /**
     * <pre>
     * Boolean corresponding to whether printer items should be encrypted.
     * </pre>
     *
     * <code>optional bool encrypt_printers = 42;</code>
     */
    public boolean hasEncryptPrinters() {
      return instance.hasEncryptPrinters();
    }
    /**
     * <pre>
     * Boolean corresponding to whether printer items should be encrypted.
     * </pre>
     *
     * <code>optional bool encrypt_printers = 42;</code>
     */
    public boolean getEncryptPrinters() {
      return instance.getEncryptPrinters();
    }
    /**
     * <pre>
     * Boolean corresponding to whether printer items should be encrypted.
     * </pre>
     *
     * <code>optional bool encrypt_printers = 42;</code>
     */
    public Builder setEncryptPrinters(boolean value) {
      copyOnWrite();
      instance.setEncryptPrinters(value);
      return this;
    }
    /**
     * <pre>
     * Boolean corresponding to whether printer items should be encrypted.
     * </pre>
     *
     * <code>optional bool encrypt_printers = 42;</code>
     */
    public Builder clearEncryptPrinters() {
      copyOnWrite();
      instance.clearEncryptPrinters();
      return this;
    }

    /**
     * <pre>
     * Boolean corresponding to whether reading list items should be encrypted.
     * </pre>
     *
     * <code>optional bool encrypt_reading_list = 43;</code>
     */
    public boolean hasEncryptReadingList() {
      return instance.hasEncryptReadingList();
    }
    /**
     * <pre>
     * Boolean corresponding to whether reading list items should be encrypted.
     * </pre>
     *
     * <code>optional bool encrypt_reading_list = 43;</code>
     */
    public boolean getEncryptReadingList() {
      return instance.getEncryptReadingList();
    }
    /**
     * <pre>
     * Boolean corresponding to whether reading list items should be encrypted.
     * </pre>
     *
     * <code>optional bool encrypt_reading_list = 43;</code>
     */
    public Builder setEncryptReadingList(boolean value) {
      copyOnWrite();
      instance.setEncryptReadingList(value);
      return this;
    }
    /**
     * <pre>
     * Boolean corresponding to whether reading list items should be encrypted.
     * </pre>
     *
     * <code>optional bool encrypt_reading_list = 43;</code>
     */
    public Builder clearEncryptReadingList() {
      copyOnWrite();
      instance.clearEncryptReadingList();
      return this;
    }

    /**
     * <pre>
     * ID of the method used to derive the encryption key from a custom
     * passphrase. Should be set only when |passphrase_type| is CUSTOM_PASSPHRASE
     * and only based on CustomPassphraseKeyDerivationMethod. This field has been
     * added in M70. All previous versions just ignore it, attempt to use
     * PBKDF2_HMAC_SHA1_1003 and, thus, reject any passphrase if a different
     * method has been used. The default corresponds to UNSPECIFIED. An |int|
     * field is used so we can detect unknown values coming from later versions.
     * </pre>
     *
     * <code>optional int32 custom_passphrase_key_derivation_method = 45 [default = 0];</code>
     */
    public boolean hasCustomPassphraseKeyDerivationMethod() {
      return instance.hasCustomPassphraseKeyDerivationMethod();
    }
    /**
     * <pre>
     * ID of the method used to derive the encryption key from a custom
     * passphrase. Should be set only when |passphrase_type| is CUSTOM_PASSPHRASE
     * and only based on CustomPassphraseKeyDerivationMethod. This field has been
     * added in M70. All previous versions just ignore it, attempt to use
     * PBKDF2_HMAC_SHA1_1003 and, thus, reject any passphrase if a different
     * method has been used. The default corresponds to UNSPECIFIED. An |int|
     * field is used so we can detect unknown values coming from later versions.
     * </pre>
     *
     * <code>optional int32 custom_passphrase_key_derivation_method = 45 [default = 0];</code>
     */
    public int getCustomPassphraseKeyDerivationMethod() {
      return instance.getCustomPassphraseKeyDerivationMethod();
    }
    /**
     * <pre>
     * ID of the method used to derive the encryption key from a custom
     * passphrase. Should be set only when |passphrase_type| is CUSTOM_PASSPHRASE
     * and only based on CustomPassphraseKeyDerivationMethod. This field has been
     * added in M70. All previous versions just ignore it, attempt to use
     * PBKDF2_HMAC_SHA1_1003 and, thus, reject any passphrase if a different
     * method has been used. The default corresponds to UNSPECIFIED. An |int|
     * field is used so we can detect unknown values coming from later versions.
     * </pre>
     *
     * <code>optional int32 custom_passphrase_key_derivation_method = 45 [default = 0];</code>
     */
    public Builder setCustomPassphraseKeyDerivationMethod(int value) {
      copyOnWrite();
      instance.setCustomPassphraseKeyDerivationMethod(value);
      return this;
    }
    /**
     * <pre>
     * ID of the method used to derive the encryption key from a custom
     * passphrase. Should be set only when |passphrase_type| is CUSTOM_PASSPHRASE
     * and only based on CustomPassphraseKeyDerivationMethod. This field has been
     * added in M70. All previous versions just ignore it, attempt to use
     * PBKDF2_HMAC_SHA1_1003 and, thus, reject any passphrase if a different
     * method has been used. The default corresponds to UNSPECIFIED. An |int|
     * field is used so we can detect unknown values coming from later versions.
     * </pre>
     *
     * <code>optional int32 custom_passphrase_key_derivation_method = 45 [default = 0];</code>
     */
    public Builder clearCustomPassphraseKeyDerivationMethod() {
      copyOnWrite();
      instance.clearCustomPassphraseKeyDerivationMethod();
      return this;
    }

    /**
     * <pre>
     * Base64-encoded salt used for the derivation of the key from the custom
     * passphrase. Valid only if custom_passphrase_key_derivation_method ==
     * SCRYPT_8192_8_11, ignored in other cases.
     * </pre>
     *
     * <code>optional string custom_passphrase_key_derivation_salt = 46;</code>
     */
    public boolean hasCustomPassphraseKeyDerivationSalt() {
      return instance.hasCustomPassphraseKeyDerivationSalt();
    }
    /**
     * <pre>
     * Base64-encoded salt used for the derivation of the key from the custom
     * passphrase. Valid only if custom_passphrase_key_derivation_method ==
     * SCRYPT_8192_8_11, ignored in other cases.
     * </pre>
     *
     * <code>optional string custom_passphrase_key_derivation_salt = 46;</code>
     */
    public java.lang.String getCustomPassphraseKeyDerivationSalt() {
      return instance.getCustomPassphraseKeyDerivationSalt();
    }
    /**
     * <pre>
     * Base64-encoded salt used for the derivation of the key from the custom
     * passphrase. Valid only if custom_passphrase_key_derivation_method ==
     * SCRYPT_8192_8_11, ignored in other cases.
     * </pre>
     *
     * <code>optional string custom_passphrase_key_derivation_salt = 46;</code>
     */
    public com.google.protobuf.ByteString
        getCustomPassphraseKeyDerivationSaltBytes() {
      return instance.getCustomPassphraseKeyDerivationSaltBytes();
    }
    /**
     * <pre>
     * Base64-encoded salt used for the derivation of the key from the custom
     * passphrase. Valid only if custom_passphrase_key_derivation_method ==
     * SCRYPT_8192_8_11, ignored in other cases.
     * </pre>
     *
     * <code>optional string custom_passphrase_key_derivation_salt = 46;</code>
     */
    public Builder setCustomPassphraseKeyDerivationSalt(
        java.lang.String value) {
      copyOnWrite();
      instance.setCustomPassphraseKeyDerivationSalt(value);
      return this;
    }
    /**
     * <pre>
     * Base64-encoded salt used for the derivation of the key from the custom
     * passphrase. Valid only if custom_passphrase_key_derivation_method ==
     * SCRYPT_8192_8_11, ignored in other cases.
     * </pre>
     *
     * <code>optional string custom_passphrase_key_derivation_salt = 46;</code>
     */
    public Builder clearCustomPassphraseKeyDerivationSalt() {
      copyOnWrite();
      instance.clearCustomPassphraseKeyDerivationSalt();
      return this;
    }
    /**
     * <pre>
     * Base64-encoded salt used for the derivation of the key from the custom
     * passphrase. Valid only if custom_passphrase_key_derivation_method ==
     * SCRYPT_8192_8_11, ignored in other cases.
     * </pre>
     *
     * <code>optional string custom_passphrase_key_derivation_salt = 46;</code>
     */
    public Builder setCustomPassphraseKeyDerivationSaltBytes(
        com.google.protobuf.ByteString value) {
      copyOnWrite();
      instance.setCustomPassphraseKeyDerivationSaltBytes(value);
      return this;
    }

    /**
     * <pre>
     * Boolean corresponding to whether send tab should be encrypted.
     * </pre>
     *
     * <code>optional bool encrypt_send_tab_to_self = 47;</code>
     */
    public boolean hasEncryptSendTabToSelf() {
      return instance.hasEncryptSendTabToSelf();
    }
    /**
     * <pre>
     * Boolean corresponding to whether send tab should be encrypted.
     * </pre>
     *
     * <code>optional bool encrypt_send_tab_to_self = 47;</code>
     */
    public boolean getEncryptSendTabToSelf() {
      return instance.getEncryptSendTabToSelf();
    }
    /**
     * <pre>
     * Boolean corresponding to whether send tab should be encrypted.
     * </pre>
     *
     * <code>optional bool encrypt_send_tab_to_self = 47;</code>
     */
    public Builder setEncryptSendTabToSelf(boolean value) {
      copyOnWrite();
      instance.setEncryptSendTabToSelf(value);
      return this;
    }
    /**
     * <pre>
     * Boolean corresponding to whether send tab should be encrypted.
     * </pre>
     *
     * <code>optional bool encrypt_send_tab_to_self = 47;</code>
     */
    public Builder clearEncryptSendTabToSelf() {
      copyOnWrite();
      instance.clearEncryptSendTabToSelf();
      return this;
    }

    /**
     * <pre>
     * Boolean corresponding to whether Web Apps data should be encrypted.
     * </pre>
     *
     * <code>optional bool encrypt_web_apps = 48;</code>
     */
    public boolean hasEncryptWebApps() {
      return instance.hasEncryptWebApps();
    }
    /**
     * <pre>
     * Boolean corresponding to whether Web Apps data should be encrypted.
     * </pre>
     *
     * <code>optional bool encrypt_web_apps = 48;</code>
     */
    public boolean getEncryptWebApps() {
      return instance.getEncryptWebApps();
    }
    /**
     * <pre>
     * Boolean corresponding to whether Web Apps data should be encrypted.
     * </pre>
     *
     * <code>optional bool encrypt_web_apps = 48;</code>
     */
    public Builder setEncryptWebApps(boolean value) {
      copyOnWrite();
      instance.setEncryptWebApps(value);
      return this;
    }
    /**
     * <pre>
     * Boolean corresponding to whether Web Apps data should be encrypted.
     * </pre>
     *
     * <code>optional bool encrypt_web_apps = 48;</code>
     */
    public Builder clearEncryptWebApps() {
      copyOnWrite();
      instance.clearEncryptWebApps();
      return this;
    }

    /**
     * <pre>
     * Boolean corresponding to whether OS preferences should be encrypted.
     * </pre>
     *
     * <code>optional bool encrypt_os_preferences = 49;</code>
     */
    public boolean hasEncryptOsPreferences() {
      return instance.hasEncryptOsPreferences();
    }
    /**
     * <pre>
     * Boolean corresponding to whether OS preferences should be encrypted.
     * </pre>
     *
     * <code>optional bool encrypt_os_preferences = 49;</code>
     */
    public boolean getEncryptOsPreferences() {
      return instance.getEncryptOsPreferences();
    }
    /**
     * <pre>
     * Boolean corresponding to whether OS preferences should be encrypted.
     * </pre>
     *
     * <code>optional bool encrypt_os_preferences = 49;</code>
     */
    public Builder setEncryptOsPreferences(boolean value) {
      copyOnWrite();
      instance.setEncryptOsPreferences(value);
      return this;
    }
    /**
     * <pre>
     * Boolean corresponding to whether OS preferences should be encrypted.
     * </pre>
     *
     * <code>optional bool encrypt_os_preferences = 49;</code>
     */
    public Builder clearEncryptOsPreferences() {
      copyOnWrite();
      instance.clearEncryptOsPreferences();
      return this;
    }

    // @@protoc_insertion_point(builder_scope:sync_pb.NigoriSpecifics)
  }
  protected final Object dynamicMethod(
      com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
      Object arg0, Object arg1) {
    switch (method) {
      case NEW_MUTABLE_INSTANCE: {
        return new org.chromium.components.sync.protocol.NigoriSpecifics();
      }
      case IS_INITIALIZED: {
        return DEFAULT_INSTANCE;
      }
      case MAKE_IMMUTABLE: {
        return null;
      }
      case NEW_BUILDER: {
        return new Builder();
      }
      case VISIT: {
        Visitor visitor = (Visitor) arg0;
        org.chromium.components.sync.protocol.NigoriSpecifics other = (org.chromium.components.sync.protocol.NigoriSpecifics) arg1;
        encryptionKeybag_ = visitor.visitMessage(encryptionKeybag_, other.encryptionKeybag_);
        keybagIsFrozen_ = visitor.visitBoolean(
            hasKeybagIsFrozen(), keybagIsFrozen_,
            other.hasKeybagIsFrozen(), other.keybagIsFrozen_);
        encryptBookmarks_ = visitor.visitBoolean(
            hasEncryptBookmarks(), encryptBookmarks_,
            other.hasEncryptBookmarks(), other.encryptBookmarks_);
        encryptPreferences_ = visitor.visitBoolean(
            hasEncryptPreferences(), encryptPreferences_,
            other.hasEncryptPreferences(), other.encryptPreferences_);
        encryptAutofillProfile_ = visitor.visitBoolean(
            hasEncryptAutofillProfile(), encryptAutofillProfile_,
            other.hasEncryptAutofillProfile(), other.encryptAutofillProfile_);
        encryptAutofill_ = visitor.visitBoolean(
            hasEncryptAutofill(), encryptAutofill_,
            other.hasEncryptAutofill(), other.encryptAutofill_);
        encryptThemes_ = visitor.visitBoolean(
            hasEncryptThemes(), encryptThemes_,
            other.hasEncryptThemes(), other.encryptThemes_);
        encryptTypedUrls_ = visitor.visitBoolean(
            hasEncryptTypedUrls(), encryptTypedUrls_,
            other.hasEncryptTypedUrls(), other.encryptTypedUrls_);
        encryptExtensions_ = visitor.visitBoolean(
            hasEncryptExtensions(), encryptExtensions_,
            other.hasEncryptExtensions(), other.encryptExtensions_);
        encryptSessions_ = visitor.visitBoolean(
            hasEncryptSessions(), encryptSessions_,
            other.hasEncryptSessions(), other.encryptSessions_);
        encryptApps_ = visitor.visitBoolean(
            hasEncryptApps(), encryptApps_,
            other.hasEncryptApps(), other.encryptApps_);
        encryptSearchEngines_ = visitor.visitBoolean(
            hasEncryptSearchEngines(), encryptSearchEngines_,
            other.hasEncryptSearchEngines(), other.encryptSearchEngines_);
        encryptEverything_ = visitor.visitBoolean(
            hasEncryptEverything(), encryptEverything_,
            other.hasEncryptEverything(), other.encryptEverything_);
        encryptExtensionSettings_ = visitor.visitBoolean(
            hasEncryptExtensionSettings(), encryptExtensionSettings_,
            other.hasEncryptExtensionSettings(), other.encryptExtensionSettings_);
        encryptAppNotifications_ = visitor.visitBoolean(
            hasEncryptAppNotifications(), encryptAppNotifications_,
            other.hasEncryptAppNotifications(), other.encryptAppNotifications_);
        encryptAppSettings_ = visitor.visitBoolean(
            hasEncryptAppSettings(), encryptAppSettings_,
            other.hasEncryptAppSettings(), other.encryptAppSettings_);
        syncTabFavicons_ = visitor.visitBoolean(
            hasSyncTabFavicons(), syncTabFavicons_,
            other.hasSyncTabFavicons(), other.syncTabFavicons_);
        passphraseType_ = visitor.visitInt(
            hasPassphraseType(), passphraseType_,
            other.hasPassphraseType(), other.passphraseType_);
        keystoreDecryptorToken_ = visitor.visitMessage(keystoreDecryptorToken_, other.keystoreDecryptorToken_);
        keystoreMigrationTime_ = visitor.visitLong(
            hasKeystoreMigrationTime(), keystoreMigrationTime_,
            other.hasKeystoreMigrationTime(), other.keystoreMigrationTime_);
        customPassphraseTime_ = visitor.visitLong(
            hasCustomPassphraseTime(), customPassphraseTime_,
            other.hasCustomPassphraseTime(), other.customPassphraseTime_);
        encryptDictionary_ = visitor.visitBoolean(
            hasEncryptDictionary(), encryptDictionary_,
            other.hasEncryptDictionary(), other.encryptDictionary_);
        encryptFaviconImages_ = visitor.visitBoolean(
            hasEncryptFaviconImages(), encryptFaviconImages_,
            other.hasEncryptFaviconImages(), other.encryptFaviconImages_);
        encryptFaviconTracking_ = visitor.visitBoolean(
            hasEncryptFaviconTracking(), encryptFaviconTracking_,
            other.hasEncryptFaviconTracking(), other.encryptFaviconTracking_);
        encryptAppList_ = visitor.visitBoolean(
            hasEncryptAppList(), encryptAppList_,
            other.hasEncryptAppList(), other.encryptAppList_);
        encryptAutofillWalletMetadata_ = visitor.visitBoolean(
            hasEncryptAutofillWalletMetadata(), encryptAutofillWalletMetadata_,
            other.hasEncryptAutofillWalletMetadata(), other.encryptAutofillWalletMetadata_);
        serverOnlyWasMissingKeystoreMigrationTime_ = visitor.visitBoolean(
            hasServerOnlyWasMissingKeystoreMigrationTime(), serverOnlyWasMissingKeystoreMigrationTime_,
            other.hasServerOnlyWasMissingKeystoreMigrationTime(), other.serverOnlyWasMissingKeystoreMigrationTime_);
        encryptArcPackage_ = visitor.visitBoolean(
            hasEncryptArcPackage(), encryptArcPackage_,
            other.hasEncryptArcPackage(), other.encryptArcPackage_);
        encryptPrinters_ = visitor.visitBoolean(
            hasEncryptPrinters(), encryptPrinters_,
            other.hasEncryptPrinters(), other.encryptPrinters_);
        encryptReadingList_ = visitor.visitBoolean(
            hasEncryptReadingList(), encryptReadingList_,
            other.hasEncryptReadingList(), other.encryptReadingList_);
        customPassphraseKeyDerivationMethod_ = visitor.visitInt(
            hasCustomPassphraseKeyDerivationMethod(), customPassphraseKeyDerivationMethod_,
            other.hasCustomPassphraseKeyDerivationMethod(), other.customPassphraseKeyDerivationMethod_);
        customPassphraseKeyDerivationSalt_ = visitor.visitString(
            hasCustomPassphraseKeyDerivationSalt(), customPassphraseKeyDerivationSalt_,
            other.hasCustomPassphraseKeyDerivationSalt(), other.customPassphraseKeyDerivationSalt_);
        encryptSendTabToSelf_ = visitor.visitBoolean(
            hasEncryptSendTabToSelf(), encryptSendTabToSelf_,
            other.hasEncryptSendTabToSelf(), other.encryptSendTabToSelf_);
        encryptWebApps_ = visitor.visitBoolean(
            hasEncryptWebApps(), encryptWebApps_,
            other.hasEncryptWebApps(), other.encryptWebApps_);
        encryptOsPreferences_ = visitor.visitBoolean(
            hasEncryptOsPreferences(), encryptOsPreferences_,
            other.hasEncryptOsPreferences(), other.encryptOsPreferences_);
        if (visitor == com.google.protobuf.GeneratedMessageLite.MergeFromVisitor
            .INSTANCE) {
          bitField0_ |= other.bitField0_;
          bitField1_ |= other.bitField1_;
        }
        return this;
      }
      case MERGE_FROM_STREAM: {
        com.google.protobuf.CodedInputStream input =
            (com.google.protobuf.CodedInputStream) arg0;
        com.google.protobuf.ExtensionRegistryLite extensionRegistry =
            (com.google.protobuf.ExtensionRegistryLite) arg1;
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              default: {
                if (!parseUnknownField(tag, input)) {
                  done = true;
                }
                break;
              }
              case 10: {
                org.chromium.components.sync.protocol.EncryptedData.Builder subBuilder = null;
                if (((bitField0_ & 0x00000001) == 0x00000001)) {
                  subBuilder = encryptionKeybag_.toBuilder();
                }
                encryptionKeybag_ = input.readMessage(org.chromium.components.sync.protocol.EncryptedData.parser(), extensionRegistry);
                if (subBuilder != null) {
                  subBuilder.mergeFrom(encryptionKeybag_);
                  encryptionKeybag_ = subBuilder.buildPartial();
                }
                bitField0_ |= 0x00000001;
                break;
              }
              case 16: {
                bitField0_ |= 0x00000002;
                keybagIsFrozen_ = input.readBool();
                break;
              }
              case 104: {
                bitField0_ |= 0x00000004;
                encryptBookmarks_ = input.readBool();
                break;
              }
              case 112: {
                bitField0_ |= 0x00000008;
                encryptPreferences_ = input.readBool();
                break;
              }
              case 120: {
                bitField0_ |= 0x00000010;
                encryptAutofillProfile_ = input.readBool();
                break;
              }
              case 128: {
                bitField0_ |= 0x00000020;
                encryptAutofill_ = input.readBool();
                break;
              }
              case 136: {
                bitField0_ |= 0x00000040;
                encryptThemes_ = input.readBool();
                break;
              }
              case 144: {
                bitField0_ |= 0x00000080;
                encryptTypedUrls_ = input.readBool();
                break;
              }
              case 152: {
                bitField0_ |= 0x00000100;
                encryptExtensions_ = input.readBool();
                break;
              }
              case 160: {
                bitField0_ |= 0x00000200;
                encryptSessions_ = input.readBool();
                break;
              }
              case 168: {
                bitField0_ |= 0x00000400;
                encryptApps_ = input.readBool();
                break;
              }
              case 176: {
                bitField0_ |= 0x00000800;
                encryptSearchEngines_ = input.readBool();
                break;
              }
              case 192: {
                bitField0_ |= 0x00001000;
                encryptEverything_ = input.readBool();
                break;
              }
              case 200: {
                bitField0_ |= 0x00002000;
                encryptExtensionSettings_ = input.readBool();
                break;
              }
              case 208: {
                bitField0_ |= 0x00004000;
                encryptAppNotifications_ = input.readBool();
                break;
              }
              case 216: {
                bitField0_ |= 0x00008000;
                encryptAppSettings_ = input.readBool();
                break;
              }
              case 232: {
                bitField0_ |= 0x00010000;
                syncTabFavicons_ = input.readBool();
                break;
              }
              case 240: {
                bitField0_ |= 0x00020000;
                passphraseType_ = input.readInt32();
                break;
              }
              case 250: {
                org.chromium.components.sync.protocol.EncryptedData.Builder subBuilder = null;
                if (((bitField0_ & 0x00040000) == 0x00040000)) {
                  subBuilder = keystoreDecryptorToken_.toBuilder();
                }
                keystoreDecryptorToken_ = input.readMessage(org.chromium.components.sync.protocol.EncryptedData.parser(), extensionRegistry);
                if (subBuilder != null) {
                  subBuilder.mergeFrom(keystoreDecryptorToken_);
                  keystoreDecryptorToken_ = subBuilder.buildPartial();
                }
                bitField0_ |= 0x00040000;
                break;
              }
              case 256: {
                bitField0_ |= 0x00080000;
                keystoreMigrationTime_ = input.readInt64();
                break;
              }
              case 264: {
                bitField0_ |= 0x00100000;
                customPassphraseTime_ = input.readInt64();
                break;
              }
              case 272: {
                bitField0_ |= 0x00200000;
                encryptDictionary_ = input.readBool();
                break;
              }
              case 280: {
                bitField0_ |= 0x00400000;
                encryptFaviconImages_ = input.readBool();
                break;
              }
              case 288: {
                bitField0_ |= 0x00800000;
                encryptFaviconTracking_ = input.readBool();
                break;
              }
              case 304: {
                bitField0_ |= 0x01000000;
                encryptAppList_ = input.readBool();
                break;
              }
              case 312: {
                bitField0_ |= 0x02000000;
                encryptAutofillWalletMetadata_ = input.readBool();
                break;
              }
              case 320: {
                bitField0_ |= 0x04000000;
                serverOnlyWasMissingKeystoreMigrationTime_ = input.readBool();
                break;
              }
              case 328: {
                bitField0_ |= 0x08000000;
                encryptArcPackage_ = input.readBool();
                break;
              }
              case 336: {
                bitField0_ |= 0x10000000;
                encryptPrinters_ = input.readBool();
                break;
              }
              case 344: {
                bitField0_ |= 0x20000000;
                encryptReadingList_ = input.readBool();
                break;
              }
              case 360: {
                bitField0_ |= 0x40000000;
                customPassphraseKeyDerivationMethod_ = input.readInt32();
                break;
              }
              case 370: {
                String s = input.readString();
                bitField0_ |= 0x80000000;
                customPassphraseKeyDerivationSalt_ = s;
                break;
              }
              case 376: {
                bitField1_ |= 0x00000001;
                encryptSendTabToSelf_ = input.readBool();
                break;
              }
              case 384: {
                bitField1_ |= 0x00000002;
                encryptWebApps_ = input.readBool();
                break;
              }
              case 392: {
                bitField1_ |= 0x00000004;
                encryptOsPreferences_ = input.readBool();
                break;
              }
            }
          }
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw new RuntimeException(e.setUnfinishedMessage(this));
        } catch (java.io.IOException e) {
          throw new RuntimeException(
              new com.google.protobuf.InvalidProtocolBufferException(
                  e.getMessage()).setUnfinishedMessage(this));
        } finally {
        }
      }
      case GET_DEFAULT_INSTANCE: {
        return DEFAULT_INSTANCE;
      }
      case GET_PARSER: {
        if (PARSER == null) {    synchronized (org.chromium.components.sync.protocol.NigoriSpecifics.class) {
            if (PARSER == null) {
              PARSER = new DefaultInstanceBasedParser(DEFAULT_INSTANCE);
            }
          }
        }
        return PARSER;
      }
    }
    throw new UnsupportedOperationException();
  }


  // @@protoc_insertion_point(class_scope:sync_pb.NigoriSpecifics)
  private static final org.chromium.components.sync.protocol.NigoriSpecifics DEFAULT_INSTANCE;
  static {
    DEFAULT_INSTANCE = new NigoriSpecifics();
    DEFAULT_INSTANCE.makeImmutable();
  }

  public static org.chromium.components.sync.protocol.NigoriSpecifics getDefaultInstance() {
    return DEFAULT_INSTANCE;
  }

  private static volatile com.google.protobuf.Parser<NigoriSpecifics> PARSER;

  public static com.google.protobuf.Parser<NigoriSpecifics> parser() {
    return DEFAULT_INSTANCE.getParserForType();
  }
}

