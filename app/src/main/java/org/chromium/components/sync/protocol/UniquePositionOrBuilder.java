// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: unique_position.proto

package org.chromium.components.sync.protocol;

public interface UniquePositionOrBuilder extends
    // @@protoc_insertion_point(interface_extends:sync_pb.UniquePosition)
    com.google.protobuf.MessageLiteOrBuilder {

  /**
   * <pre>
   * The uncompressed string of bytes representing the position.
   * Deprecated.  See history note above.
   * </pre>
   *
   * <code>optional bytes value = 1;</code>
   */
  boolean hasValue();
  /**
   * <pre>
   * The uncompressed string of bytes representing the position.
   * Deprecated.  See history note above.
   * </pre>
   *
   * <code>optional bytes value = 1;</code>
   */
  com.google.protobuf.ByteString getValue();

  /**
   * <pre>
   * The client may choose to write a compressed position to this field instead
   * of populating the 'value' above.  If it chooses to use compression, the
   * 'value' field above must be empty.  The position value will be compressed
   * with gzip and stored in the compressed_value field.  The position's
   * uncompressed length must be specified and written to the
   * uncompressed_length field.
   * Deprecated.  See history note above.
   * </pre>
   *
   * <code>optional bytes compressed_value = 2;</code>
   */
  boolean hasCompressedValue();
  /**
   * <pre>
   * The client may choose to write a compressed position to this field instead
   * of populating the 'value' above.  If it chooses to use compression, the
   * 'value' field above must be empty.  The position value will be compressed
   * with gzip and stored in the compressed_value field.  The position's
   * uncompressed length must be specified and written to the
   * uncompressed_length field.
   * Deprecated.  See history note above.
   * </pre>
   *
   * <code>optional bytes compressed_value = 2;</code>
   */
  com.google.protobuf.ByteString getCompressedValue();

  /**
   * <code>optional uint64 uncompressed_length = 3;</code>
   */
  boolean hasUncompressedLength();
  /**
   * <code>optional uint64 uncompressed_length = 3;</code>
   */
  long getUncompressedLength();

  /**
   * <pre>
   * This encoding uses compression scheme designed especially for unique
   * positions.  It has the property that X &lt; Y precisely when Compressed(X) &lt;
   * Compressed(Y), which is very useful when the most common operation is to
   * compare these positions against each other.  Their values may remain
   * compressed in memory.
   * The compression scheme is implemented and documented in
   * sync/core_impl/base/unique_position.cc.
   * As of M30, this is the preferred encoding.  Newer clients may continue to
   * populate the 'value' and 'compressed_value' fields to ensure backwards
   * compatibility, but they will always try to read from this field first.
   * </pre>
   *
   * <code>optional bytes custom_compressed_v1 = 4;</code>
   */
  boolean hasCustomCompressedV1();
  /**
   * <pre>
   * This encoding uses compression scheme designed especially for unique
   * positions.  It has the property that X &lt; Y precisely when Compressed(X) &lt;
   * Compressed(Y), which is very useful when the most common operation is to
   * compare these positions against each other.  Their values may remain
   * compressed in memory.
   * The compression scheme is implemented and documented in
   * sync/core_impl/base/unique_position.cc.
   * As of M30, this is the preferred encoding.  Newer clients may continue to
   * populate the 'value' and 'compressed_value' fields to ensure backwards
   * compatibility, but they will always try to read from this field first.
   * </pre>
   *
   * <code>optional bytes custom_compressed_v1 = 4;</code>
   */
  com.google.protobuf.ByteString getCustomCompressedV1();
}
