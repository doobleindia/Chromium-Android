// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: entity_metadata.proto

package org.chromium.components.sync.protocol;

/**
 * <pre>
 * Sync proto to store entity metadata in model type storage.
 * </pre>
 *
 * Protobuf type {@code sync_pb.EntityMetadata}
 */
public  final class EntityMetadata extends
    com.google.protobuf.GeneratedMessageLite<
        EntityMetadata, EntityMetadata.Builder> implements
    // @@protoc_insertion_point(message_implements:sync_pb.EntityMetadata)
    EntityMetadataOrBuilder {
  private EntityMetadata() {
    clientTagHash_ = "";
    serverId_ = "";
    serverVersion_ = -1L;
    specificsHash_ = "";
    baseSpecificsHash_ = "";
  }
  private int bitField0_;
  public static final int CLIENT_TAG_HASH_FIELD_NUMBER = 1;
  private java.lang.String clientTagHash_;
  /**
   * <pre>
   * A hash based on the client tag and model type.
   * Used for various map lookups. Should always be available.
   * Sent to the server as SyncEntity::client_defined_unique_tag.
   * </pre>
   *
   * <code>optional string client_tag_hash = 1;</code>
   */
  public boolean hasClientTagHash() {
    return ((bitField0_ & 0x00000001) == 0x00000001);
  }
  /**
   * <pre>
   * A hash based on the client tag and model type.
   * Used for various map lookups. Should always be available.
   * Sent to the server as SyncEntity::client_defined_unique_tag.
   * </pre>
   *
   * <code>optional string client_tag_hash = 1;</code>
   */
  public java.lang.String getClientTagHash() {
    return clientTagHash_;
  }
  /**
   * <pre>
   * A hash based on the client tag and model type.
   * Used for various map lookups. Should always be available.
   * Sent to the server as SyncEntity::client_defined_unique_tag.
   * </pre>
   *
   * <code>optional string client_tag_hash = 1;</code>
   */
  public com.google.protobuf.ByteString
      getClientTagHashBytes() {
    return com.google.protobuf.ByteString.copyFromUtf8(clientTagHash_);
  }
  /**
   * <pre>
   * A hash based on the client tag and model type.
   * Used for various map lookups. Should always be available.
   * Sent to the server as SyncEntity::client_defined_unique_tag.
   * </pre>
   *
   * <code>optional string client_tag_hash = 1;</code>
   */
  private void setClientTagHash(
      java.lang.String value) {
    if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000001;
    clientTagHash_ = value;
  }
  /**
   * <pre>
   * A hash based on the client tag and model type.
   * Used for various map lookups. Should always be available.
   * Sent to the server as SyncEntity::client_defined_unique_tag.
   * </pre>
   *
   * <code>optional string client_tag_hash = 1;</code>
   */
  private void clearClientTagHash() {
    bitField0_ = (bitField0_ & ~0x00000001);
    clientTagHash_ = getDefaultInstance().getClientTagHash();
  }
  /**
   * <pre>
   * A hash based on the client tag and model type.
   * Used for various map lookups. Should always be available.
   * Sent to the server as SyncEntity::client_defined_unique_tag.
   * </pre>
   *
   * <code>optional string client_tag_hash = 1;</code>
   */
  private void setClientTagHashBytes(
      com.google.protobuf.ByteString value) {
    if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000001;
    clientTagHash_ = value.toStringUtf8();
  }

  public static final int SERVER_ID_FIELD_NUMBER = 2;
  private java.lang.String serverId_;
  /**
   * <pre>
   * The entity's server-assigned ID.
   * Prior to the item's first commit, we leave this value as an empty string.
   * The initial ID for a newly created item has to meet certain uniqueness
   * requirements, and we handle those on the sync thread.
   * </pre>
   *
   * <code>optional string server_id = 2;</code>
   */
  public boolean hasServerId() {
    return ((bitField0_ & 0x00000002) == 0x00000002);
  }
  /**
   * <pre>
   * The entity's server-assigned ID.
   * Prior to the item's first commit, we leave this value as an empty string.
   * The initial ID for a newly created item has to meet certain uniqueness
   * requirements, and we handle those on the sync thread.
   * </pre>
   *
   * <code>optional string server_id = 2;</code>
   */
  public java.lang.String getServerId() {
    return serverId_;
  }
  /**
   * <pre>
   * The entity's server-assigned ID.
   * Prior to the item's first commit, we leave this value as an empty string.
   * The initial ID for a newly created item has to meet certain uniqueness
   * requirements, and we handle those on the sync thread.
   * </pre>
   *
   * <code>optional string server_id = 2;</code>
   */
  public com.google.protobuf.ByteString
      getServerIdBytes() {
    return com.google.protobuf.ByteString.copyFromUtf8(serverId_);
  }
  /**
   * <pre>
   * The entity's server-assigned ID.
   * Prior to the item's first commit, we leave this value as an empty string.
   * The initial ID for a newly created item has to meet certain uniqueness
   * requirements, and we handle those on the sync thread.
   * </pre>
   *
   * <code>optional string server_id = 2;</code>
   */
  private void setServerId(
      java.lang.String value) {
    if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000002;
    serverId_ = value;
  }
  /**
   * <pre>
   * The entity's server-assigned ID.
   * Prior to the item's first commit, we leave this value as an empty string.
   * The initial ID for a newly created item has to meet certain uniqueness
   * requirements, and we handle those on the sync thread.
   * </pre>
   *
   * <code>optional string server_id = 2;</code>
   */
  private void clearServerId() {
    bitField0_ = (bitField0_ & ~0x00000002);
    serverId_ = getDefaultInstance().getServerId();
  }
  /**
   * <pre>
   * The entity's server-assigned ID.
   * Prior to the item's first commit, we leave this value as an empty string.
   * The initial ID for a newly created item has to meet certain uniqueness
   * requirements, and we handle those on the sync thread.
   * </pre>
   *
   * <code>optional string server_id = 2;</code>
   */
  private void setServerIdBytes(
      com.google.protobuf.ByteString value) {
    if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000002;
    serverId_ = value.toStringUtf8();
  }

  public static final int IS_DELETED_FIELD_NUMBER = 3;
  private boolean isDeleted_;
  /**
   * <pre>
   * Whether or not the entity is deleted.
   * </pre>
   *
   * <code>optional bool is_deleted = 3;</code>
   */
  public boolean hasIsDeleted() {
    return ((bitField0_ & 0x00000004) == 0x00000004);
  }
  /**
   * <pre>
   * Whether or not the entity is deleted.
   * </pre>
   *
   * <code>optional bool is_deleted = 3;</code>
   */
  public boolean getIsDeleted() {
    return isDeleted_;
  }
  /**
   * <pre>
   * Whether or not the entity is deleted.
   * </pre>
   *
   * <code>optional bool is_deleted = 3;</code>
   */
  private void setIsDeleted(boolean value) {
    bitField0_ |= 0x00000004;
    isDeleted_ = value;
  }
  /**
   * <pre>
   * Whether or not the entity is deleted.
   * </pre>
   *
   * <code>optional bool is_deleted = 3;</code>
   */
  private void clearIsDeleted() {
    bitField0_ = (bitField0_ & ~0x00000004);
    isDeleted_ = false;
  }

  public static final int SEQUENCE_NUMBER_FIELD_NUMBER = 4;
  private long sequenceNumber_;
  /**
   * <pre>
   * A version number used to track in-progress commits. Each local change
   * increments this number.
   * </pre>
   *
   * <code>optional int64 sequence_number = 4;</code>
   */
  public boolean hasSequenceNumber() {
    return ((bitField0_ & 0x00000008) == 0x00000008);
  }
  /**
   * <pre>
   * A version number used to track in-progress commits. Each local change
   * increments this number.
   * </pre>
   *
   * <code>optional int64 sequence_number = 4;</code>
   */
  public long getSequenceNumber() {
    return sequenceNumber_;
  }
  /**
   * <pre>
   * A version number used to track in-progress commits. Each local change
   * increments this number.
   * </pre>
   *
   * <code>optional int64 sequence_number = 4;</code>
   */
  private void setSequenceNumber(long value) {
    bitField0_ |= 0x00000008;
    sequenceNumber_ = value;
  }
  /**
   * <pre>
   * A version number used to track in-progress commits. Each local change
   * increments this number.
   * </pre>
   *
   * <code>optional int64 sequence_number = 4;</code>
   */
  private void clearSequenceNumber() {
    bitField0_ = (bitField0_ & ~0x00000008);
    sequenceNumber_ = 0L;
  }

  public static final int ACKED_SEQUENCE_NUMBER_FIELD_NUMBER = 5;
  private long ackedSequenceNumber_;
  /**
   * <pre>
   * The sequence number of the last item known to be successfully committed.
   * </pre>
   *
   * <code>optional int64 acked_sequence_number = 5;</code>
   */
  public boolean hasAckedSequenceNumber() {
    return ((bitField0_ & 0x00000010) == 0x00000010);
  }
  /**
   * <pre>
   * The sequence number of the last item known to be successfully committed.
   * </pre>
   *
   * <code>optional int64 acked_sequence_number = 5;</code>
   */
  public long getAckedSequenceNumber() {
    return ackedSequenceNumber_;
  }
  /**
   * <pre>
   * The sequence number of the last item known to be successfully committed.
   * </pre>
   *
   * <code>optional int64 acked_sequence_number = 5;</code>
   */
  private void setAckedSequenceNumber(long value) {
    bitField0_ |= 0x00000010;
    ackedSequenceNumber_ = value;
  }
  /**
   * <pre>
   * The sequence number of the last item known to be successfully committed.
   * </pre>
   *
   * <code>optional int64 acked_sequence_number = 5;</code>
   */
  private void clearAckedSequenceNumber() {
    bitField0_ = (bitField0_ & ~0x00000010);
    ackedSequenceNumber_ = 0L;
  }

  public static final int SERVER_VERSION_FIELD_NUMBER = 6;
  private long serverVersion_;
  /**
   * <pre>
   * The server version on which this item is based.
   * If there are no local changes, this is the version of the entity as we see
   * it here.
   * If there are local changes, this is the version of the entity on which
   * those changes are based.
   * </pre>
   *
   * <code>optional int64 server_version = 6 [default = -1];</code>
   */
  public boolean hasServerVersion() {
    return ((bitField0_ & 0x00000020) == 0x00000020);
  }
  /**
   * <pre>
   * The server version on which this item is based.
   * If there are no local changes, this is the version of the entity as we see
   * it here.
   * If there are local changes, this is the version of the entity on which
   * those changes are based.
   * </pre>
   *
   * <code>optional int64 server_version = 6 [default = -1];</code>
   */
  public long getServerVersion() {
    return serverVersion_;
  }
  /**
   * <pre>
   * The server version on which this item is based.
   * If there are no local changes, this is the version of the entity as we see
   * it here.
   * If there are local changes, this is the version of the entity on which
   * those changes are based.
   * </pre>
   *
   * <code>optional int64 server_version = 6 [default = -1];</code>
   */
  private void setServerVersion(long value) {
    bitField0_ |= 0x00000020;
    serverVersion_ = value;
  }
  /**
   * <pre>
   * The server version on which this item is based.
   * If there are no local changes, this is the version of the entity as we see
   * it here.
   * If there are local changes, this is the version of the entity on which
   * those changes are based.
   * </pre>
   *
   * <code>optional int64 server_version = 6 [default = -1];</code>
   */
  private void clearServerVersion() {
    bitField0_ = (bitField0_ & ~0x00000020);
    serverVersion_ = -1L;
  }

  public static final int CREATION_TIME_FIELD_NUMBER = 7;
  private long creationTime_;
  /**
   * <pre>
   * Entity creation and modification timestamps. Assigned by the client and
   * synced by the server, though the server usually doesn't bother to inspect
   * their values. They are encoded as milliseconds since the Unix epoch.
   * </pre>
   *
   * <code>optional int64 creation_time = 7;</code>
   */
  public boolean hasCreationTime() {
    return ((bitField0_ & 0x00000040) == 0x00000040);
  }
  /**
   * <pre>
   * Entity creation and modification timestamps. Assigned by the client and
   * synced by the server, though the server usually doesn't bother to inspect
   * their values. They are encoded as milliseconds since the Unix epoch.
   * </pre>
   *
   * <code>optional int64 creation_time = 7;</code>
   */
  public long getCreationTime() {
    return creationTime_;
  }
  /**
   * <pre>
   * Entity creation and modification timestamps. Assigned by the client and
   * synced by the server, though the server usually doesn't bother to inspect
   * their values. They are encoded as milliseconds since the Unix epoch.
   * </pre>
   *
   * <code>optional int64 creation_time = 7;</code>
   */
  private void setCreationTime(long value) {
    bitField0_ |= 0x00000040;
    creationTime_ = value;
  }
  /**
   * <pre>
   * Entity creation and modification timestamps. Assigned by the client and
   * synced by the server, though the server usually doesn't bother to inspect
   * their values. They are encoded as milliseconds since the Unix epoch.
   * </pre>
   *
   * <code>optional int64 creation_time = 7;</code>
   */
  private void clearCreationTime() {
    bitField0_ = (bitField0_ & ~0x00000040);
    creationTime_ = 0L;
  }

  public static final int MODIFICATION_TIME_FIELD_NUMBER = 8;
  private long modificationTime_;
  /**
   * <code>optional int64 modification_time = 8;</code>
   */
  public boolean hasModificationTime() {
    return ((bitField0_ & 0x00000080) == 0x00000080);
  }
  /**
   * <code>optional int64 modification_time = 8;</code>
   */
  public long getModificationTime() {
    return modificationTime_;
  }
  /**
   * <code>optional int64 modification_time = 8;</code>
   */
  private void setModificationTime(long value) {
    bitField0_ |= 0x00000080;
    modificationTime_ = value;
  }
  /**
   * <code>optional int64 modification_time = 8;</code>
   */
  private void clearModificationTime() {
    bitField0_ = (bitField0_ & ~0x00000080);
    modificationTime_ = 0L;
  }

  public static final int SPECIFICS_HASH_FIELD_NUMBER = 9;
  private java.lang.String specificsHash_;
  /**
   * <pre>
   * A hash of the current entity specifics value. Used to detect whether
   * entity's specifics value has changed without having to keep specifics in
   * memory.
   * </pre>
   *
   * <code>optional string specifics_hash = 9;</code>
   */
  public boolean hasSpecificsHash() {
    return ((bitField0_ & 0x00000100) == 0x00000100);
  }
  /**
   * <pre>
   * A hash of the current entity specifics value. Used to detect whether
   * entity's specifics value has changed without having to keep specifics in
   * memory.
   * </pre>
   *
   * <code>optional string specifics_hash = 9;</code>
   */
  public java.lang.String getSpecificsHash() {
    return specificsHash_;
  }
  /**
   * <pre>
   * A hash of the current entity specifics value. Used to detect whether
   * entity's specifics value has changed without having to keep specifics in
   * memory.
   * </pre>
   *
   * <code>optional string specifics_hash = 9;</code>
   */
  public com.google.protobuf.ByteString
      getSpecificsHashBytes() {
    return com.google.protobuf.ByteString.copyFromUtf8(specificsHash_);
  }
  /**
   * <pre>
   * A hash of the current entity specifics value. Used to detect whether
   * entity's specifics value has changed without having to keep specifics in
   * memory.
   * </pre>
   *
   * <code>optional string specifics_hash = 9;</code>
   */
  private void setSpecificsHash(
      java.lang.String value) {
    if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000100;
    specificsHash_ = value;
  }
  /**
   * <pre>
   * A hash of the current entity specifics value. Used to detect whether
   * entity's specifics value has changed without having to keep specifics in
   * memory.
   * </pre>
   *
   * <code>optional string specifics_hash = 9;</code>
   */
  private void clearSpecificsHash() {
    bitField0_ = (bitField0_ & ~0x00000100);
    specificsHash_ = getDefaultInstance().getSpecificsHash();
  }
  /**
   * <pre>
   * A hash of the current entity specifics value. Used to detect whether
   * entity's specifics value has changed without having to keep specifics in
   * memory.
   * </pre>
   *
   * <code>optional string specifics_hash = 9;</code>
   */
  private void setSpecificsHashBytes(
      com.google.protobuf.ByteString value) {
    if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000100;
    specificsHash_ = value.toStringUtf8();
  }

  public static final int BASE_SPECIFICS_HASH_FIELD_NUMBER = 10;
  private java.lang.String baseSpecificsHash_;
  /**
   * <pre>
   * A hash of the last specifics known by both the client and server. Used to
   * detect when local commits and remote updates are just for encryption. This
   * value will be the empty string only in the following cases: the entity is
   * in sync with the server, has never been synced, or is deleted.
   * </pre>
   *
   * <code>optional string base_specifics_hash = 10;</code>
   */
  public boolean hasBaseSpecificsHash() {
    return ((bitField0_ & 0x00000200) == 0x00000200);
  }
  /**
   * <pre>
   * A hash of the last specifics known by both the client and server. Used to
   * detect when local commits and remote updates are just for encryption. This
   * value will be the empty string only in the following cases: the entity is
   * in sync with the server, has never been synced, or is deleted.
   * </pre>
   *
   * <code>optional string base_specifics_hash = 10;</code>
   */
  public java.lang.String getBaseSpecificsHash() {
    return baseSpecificsHash_;
  }
  /**
   * <pre>
   * A hash of the last specifics known by both the client and server. Used to
   * detect when local commits and remote updates are just for encryption. This
   * value will be the empty string only in the following cases: the entity is
   * in sync with the server, has never been synced, or is deleted.
   * </pre>
   *
   * <code>optional string base_specifics_hash = 10;</code>
   */
  public com.google.protobuf.ByteString
      getBaseSpecificsHashBytes() {
    return com.google.protobuf.ByteString.copyFromUtf8(baseSpecificsHash_);
  }
  /**
   * <pre>
   * A hash of the last specifics known by both the client and server. Used to
   * detect when local commits and remote updates are just for encryption. This
   * value will be the empty string only in the following cases: the entity is
   * in sync with the server, has never been synced, or is deleted.
   * </pre>
   *
   * <code>optional string base_specifics_hash = 10;</code>
   */
  private void setBaseSpecificsHash(
      java.lang.String value) {
    if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000200;
    baseSpecificsHash_ = value;
  }
  /**
   * <pre>
   * A hash of the last specifics known by both the client and server. Used to
   * detect when local commits and remote updates are just for encryption. This
   * value will be the empty string only in the following cases: the entity is
   * in sync with the server, has never been synced, or is deleted.
   * </pre>
   *
   * <code>optional string base_specifics_hash = 10;</code>
   */
  private void clearBaseSpecificsHash() {
    bitField0_ = (bitField0_ & ~0x00000200);
    baseSpecificsHash_ = getDefaultInstance().getBaseSpecificsHash();
  }
  /**
   * <pre>
   * A hash of the last specifics known by both the client and server. Used to
   * detect when local commits and remote updates are just for encryption. This
   * value will be the empty string only in the following cases: the entity is
   * in sync with the server, has never been synced, or is deleted.
   * </pre>
   *
   * <code>optional string base_specifics_hash = 10;</code>
   */
  private void setBaseSpecificsHashBytes(
      com.google.protobuf.ByteString value) {
    if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000200;
    baseSpecificsHash_ = value.toStringUtf8();
  }

  public static final int UNIQUE_POSITION_FIELD_NUMBER = 11;
  private org.chromium.components.sync.protocol.UniquePosition uniquePosition_;
  /**
   * <pre>
   * Used for positioning entities among their siblings. Relevant only for data
   * types that support positions (e.g bookmarks). Refer to its definition in
   * unique_position.proto for more information about its internal
   * representation.
   * </pre>
   *
   * <code>optional .sync_pb.UniquePosition unique_position = 11;</code>
   */
  public boolean hasUniquePosition() {
    return ((bitField0_ & 0x00000400) == 0x00000400);
  }
  /**
   * <pre>
   * Used for positioning entities among their siblings. Relevant only for data
   * types that support positions (e.g bookmarks). Refer to its definition in
   * unique_position.proto for more information about its internal
   * representation.
   * </pre>
   *
   * <code>optional .sync_pb.UniquePosition unique_position = 11;</code>
   */
  public org.chromium.components.sync.protocol.UniquePosition getUniquePosition() {
    return uniquePosition_ == null ? org.chromium.components.sync.protocol.UniquePosition.getDefaultInstance() : uniquePosition_;
  }
  /**
   * <pre>
   * Used for positioning entities among their siblings. Relevant only for data
   * types that support positions (e.g bookmarks). Refer to its definition in
   * unique_position.proto for more information about its internal
   * representation.
   * </pre>
   *
   * <code>optional .sync_pb.UniquePosition unique_position = 11;</code>
   */
  private void setUniquePosition(org.chromium.components.sync.protocol.UniquePosition value) {
    if (value == null) {
      throw new NullPointerException();
    }
    uniquePosition_ = value;
    bitField0_ |= 0x00000400;
    }
  /**
   * <pre>
   * Used for positioning entities among their siblings. Relevant only for data
   * types that support positions (e.g bookmarks). Refer to its definition in
   * unique_position.proto for more information about its internal
   * representation.
   * </pre>
   *
   * <code>optional .sync_pb.UniquePosition unique_position = 11;</code>
   */
  private void setUniquePosition(
      org.chromium.components.sync.protocol.UniquePosition.Builder builderForValue) {
    uniquePosition_ = builderForValue.build();
    bitField0_ |= 0x00000400;
  }
  /**
   * <pre>
   * Used for positioning entities among their siblings. Relevant only for data
   * types that support positions (e.g bookmarks). Refer to its definition in
   * unique_position.proto for more information about its internal
   * representation.
   * </pre>
   *
   * <code>optional .sync_pb.UniquePosition unique_position = 11;</code>
   */
  private void mergeUniquePosition(org.chromium.components.sync.protocol.UniquePosition value) {
    if (uniquePosition_ != null &&
        uniquePosition_ != org.chromium.components.sync.protocol.UniquePosition.getDefaultInstance()) {
      uniquePosition_ =
        org.chromium.components.sync.protocol.UniquePosition.newBuilder(uniquePosition_).mergeFrom(value).buildPartial();
    } else {
      uniquePosition_ = value;
    }
    bitField0_ |= 0x00000400;
  }
  /**
   * <pre>
   * Used for positioning entities among their siblings. Relevant only for data
   * types that support positions (e.g bookmarks). Refer to its definition in
   * unique_position.proto for more information about its internal
   * representation.
   * </pre>
   *
   * <code>optional .sync_pb.UniquePosition unique_position = 11;</code>
   */
  private void clearUniquePosition() {  uniquePosition_ = null;
    bitField0_ = (bitField0_ & ~0x00000400);
  }

  public void writeTo(com.google.protobuf.CodedOutputStream output)
                      throws java.io.IOException {
    if (((bitField0_ & 0x00000001) == 0x00000001)) {
      output.writeString(1, getClientTagHash());
    }
    if (((bitField0_ & 0x00000002) == 0x00000002)) {
      output.writeString(2, getServerId());
    }
    if (((bitField0_ & 0x00000004) == 0x00000004)) {
      output.writeBool(3, isDeleted_);
    }
    if (((bitField0_ & 0x00000008) == 0x00000008)) {
      output.writeInt64(4, sequenceNumber_);
    }
    if (((bitField0_ & 0x00000010) == 0x00000010)) {
      output.writeInt64(5, ackedSequenceNumber_);
    }
    if (((bitField0_ & 0x00000020) == 0x00000020)) {
      output.writeInt64(6, serverVersion_);
    }
    if (((bitField0_ & 0x00000040) == 0x00000040)) {
      output.writeInt64(7, creationTime_);
    }
    if (((bitField0_ & 0x00000080) == 0x00000080)) {
      output.writeInt64(8, modificationTime_);
    }
    if (((bitField0_ & 0x00000100) == 0x00000100)) {
      output.writeString(9, getSpecificsHash());
    }
    if (((bitField0_ & 0x00000200) == 0x00000200)) {
      output.writeString(10, getBaseSpecificsHash());
    }
    if (((bitField0_ & 0x00000400) == 0x00000400)) {
      output.writeMessage(11, getUniquePosition());
    }
    unknownFields.writeTo(output);
  }

  public int getSerializedSize() {
    int size = memoizedSerializedSize;
    if (size != -1) return size;

    size = 0;
    if (((bitField0_ & 0x00000001) == 0x00000001)) {
      size += com.google.protobuf.CodedOutputStream
        .computeStringSize(1, getClientTagHash());
    }
    if (((bitField0_ & 0x00000002) == 0x00000002)) {
      size += com.google.protobuf.CodedOutputStream
        .computeStringSize(2, getServerId());
    }
    if (((bitField0_ & 0x00000004) == 0x00000004)) {
      size += com.google.protobuf.CodedOutputStream
        .computeBoolSize(3, isDeleted_);
    }
    if (((bitField0_ & 0x00000008) == 0x00000008)) {
      size += com.google.protobuf.CodedOutputStream
        .computeInt64Size(4, sequenceNumber_);
    }
    if (((bitField0_ & 0x00000010) == 0x00000010)) {
      size += com.google.protobuf.CodedOutputStream
        .computeInt64Size(5, ackedSequenceNumber_);
    }
    if (((bitField0_ & 0x00000020) == 0x00000020)) {
      size += com.google.protobuf.CodedOutputStream
        .computeInt64Size(6, serverVersion_);
    }
    if (((bitField0_ & 0x00000040) == 0x00000040)) {
      size += com.google.protobuf.CodedOutputStream
        .computeInt64Size(7, creationTime_);
    }
    if (((bitField0_ & 0x00000080) == 0x00000080)) {
      size += com.google.protobuf.CodedOutputStream
        .computeInt64Size(8, modificationTime_);
    }
    if (((bitField0_ & 0x00000100) == 0x00000100)) {
      size += com.google.protobuf.CodedOutputStream
        .computeStringSize(9, getSpecificsHash());
    }
    if (((bitField0_ & 0x00000200) == 0x00000200)) {
      size += com.google.protobuf.CodedOutputStream
        .computeStringSize(10, getBaseSpecificsHash());
    }
    if (((bitField0_ & 0x00000400) == 0x00000400)) {
      size += com.google.protobuf.CodedOutputStream
        .computeMessageSize(11, getUniquePosition());
    }
    size += unknownFields.getSerializedSize();
    memoizedSerializedSize = size;
    return size;
  }

  public static org.chromium.components.sync.protocol.EntityMetadata parseFrom(
      com.google.protobuf.ByteString data)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, data);
  }
  public static org.chromium.components.sync.protocol.EntityMetadata parseFrom(
      com.google.protobuf.ByteString data,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, data, extensionRegistry);
  }
  public static org.chromium.components.sync.protocol.EntityMetadata parseFrom(byte[] data)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, data);
  }
  public static org.chromium.components.sync.protocol.EntityMetadata parseFrom(
      byte[] data,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, data, extensionRegistry);
  }
  public static org.chromium.components.sync.protocol.EntityMetadata parseFrom(java.io.InputStream input)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, input);
  }
  public static org.chromium.components.sync.protocol.EntityMetadata parseFrom(
      java.io.InputStream input,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, input, extensionRegistry);
  }
  public static org.chromium.components.sync.protocol.EntityMetadata parseDelimitedFrom(java.io.InputStream input)
      throws java.io.IOException {
    return parseDelimitedFrom(DEFAULT_INSTANCE, input);
  }
  public static org.chromium.components.sync.protocol.EntityMetadata parseDelimitedFrom(
      java.io.InputStream input,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws java.io.IOException {
    return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
  }
  public static org.chromium.components.sync.protocol.EntityMetadata parseFrom(
      com.google.protobuf.CodedInputStream input)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, input);
  }
  public static org.chromium.components.sync.protocol.EntityMetadata parseFrom(
      com.google.protobuf.CodedInputStream input,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, input, extensionRegistry);
  }

  public static Builder newBuilder() {
    return DEFAULT_INSTANCE.toBuilder();
  }
  public static Builder newBuilder(org.chromium.components.sync.protocol.EntityMetadata prototype) {
    return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
  }

  /**
   * <pre>
   * Sync proto to store entity metadata in model type storage.
   * </pre>
   *
   * Protobuf type {@code sync_pb.EntityMetadata}
   */
  public static final class Builder extends
      com.google.protobuf.GeneratedMessageLite.Builder<
        org.chromium.components.sync.protocol.EntityMetadata, Builder> implements
      // @@protoc_insertion_point(builder_implements:sync_pb.EntityMetadata)
      org.chromium.components.sync.protocol.EntityMetadataOrBuilder {
    // Construct using org.chromium.components.sync.protocol.EntityMetadata.newBuilder()
    private Builder() {
      super(DEFAULT_INSTANCE);
    }


    /**
     * <pre>
     * A hash based on the client tag and model type.
     * Used for various map lookups. Should always be available.
     * Sent to the server as SyncEntity::client_defined_unique_tag.
     * </pre>
     *
     * <code>optional string client_tag_hash = 1;</code>
     */
    public boolean hasClientTagHash() {
      return instance.hasClientTagHash();
    }
    /**
     * <pre>
     * A hash based on the client tag and model type.
     * Used for various map lookups. Should always be available.
     * Sent to the server as SyncEntity::client_defined_unique_tag.
     * </pre>
     *
     * <code>optional string client_tag_hash = 1;</code>
     */
    public java.lang.String getClientTagHash() {
      return instance.getClientTagHash();
    }
    /**
     * <pre>
     * A hash based on the client tag and model type.
     * Used for various map lookups. Should always be available.
     * Sent to the server as SyncEntity::client_defined_unique_tag.
     * </pre>
     *
     * <code>optional string client_tag_hash = 1;</code>
     */
    public com.google.protobuf.ByteString
        getClientTagHashBytes() {
      return instance.getClientTagHashBytes();
    }
    /**
     * <pre>
     * A hash based on the client tag and model type.
     * Used for various map lookups. Should always be available.
     * Sent to the server as SyncEntity::client_defined_unique_tag.
     * </pre>
     *
     * <code>optional string client_tag_hash = 1;</code>
     */
    public Builder setClientTagHash(
        java.lang.String value) {
      copyOnWrite();
      instance.setClientTagHash(value);
      return this;
    }
    /**
     * <pre>
     * A hash based on the client tag and model type.
     * Used for various map lookups. Should always be available.
     * Sent to the server as SyncEntity::client_defined_unique_tag.
     * </pre>
     *
     * <code>optional string client_tag_hash = 1;</code>
     */
    public Builder clearClientTagHash() {
      copyOnWrite();
      instance.clearClientTagHash();
      return this;
    }
    /**
     * <pre>
     * A hash based on the client tag and model type.
     * Used for various map lookups. Should always be available.
     * Sent to the server as SyncEntity::client_defined_unique_tag.
     * </pre>
     *
     * <code>optional string client_tag_hash = 1;</code>
     */
    public Builder setClientTagHashBytes(
        com.google.protobuf.ByteString value) {
      copyOnWrite();
      instance.setClientTagHashBytes(value);
      return this;
    }

    /**
     * <pre>
     * The entity's server-assigned ID.
     * Prior to the item's first commit, we leave this value as an empty string.
     * The initial ID for a newly created item has to meet certain uniqueness
     * requirements, and we handle those on the sync thread.
     * </pre>
     *
     * <code>optional string server_id = 2;</code>
     */
    public boolean hasServerId() {
      return instance.hasServerId();
    }
    /**
     * <pre>
     * The entity's server-assigned ID.
     * Prior to the item's first commit, we leave this value as an empty string.
     * The initial ID for a newly created item has to meet certain uniqueness
     * requirements, and we handle those on the sync thread.
     * </pre>
     *
     * <code>optional string server_id = 2;</code>
     */
    public java.lang.String getServerId() {
      return instance.getServerId();
    }
    /**
     * <pre>
     * The entity's server-assigned ID.
     * Prior to the item's first commit, we leave this value as an empty string.
     * The initial ID for a newly created item has to meet certain uniqueness
     * requirements, and we handle those on the sync thread.
     * </pre>
     *
     * <code>optional string server_id = 2;</code>
     */
    public com.google.protobuf.ByteString
        getServerIdBytes() {
      return instance.getServerIdBytes();
    }
    /**
     * <pre>
     * The entity's server-assigned ID.
     * Prior to the item's first commit, we leave this value as an empty string.
     * The initial ID for a newly created item has to meet certain uniqueness
     * requirements, and we handle those on the sync thread.
     * </pre>
     *
     * <code>optional string server_id = 2;</code>
     */
    public Builder setServerId(
        java.lang.String value) {
      copyOnWrite();
      instance.setServerId(value);
      return this;
    }
    /**
     * <pre>
     * The entity's server-assigned ID.
     * Prior to the item's first commit, we leave this value as an empty string.
     * The initial ID for a newly created item has to meet certain uniqueness
     * requirements, and we handle those on the sync thread.
     * </pre>
     *
     * <code>optional string server_id = 2;</code>
     */
    public Builder clearServerId() {
      copyOnWrite();
      instance.clearServerId();
      return this;
    }
    /**
     * <pre>
     * The entity's server-assigned ID.
     * Prior to the item's first commit, we leave this value as an empty string.
     * The initial ID for a newly created item has to meet certain uniqueness
     * requirements, and we handle those on the sync thread.
     * </pre>
     *
     * <code>optional string server_id = 2;</code>
     */
    public Builder setServerIdBytes(
        com.google.protobuf.ByteString value) {
      copyOnWrite();
      instance.setServerIdBytes(value);
      return this;
    }

    /**
     * <pre>
     * Whether or not the entity is deleted.
     * </pre>
     *
     * <code>optional bool is_deleted = 3;</code>
     */
    public boolean hasIsDeleted() {
      return instance.hasIsDeleted();
    }
    /**
     * <pre>
     * Whether or not the entity is deleted.
     * </pre>
     *
     * <code>optional bool is_deleted = 3;</code>
     */
    public boolean getIsDeleted() {
      return instance.getIsDeleted();
    }
    /**
     * <pre>
     * Whether or not the entity is deleted.
     * </pre>
     *
     * <code>optional bool is_deleted = 3;</code>
     */
    public Builder setIsDeleted(boolean value) {
      copyOnWrite();
      instance.setIsDeleted(value);
      return this;
    }
    /**
     * <pre>
     * Whether or not the entity is deleted.
     * </pre>
     *
     * <code>optional bool is_deleted = 3;</code>
     */
    public Builder clearIsDeleted() {
      copyOnWrite();
      instance.clearIsDeleted();
      return this;
    }

    /**
     * <pre>
     * A version number used to track in-progress commits. Each local change
     * increments this number.
     * </pre>
     *
     * <code>optional int64 sequence_number = 4;</code>
     */
    public boolean hasSequenceNumber() {
      return instance.hasSequenceNumber();
    }
    /**
     * <pre>
     * A version number used to track in-progress commits. Each local change
     * increments this number.
     * </pre>
     *
     * <code>optional int64 sequence_number = 4;</code>
     */
    public long getSequenceNumber() {
      return instance.getSequenceNumber();
    }
    /**
     * <pre>
     * A version number used to track in-progress commits. Each local change
     * increments this number.
     * </pre>
     *
     * <code>optional int64 sequence_number = 4;</code>
     */
    public Builder setSequenceNumber(long value) {
      copyOnWrite();
      instance.setSequenceNumber(value);
      return this;
    }
    /**
     * <pre>
     * A version number used to track in-progress commits. Each local change
     * increments this number.
     * </pre>
     *
     * <code>optional int64 sequence_number = 4;</code>
     */
    public Builder clearSequenceNumber() {
      copyOnWrite();
      instance.clearSequenceNumber();
      return this;
    }

    /**
     * <pre>
     * The sequence number of the last item known to be successfully committed.
     * </pre>
     *
     * <code>optional int64 acked_sequence_number = 5;</code>
     */
    public boolean hasAckedSequenceNumber() {
      return instance.hasAckedSequenceNumber();
    }
    /**
     * <pre>
     * The sequence number of the last item known to be successfully committed.
     * </pre>
     *
     * <code>optional int64 acked_sequence_number = 5;</code>
     */
    public long getAckedSequenceNumber() {
      return instance.getAckedSequenceNumber();
    }
    /**
     * <pre>
     * The sequence number of the last item known to be successfully committed.
     * </pre>
     *
     * <code>optional int64 acked_sequence_number = 5;</code>
     */
    public Builder setAckedSequenceNumber(long value) {
      copyOnWrite();
      instance.setAckedSequenceNumber(value);
      return this;
    }
    /**
     * <pre>
     * The sequence number of the last item known to be successfully committed.
     * </pre>
     *
     * <code>optional int64 acked_sequence_number = 5;</code>
     */
    public Builder clearAckedSequenceNumber() {
      copyOnWrite();
      instance.clearAckedSequenceNumber();
      return this;
    }

    /**
     * <pre>
     * The server version on which this item is based.
     * If there are no local changes, this is the version of the entity as we see
     * it here.
     * If there are local changes, this is the version of the entity on which
     * those changes are based.
     * </pre>
     *
     * <code>optional int64 server_version = 6 [default = -1];</code>
     */
    public boolean hasServerVersion() {
      return instance.hasServerVersion();
    }
    /**
     * <pre>
     * The server version on which this item is based.
     * If there are no local changes, this is the version of the entity as we see
     * it here.
     * If there are local changes, this is the version of the entity on which
     * those changes are based.
     * </pre>
     *
     * <code>optional int64 server_version = 6 [default = -1];</code>
     */
    public long getServerVersion() {
      return instance.getServerVersion();
    }
    /**
     * <pre>
     * The server version on which this item is based.
     * If there are no local changes, this is the version of the entity as we see
     * it here.
     * If there are local changes, this is the version of the entity on which
     * those changes are based.
     * </pre>
     *
     * <code>optional int64 server_version = 6 [default = -1];</code>
     */
    public Builder setServerVersion(long value) {
      copyOnWrite();
      instance.setServerVersion(value);
      return this;
    }
    /**
     * <pre>
     * The server version on which this item is based.
     * If there are no local changes, this is the version of the entity as we see
     * it here.
     * If there are local changes, this is the version of the entity on which
     * those changes are based.
     * </pre>
     *
     * <code>optional int64 server_version = 6 [default = -1];</code>
     */
    public Builder clearServerVersion() {
      copyOnWrite();
      instance.clearServerVersion();
      return this;
    }

    /**
     * <pre>
     * Entity creation and modification timestamps. Assigned by the client and
     * synced by the server, though the server usually doesn't bother to inspect
     * their values. They are encoded as milliseconds since the Unix epoch.
     * </pre>
     *
     * <code>optional int64 creation_time = 7;</code>
     */
    public boolean hasCreationTime() {
      return instance.hasCreationTime();
    }
    /**
     * <pre>
     * Entity creation and modification timestamps. Assigned by the client and
     * synced by the server, though the server usually doesn't bother to inspect
     * their values. They are encoded as milliseconds since the Unix epoch.
     * </pre>
     *
     * <code>optional int64 creation_time = 7;</code>
     */
    public long getCreationTime() {
      return instance.getCreationTime();
    }
    /**
     * <pre>
     * Entity creation and modification timestamps. Assigned by the client and
     * synced by the server, though the server usually doesn't bother to inspect
     * their values. They are encoded as milliseconds since the Unix epoch.
     * </pre>
     *
     * <code>optional int64 creation_time = 7;</code>
     */
    public Builder setCreationTime(long value) {
      copyOnWrite();
      instance.setCreationTime(value);
      return this;
    }
    /**
     * <pre>
     * Entity creation and modification timestamps. Assigned by the client and
     * synced by the server, though the server usually doesn't bother to inspect
     * their values. They are encoded as milliseconds since the Unix epoch.
     * </pre>
     *
     * <code>optional int64 creation_time = 7;</code>
     */
    public Builder clearCreationTime() {
      copyOnWrite();
      instance.clearCreationTime();
      return this;
    }

    /**
     * <code>optional int64 modification_time = 8;</code>
     */
    public boolean hasModificationTime() {
      return instance.hasModificationTime();
    }
    /**
     * <code>optional int64 modification_time = 8;</code>
     */
    public long getModificationTime() {
      return instance.getModificationTime();
    }
    /**
     * <code>optional int64 modification_time = 8;</code>
     */
    public Builder setModificationTime(long value) {
      copyOnWrite();
      instance.setModificationTime(value);
      return this;
    }
    /**
     * <code>optional int64 modification_time = 8;</code>
     */
    public Builder clearModificationTime() {
      copyOnWrite();
      instance.clearModificationTime();
      return this;
    }

    /**
     * <pre>
     * A hash of the current entity specifics value. Used to detect whether
     * entity's specifics value has changed without having to keep specifics in
     * memory.
     * </pre>
     *
     * <code>optional string specifics_hash = 9;</code>
     */
    public boolean hasSpecificsHash() {
      return instance.hasSpecificsHash();
    }
    /**
     * <pre>
     * A hash of the current entity specifics value. Used to detect whether
     * entity's specifics value has changed without having to keep specifics in
     * memory.
     * </pre>
     *
     * <code>optional string specifics_hash = 9;</code>
     */
    public java.lang.String getSpecificsHash() {
      return instance.getSpecificsHash();
    }
    /**
     * <pre>
     * A hash of the current entity specifics value. Used to detect whether
     * entity's specifics value has changed without having to keep specifics in
     * memory.
     * </pre>
     *
     * <code>optional string specifics_hash = 9;</code>
     */
    public com.google.protobuf.ByteString
        getSpecificsHashBytes() {
      return instance.getSpecificsHashBytes();
    }
    /**
     * <pre>
     * A hash of the current entity specifics value. Used to detect whether
     * entity's specifics value has changed without having to keep specifics in
     * memory.
     * </pre>
     *
     * <code>optional string specifics_hash = 9;</code>
     */
    public Builder setSpecificsHash(
        java.lang.String value) {
      copyOnWrite();
      instance.setSpecificsHash(value);
      return this;
    }
    /**
     * <pre>
     * A hash of the current entity specifics value. Used to detect whether
     * entity's specifics value has changed without having to keep specifics in
     * memory.
     * </pre>
     *
     * <code>optional string specifics_hash = 9;</code>
     */
    public Builder clearSpecificsHash() {
      copyOnWrite();
      instance.clearSpecificsHash();
      return this;
    }
    /**
     * <pre>
     * A hash of the current entity specifics value. Used to detect whether
     * entity's specifics value has changed without having to keep specifics in
     * memory.
     * </pre>
     *
     * <code>optional string specifics_hash = 9;</code>
     */
    public Builder setSpecificsHashBytes(
        com.google.protobuf.ByteString value) {
      copyOnWrite();
      instance.setSpecificsHashBytes(value);
      return this;
    }

    /**
     * <pre>
     * A hash of the last specifics known by both the client and server. Used to
     * detect when local commits and remote updates are just for encryption. This
     * value will be the empty string only in the following cases: the entity is
     * in sync with the server, has never been synced, or is deleted.
     * </pre>
     *
     * <code>optional string base_specifics_hash = 10;</code>
     */
    public boolean hasBaseSpecificsHash() {
      return instance.hasBaseSpecificsHash();
    }
    /**
     * <pre>
     * A hash of the last specifics known by both the client and server. Used to
     * detect when local commits and remote updates are just for encryption. This
     * value will be the empty string only in the following cases: the entity is
     * in sync with the server, has never been synced, or is deleted.
     * </pre>
     *
     * <code>optional string base_specifics_hash = 10;</code>
     */
    public java.lang.String getBaseSpecificsHash() {
      return instance.getBaseSpecificsHash();
    }
    /**
     * <pre>
     * A hash of the last specifics known by both the client and server. Used to
     * detect when local commits and remote updates are just for encryption. This
     * value will be the empty string only in the following cases: the entity is
     * in sync with the server, has never been synced, or is deleted.
     * </pre>
     *
     * <code>optional string base_specifics_hash = 10;</code>
     */
    public com.google.protobuf.ByteString
        getBaseSpecificsHashBytes() {
      return instance.getBaseSpecificsHashBytes();
    }
    /**
     * <pre>
     * A hash of the last specifics known by both the client and server. Used to
     * detect when local commits and remote updates are just for encryption. This
     * value will be the empty string only in the following cases: the entity is
     * in sync with the server, has never been synced, or is deleted.
     * </pre>
     *
     * <code>optional string base_specifics_hash = 10;</code>
     */
    public Builder setBaseSpecificsHash(
        java.lang.String value) {
      copyOnWrite();
      instance.setBaseSpecificsHash(value);
      return this;
    }
    /**
     * <pre>
     * A hash of the last specifics known by both the client and server. Used to
     * detect when local commits and remote updates are just for encryption. This
     * value will be the empty string only in the following cases: the entity is
     * in sync with the server, has never been synced, or is deleted.
     * </pre>
     *
     * <code>optional string base_specifics_hash = 10;</code>
     */
    public Builder clearBaseSpecificsHash() {
      copyOnWrite();
      instance.clearBaseSpecificsHash();
      return this;
    }
    /**
     * <pre>
     * A hash of the last specifics known by both the client and server. Used to
     * detect when local commits and remote updates are just for encryption. This
     * value will be the empty string only in the following cases: the entity is
     * in sync with the server, has never been synced, or is deleted.
     * </pre>
     *
     * <code>optional string base_specifics_hash = 10;</code>
     */
    public Builder setBaseSpecificsHashBytes(
        com.google.protobuf.ByteString value) {
      copyOnWrite();
      instance.setBaseSpecificsHashBytes(value);
      return this;
    }

    /**
     * <pre>
     * Used for positioning entities among their siblings. Relevant only for data
     * types that support positions (e.g bookmarks). Refer to its definition in
     * unique_position.proto for more information about its internal
     * representation.
     * </pre>
     *
     * <code>optional .sync_pb.UniquePosition unique_position = 11;</code>
     */
    public boolean hasUniquePosition() {
      return instance.hasUniquePosition();
    }
    /**
     * <pre>
     * Used for positioning entities among their siblings. Relevant only for data
     * types that support positions (e.g bookmarks). Refer to its definition in
     * unique_position.proto for more information about its internal
     * representation.
     * </pre>
     *
     * <code>optional .sync_pb.UniquePosition unique_position = 11;</code>
     */
    public org.chromium.components.sync.protocol.UniquePosition getUniquePosition() {
      return instance.getUniquePosition();
    }
    /**
     * <pre>
     * Used for positioning entities among their siblings. Relevant only for data
     * types that support positions (e.g bookmarks). Refer to its definition in
     * unique_position.proto for more information about its internal
     * representation.
     * </pre>
     *
     * <code>optional .sync_pb.UniquePosition unique_position = 11;</code>
     */
    public Builder setUniquePosition(org.chromium.components.sync.protocol.UniquePosition value) {
      copyOnWrite();
      instance.setUniquePosition(value);
      return this;
      }
    /**
     * <pre>
     * Used for positioning entities among their siblings. Relevant only for data
     * types that support positions (e.g bookmarks). Refer to its definition in
     * unique_position.proto for more information about its internal
     * representation.
     * </pre>
     *
     * <code>optional .sync_pb.UniquePosition unique_position = 11;</code>
     */
    public Builder setUniquePosition(
        org.chromium.components.sync.protocol.UniquePosition.Builder builderForValue) {
      copyOnWrite();
      instance.setUniquePosition(builderForValue);
      return this;
    }
    /**
     * <pre>
     * Used for positioning entities among their siblings. Relevant only for data
     * types that support positions (e.g bookmarks). Refer to its definition in
     * unique_position.proto for more information about its internal
     * representation.
     * </pre>
     *
     * <code>optional .sync_pb.UniquePosition unique_position = 11;</code>
     */
    public Builder mergeUniquePosition(org.chromium.components.sync.protocol.UniquePosition value) {
      copyOnWrite();
      instance.mergeUniquePosition(value);
      return this;
    }
    /**
     * <pre>
     * Used for positioning entities among their siblings. Relevant only for data
     * types that support positions (e.g bookmarks). Refer to its definition in
     * unique_position.proto for more information about its internal
     * representation.
     * </pre>
     *
     * <code>optional .sync_pb.UniquePosition unique_position = 11;</code>
     */
    public Builder clearUniquePosition() {  copyOnWrite();
      instance.clearUniquePosition();
      return this;
    }

    // @@protoc_insertion_point(builder_scope:sync_pb.EntityMetadata)
  }
  protected final Object dynamicMethod(
      com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
      Object arg0, Object arg1) {
    switch (method) {
      case NEW_MUTABLE_INSTANCE: {
        return new org.chromium.components.sync.protocol.EntityMetadata();
      }
      case IS_INITIALIZED: {
        return DEFAULT_INSTANCE;
      }
      case MAKE_IMMUTABLE: {
        return null;
      }
      case NEW_BUILDER: {
        return new Builder();
      }
      case VISIT: {
        Visitor visitor = (Visitor) arg0;
        org.chromium.components.sync.protocol.EntityMetadata other = (org.chromium.components.sync.protocol.EntityMetadata) arg1;
        clientTagHash_ = visitor.visitString(
            hasClientTagHash(), clientTagHash_,
            other.hasClientTagHash(), other.clientTagHash_);
        serverId_ = visitor.visitString(
            hasServerId(), serverId_,
            other.hasServerId(), other.serverId_);
        isDeleted_ = visitor.visitBoolean(
            hasIsDeleted(), isDeleted_,
            other.hasIsDeleted(), other.isDeleted_);
        sequenceNumber_ = visitor.visitLong(
            hasSequenceNumber(), sequenceNumber_,
            other.hasSequenceNumber(), other.sequenceNumber_);
        ackedSequenceNumber_ = visitor.visitLong(
            hasAckedSequenceNumber(), ackedSequenceNumber_,
            other.hasAckedSequenceNumber(), other.ackedSequenceNumber_);
        serverVersion_ = visitor.visitLong(
            hasServerVersion(), serverVersion_,
            other.hasServerVersion(), other.serverVersion_);
        creationTime_ = visitor.visitLong(
            hasCreationTime(), creationTime_,
            other.hasCreationTime(), other.creationTime_);
        modificationTime_ = visitor.visitLong(
            hasModificationTime(), modificationTime_,
            other.hasModificationTime(), other.modificationTime_);
        specificsHash_ = visitor.visitString(
            hasSpecificsHash(), specificsHash_,
            other.hasSpecificsHash(), other.specificsHash_);
        baseSpecificsHash_ = visitor.visitString(
            hasBaseSpecificsHash(), baseSpecificsHash_,
            other.hasBaseSpecificsHash(), other.baseSpecificsHash_);
        uniquePosition_ = visitor.visitMessage(uniquePosition_, other.uniquePosition_);
        if (visitor == com.google.protobuf.GeneratedMessageLite.MergeFromVisitor
            .INSTANCE) {
          bitField0_ |= other.bitField0_;
        }
        return this;
      }
      case MERGE_FROM_STREAM: {
        com.google.protobuf.CodedInputStream input =
            (com.google.protobuf.CodedInputStream) arg0;
        com.google.protobuf.ExtensionRegistryLite extensionRegistry =
            (com.google.protobuf.ExtensionRegistryLite) arg1;
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              default: {
                if (!parseUnknownField(tag, input)) {
                  done = true;
                }
                break;
              }
              case 10: {
                String s = input.readString();
                bitField0_ |= 0x00000001;
                clientTagHash_ = s;
                break;
              }
              case 18: {
                String s = input.readString();
                bitField0_ |= 0x00000002;
                serverId_ = s;
                break;
              }
              case 24: {
                bitField0_ |= 0x00000004;
                isDeleted_ = input.readBool();
                break;
              }
              case 32: {
                bitField0_ |= 0x00000008;
                sequenceNumber_ = input.readInt64();
                break;
              }
              case 40: {
                bitField0_ |= 0x00000010;
                ackedSequenceNumber_ = input.readInt64();
                break;
              }
              case 48: {
                bitField0_ |= 0x00000020;
                serverVersion_ = input.readInt64();
                break;
              }
              case 56: {
                bitField0_ |= 0x00000040;
                creationTime_ = input.readInt64();
                break;
              }
              case 64: {
                bitField0_ |= 0x00000080;
                modificationTime_ = input.readInt64();
                break;
              }
              case 74: {
                String s = input.readString();
                bitField0_ |= 0x00000100;
                specificsHash_ = s;
                break;
              }
              case 82: {
                String s = input.readString();
                bitField0_ |= 0x00000200;
                baseSpecificsHash_ = s;
                break;
              }
              case 90: {
                org.chromium.components.sync.protocol.UniquePosition.Builder subBuilder = null;
                if (((bitField0_ & 0x00000400) == 0x00000400)) {
                  subBuilder = uniquePosition_.toBuilder();
                }
                uniquePosition_ = input.readMessage(org.chromium.components.sync.protocol.UniquePosition.parser(), extensionRegistry);
                if (subBuilder != null) {
                  subBuilder.mergeFrom(uniquePosition_);
                  uniquePosition_ = subBuilder.buildPartial();
                }
                bitField0_ |= 0x00000400;
                break;
              }
            }
          }
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw new RuntimeException(e.setUnfinishedMessage(this));
        } catch (java.io.IOException e) {
          throw new RuntimeException(
              new com.google.protobuf.InvalidProtocolBufferException(
                  e.getMessage()).setUnfinishedMessage(this));
        } finally {
        }
      }
      case GET_DEFAULT_INSTANCE: {
        return DEFAULT_INSTANCE;
      }
      case GET_PARSER: {
        if (PARSER == null) {    synchronized (org.chromium.components.sync.protocol.EntityMetadata.class) {
            if (PARSER == null) {
              PARSER = new DefaultInstanceBasedParser(DEFAULT_INSTANCE);
            }
          }
        }
        return PARSER;
      }
    }
    throw new UnsupportedOperationException();
  }


  // @@protoc_insertion_point(class_scope:sync_pb.EntityMetadata)
  private static final org.chromium.components.sync.protocol.EntityMetadata DEFAULT_INSTANCE;
  static {
    DEFAULT_INSTANCE = new EntityMetadata();
    DEFAULT_INSTANCE.makeImmutable();
  }

  public static org.chromium.components.sync.protocol.EntityMetadata getDefaultInstance() {
    return DEFAULT_INSTANCE;
  }

  private static volatile com.google.protobuf.Parser<EntityMetadata> PARSER;

  public static com.google.protobuf.Parser<EntityMetadata> parser() {
    return DEFAULT_INSTANCE.getParserForType();
  }
}

