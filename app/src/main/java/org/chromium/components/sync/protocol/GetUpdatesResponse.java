// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: sync.proto

package org.chromium.components.sync.protocol;

/**
 * Protobuf type {@code sync_pb.GetUpdatesResponse}
 */
public  final class GetUpdatesResponse extends
    com.google.protobuf.GeneratedMessageLite<
        GetUpdatesResponse, GetUpdatesResponse.Builder> implements
    // @@protoc_insertion_point(message_implements:sync_pb.GetUpdatesResponse)
    GetUpdatesResponseOrBuilder {
  private GetUpdatesResponse() {
    entries_ = emptyProtobufList();
    newProgressMarker_ = emptyProtobufList();
    encryptionKeys_ = emptyProtobufList();
    contextMutations_ = emptyProtobufList();
  }
  private int bitField0_;
  public static final int ENTRIES_FIELD_NUMBER = 1;
  private com.google.protobuf.Internal.ProtobufList<org.chromium.components.sync.protocol.SyncEntity> entries_;
  /**
   * <pre>
   * New sync entries that the client should apply.
   * </pre>
   *
   * <code>repeated .sync_pb.SyncEntity entries = 1;</code>
   */
  public java.util.List<org.chromium.components.sync.protocol.SyncEntity> getEntriesList() {
    return entries_;
  }
  /**
   * <pre>
   * New sync entries that the client should apply.
   * </pre>
   *
   * <code>repeated .sync_pb.SyncEntity entries = 1;</code>
   */
  public java.util.List<? extends org.chromium.components.sync.protocol.SyncEntityOrBuilder> 
      getEntriesOrBuilderList() {
    return entries_;
  }
  /**
   * <pre>
   * New sync entries that the client should apply.
   * </pre>
   *
   * <code>repeated .sync_pb.SyncEntity entries = 1;</code>
   */
  public int getEntriesCount() {
    return entries_.size();
  }
  /**
   * <pre>
   * New sync entries that the client should apply.
   * </pre>
   *
   * <code>repeated .sync_pb.SyncEntity entries = 1;</code>
   */
  public org.chromium.components.sync.protocol.SyncEntity getEntries(int index) {
    return entries_.get(index);
  }
  /**
   * <pre>
   * New sync entries that the client should apply.
   * </pre>
   *
   * <code>repeated .sync_pb.SyncEntity entries = 1;</code>
   */
  public org.chromium.components.sync.protocol.SyncEntityOrBuilder getEntriesOrBuilder(
      int index) {
    return entries_.get(index);
  }
  private void ensureEntriesIsMutable() {
    if (!entries_.isModifiable()) {
      entries_ =
          com.google.protobuf.GeneratedMessageLite.mutableCopy(entries_);
     }
  }

  /**
   * <pre>
   * New sync entries that the client should apply.
   * </pre>
   *
   * <code>repeated .sync_pb.SyncEntity entries = 1;</code>
   */
  private void setEntries(
      int index, org.chromium.components.sync.protocol.SyncEntity value) {
    if (value == null) {
      throw new NullPointerException();
    }
    ensureEntriesIsMutable();
    entries_.set(index, value);
  }
  /**
   * <pre>
   * New sync entries that the client should apply.
   * </pre>
   *
   * <code>repeated .sync_pb.SyncEntity entries = 1;</code>
   */
  private void setEntries(
      int index, org.chromium.components.sync.protocol.SyncEntity.Builder builderForValue) {
    ensureEntriesIsMutable();
    entries_.set(index, builderForValue.build());
  }
  /**
   * <pre>
   * New sync entries that the client should apply.
   * </pre>
   *
   * <code>repeated .sync_pb.SyncEntity entries = 1;</code>
   */
  private void addEntries(org.chromium.components.sync.protocol.SyncEntity value) {
    if (value == null) {
      throw new NullPointerException();
    }
    ensureEntriesIsMutable();
    entries_.add(value);
  }
  /**
   * <pre>
   * New sync entries that the client should apply.
   * </pre>
   *
   * <code>repeated .sync_pb.SyncEntity entries = 1;</code>
   */
  private void addEntries(
      int index, org.chromium.components.sync.protocol.SyncEntity value) {
    if (value == null) {
      throw new NullPointerException();
    }
    ensureEntriesIsMutable();
    entries_.add(index, value);
  }
  /**
   * <pre>
   * New sync entries that the client should apply.
   * </pre>
   *
   * <code>repeated .sync_pb.SyncEntity entries = 1;</code>
   */
  private void addEntries(
      org.chromium.components.sync.protocol.SyncEntity.Builder builderForValue) {
    ensureEntriesIsMutable();
    entries_.add(builderForValue.build());
  }
  /**
   * <pre>
   * New sync entries that the client should apply.
   * </pre>
   *
   * <code>repeated .sync_pb.SyncEntity entries = 1;</code>
   */
  private void addEntries(
      int index, org.chromium.components.sync.protocol.SyncEntity.Builder builderForValue) {
    ensureEntriesIsMutable();
    entries_.add(index, builderForValue.build());
  }
  /**
   * <pre>
   * New sync entries that the client should apply.
   * </pre>
   *
   * <code>repeated .sync_pb.SyncEntity entries = 1;</code>
   */
  private void addAllEntries(
      java.lang.Iterable<? extends org.chromium.components.sync.protocol.SyncEntity> values) {
    ensureEntriesIsMutable();
    com.google.protobuf.AbstractMessageLite.addAll(
        values, entries_);
  }
  /**
   * <pre>
   * New sync entries that the client should apply.
   * </pre>
   *
   * <code>repeated .sync_pb.SyncEntity entries = 1;</code>
   */
  private void clearEntries() {
    entries_ = emptyProtobufList();
  }
  /**
   * <pre>
   * New sync entries that the client should apply.
   * </pre>
   *
   * <code>repeated .sync_pb.SyncEntity entries = 1;</code>
   */
  private void removeEntries(int index) {
    ensureEntriesIsMutable();
    entries_.remove(index);
  }

  public static final int CHANGES_REMAINING_FIELD_NUMBER = 4;
  private long changesRemaining_;
  /**
   * <pre>
   * Approximate count of changes remaining - use this for UI feedback.
   * If present and zero, this estimate is firm: the server has no changes
   * after the current batch.
   * </pre>
   *
   * <code>optional int64 changes_remaining = 4;</code>
   */
  public boolean hasChangesRemaining() {
    return ((bitField0_ & 0x00000001) == 0x00000001);
  }
  /**
   * <pre>
   * Approximate count of changes remaining - use this for UI feedback.
   * If present and zero, this estimate is firm: the server has no changes
   * after the current batch.
   * </pre>
   *
   * <code>optional int64 changes_remaining = 4;</code>
   */
  public long getChangesRemaining() {
    return changesRemaining_;
  }
  /**
   * <pre>
   * Approximate count of changes remaining - use this for UI feedback.
   * If present and zero, this estimate is firm: the server has no changes
   * after the current batch.
   * </pre>
   *
   * <code>optional int64 changes_remaining = 4;</code>
   */
  private void setChangesRemaining(long value) {
    bitField0_ |= 0x00000001;
    changesRemaining_ = value;
  }
  /**
   * <pre>
   * Approximate count of changes remaining - use this for UI feedback.
   * If present and zero, this estimate is firm: the server has no changes
   * after the current batch.
   * </pre>
   *
   * <code>optional int64 changes_remaining = 4;</code>
   */
  private void clearChangesRemaining() {
    bitField0_ = (bitField0_ & ~0x00000001);
    changesRemaining_ = 0L;
  }

  public static final int NEW_PROGRESS_MARKER_FIELD_NUMBER = 5;
  private com.google.protobuf.Internal.ProtobufList<org.chromium.components.sync.protocol.DataTypeProgressMarker> newProgressMarker_;
  /**
   * <pre>
   * Opaque, per-datatype timestamp-like tokens.  Clients should retain and
   * persist the values returned in this field, and present them back to the
   * server to indicate the starting point for future update requests.
   * This will be sent only if the client provided |from_progress_marker|
   * in the update request.
   * The server may provide a new progress marker even if this is the end of
   * the batch, or if there were no new updates on the server; and the client
   * must save these.  If the server does not provide a |new_progress_marker|
   * value for a particular datatype, when the request provided a
   * |from_progress_marker| value for that datatype, the client should
   * interpret this to mean "no change from the previous state" and retain its
   * previous progress-marker value for that datatype.
   * Progress markers in the context of a response will never have the
   * |timestamp_token_for_migration| field set.
   * </pre>
   *
   * <code>repeated .sync_pb.DataTypeProgressMarker new_progress_marker = 5;</code>
   */
  public java.util.List<org.chromium.components.sync.protocol.DataTypeProgressMarker> getNewProgressMarkerList() {
    return newProgressMarker_;
  }
  /**
   * <pre>
   * Opaque, per-datatype timestamp-like tokens.  Clients should retain and
   * persist the values returned in this field, and present them back to the
   * server to indicate the starting point for future update requests.
   * This will be sent only if the client provided |from_progress_marker|
   * in the update request.
   * The server may provide a new progress marker even if this is the end of
   * the batch, or if there were no new updates on the server; and the client
   * must save these.  If the server does not provide a |new_progress_marker|
   * value for a particular datatype, when the request provided a
   * |from_progress_marker| value for that datatype, the client should
   * interpret this to mean "no change from the previous state" and retain its
   * previous progress-marker value for that datatype.
   * Progress markers in the context of a response will never have the
   * |timestamp_token_for_migration| field set.
   * </pre>
   *
   * <code>repeated .sync_pb.DataTypeProgressMarker new_progress_marker = 5;</code>
   */
  public java.util.List<? extends org.chromium.components.sync.protocol.DataTypeProgressMarkerOrBuilder> 
      getNewProgressMarkerOrBuilderList() {
    return newProgressMarker_;
  }
  /**
   * <pre>
   * Opaque, per-datatype timestamp-like tokens.  Clients should retain and
   * persist the values returned in this field, and present them back to the
   * server to indicate the starting point for future update requests.
   * This will be sent only if the client provided |from_progress_marker|
   * in the update request.
   * The server may provide a new progress marker even if this is the end of
   * the batch, or if there were no new updates on the server; and the client
   * must save these.  If the server does not provide a |new_progress_marker|
   * value for a particular datatype, when the request provided a
   * |from_progress_marker| value for that datatype, the client should
   * interpret this to mean "no change from the previous state" and retain its
   * previous progress-marker value for that datatype.
   * Progress markers in the context of a response will never have the
   * |timestamp_token_for_migration| field set.
   * </pre>
   *
   * <code>repeated .sync_pb.DataTypeProgressMarker new_progress_marker = 5;</code>
   */
  public int getNewProgressMarkerCount() {
    return newProgressMarker_.size();
  }
  /**
   * <pre>
   * Opaque, per-datatype timestamp-like tokens.  Clients should retain and
   * persist the values returned in this field, and present them back to the
   * server to indicate the starting point for future update requests.
   * This will be sent only if the client provided |from_progress_marker|
   * in the update request.
   * The server may provide a new progress marker even if this is the end of
   * the batch, or if there were no new updates on the server; and the client
   * must save these.  If the server does not provide a |new_progress_marker|
   * value for a particular datatype, when the request provided a
   * |from_progress_marker| value for that datatype, the client should
   * interpret this to mean "no change from the previous state" and retain its
   * previous progress-marker value for that datatype.
   * Progress markers in the context of a response will never have the
   * |timestamp_token_for_migration| field set.
   * </pre>
   *
   * <code>repeated .sync_pb.DataTypeProgressMarker new_progress_marker = 5;</code>
   */
  public org.chromium.components.sync.protocol.DataTypeProgressMarker getNewProgressMarker(int index) {
    return newProgressMarker_.get(index);
  }
  /**
   * <pre>
   * Opaque, per-datatype timestamp-like tokens.  Clients should retain and
   * persist the values returned in this field, and present them back to the
   * server to indicate the starting point for future update requests.
   * This will be sent only if the client provided |from_progress_marker|
   * in the update request.
   * The server may provide a new progress marker even if this is the end of
   * the batch, or if there were no new updates on the server; and the client
   * must save these.  If the server does not provide a |new_progress_marker|
   * value for a particular datatype, when the request provided a
   * |from_progress_marker| value for that datatype, the client should
   * interpret this to mean "no change from the previous state" and retain its
   * previous progress-marker value for that datatype.
   * Progress markers in the context of a response will never have the
   * |timestamp_token_for_migration| field set.
   * </pre>
   *
   * <code>repeated .sync_pb.DataTypeProgressMarker new_progress_marker = 5;</code>
   */
  public org.chromium.components.sync.protocol.DataTypeProgressMarkerOrBuilder getNewProgressMarkerOrBuilder(
      int index) {
    return newProgressMarker_.get(index);
  }
  private void ensureNewProgressMarkerIsMutable() {
    if (!newProgressMarker_.isModifiable()) {
      newProgressMarker_ =
          com.google.protobuf.GeneratedMessageLite.mutableCopy(newProgressMarker_);
     }
  }

  /**
   * <pre>
   * Opaque, per-datatype timestamp-like tokens.  Clients should retain and
   * persist the values returned in this field, and present them back to the
   * server to indicate the starting point for future update requests.
   * This will be sent only if the client provided |from_progress_marker|
   * in the update request.
   * The server may provide a new progress marker even if this is the end of
   * the batch, or if there were no new updates on the server; and the client
   * must save these.  If the server does not provide a |new_progress_marker|
   * value for a particular datatype, when the request provided a
   * |from_progress_marker| value for that datatype, the client should
   * interpret this to mean "no change from the previous state" and retain its
   * previous progress-marker value for that datatype.
   * Progress markers in the context of a response will never have the
   * |timestamp_token_for_migration| field set.
   * </pre>
   *
   * <code>repeated .sync_pb.DataTypeProgressMarker new_progress_marker = 5;</code>
   */
  private void setNewProgressMarker(
      int index, org.chromium.components.sync.protocol.DataTypeProgressMarker value) {
    if (value == null) {
      throw new NullPointerException();
    }
    ensureNewProgressMarkerIsMutable();
    newProgressMarker_.set(index, value);
  }
  /**
   * <pre>
   * Opaque, per-datatype timestamp-like tokens.  Clients should retain and
   * persist the values returned in this field, and present them back to the
   * server to indicate the starting point for future update requests.
   * This will be sent only if the client provided |from_progress_marker|
   * in the update request.
   * The server may provide a new progress marker even if this is the end of
   * the batch, or if there were no new updates on the server; and the client
   * must save these.  If the server does not provide a |new_progress_marker|
   * value for a particular datatype, when the request provided a
   * |from_progress_marker| value for that datatype, the client should
   * interpret this to mean "no change from the previous state" and retain its
   * previous progress-marker value for that datatype.
   * Progress markers in the context of a response will never have the
   * |timestamp_token_for_migration| field set.
   * </pre>
   *
   * <code>repeated .sync_pb.DataTypeProgressMarker new_progress_marker = 5;</code>
   */
  private void setNewProgressMarker(
      int index, org.chromium.components.sync.protocol.DataTypeProgressMarker.Builder builderForValue) {
    ensureNewProgressMarkerIsMutable();
    newProgressMarker_.set(index, builderForValue.build());
  }
  /**
   * <pre>
   * Opaque, per-datatype timestamp-like tokens.  Clients should retain and
   * persist the values returned in this field, and present them back to the
   * server to indicate the starting point for future update requests.
   * This will be sent only if the client provided |from_progress_marker|
   * in the update request.
   * The server may provide a new progress marker even if this is the end of
   * the batch, or if there were no new updates on the server; and the client
   * must save these.  If the server does not provide a |new_progress_marker|
   * value for a particular datatype, when the request provided a
   * |from_progress_marker| value for that datatype, the client should
   * interpret this to mean "no change from the previous state" and retain its
   * previous progress-marker value for that datatype.
   * Progress markers in the context of a response will never have the
   * |timestamp_token_for_migration| field set.
   * </pre>
   *
   * <code>repeated .sync_pb.DataTypeProgressMarker new_progress_marker = 5;</code>
   */
  private void addNewProgressMarker(org.chromium.components.sync.protocol.DataTypeProgressMarker value) {
    if (value == null) {
      throw new NullPointerException();
    }
    ensureNewProgressMarkerIsMutable();
    newProgressMarker_.add(value);
  }
  /**
   * <pre>
   * Opaque, per-datatype timestamp-like tokens.  Clients should retain and
   * persist the values returned in this field, and present them back to the
   * server to indicate the starting point for future update requests.
   * This will be sent only if the client provided |from_progress_marker|
   * in the update request.
   * The server may provide a new progress marker even if this is the end of
   * the batch, or if there were no new updates on the server; and the client
   * must save these.  If the server does not provide a |new_progress_marker|
   * value for a particular datatype, when the request provided a
   * |from_progress_marker| value for that datatype, the client should
   * interpret this to mean "no change from the previous state" and retain its
   * previous progress-marker value for that datatype.
   * Progress markers in the context of a response will never have the
   * |timestamp_token_for_migration| field set.
   * </pre>
   *
   * <code>repeated .sync_pb.DataTypeProgressMarker new_progress_marker = 5;</code>
   */
  private void addNewProgressMarker(
      int index, org.chromium.components.sync.protocol.DataTypeProgressMarker value) {
    if (value == null) {
      throw new NullPointerException();
    }
    ensureNewProgressMarkerIsMutable();
    newProgressMarker_.add(index, value);
  }
  /**
   * <pre>
   * Opaque, per-datatype timestamp-like tokens.  Clients should retain and
   * persist the values returned in this field, and present them back to the
   * server to indicate the starting point for future update requests.
   * This will be sent only if the client provided |from_progress_marker|
   * in the update request.
   * The server may provide a new progress marker even if this is the end of
   * the batch, or if there were no new updates on the server; and the client
   * must save these.  If the server does not provide a |new_progress_marker|
   * value for a particular datatype, when the request provided a
   * |from_progress_marker| value for that datatype, the client should
   * interpret this to mean "no change from the previous state" and retain its
   * previous progress-marker value for that datatype.
   * Progress markers in the context of a response will never have the
   * |timestamp_token_for_migration| field set.
   * </pre>
   *
   * <code>repeated .sync_pb.DataTypeProgressMarker new_progress_marker = 5;</code>
   */
  private void addNewProgressMarker(
      org.chromium.components.sync.protocol.DataTypeProgressMarker.Builder builderForValue) {
    ensureNewProgressMarkerIsMutable();
    newProgressMarker_.add(builderForValue.build());
  }
  /**
   * <pre>
   * Opaque, per-datatype timestamp-like tokens.  Clients should retain and
   * persist the values returned in this field, and present them back to the
   * server to indicate the starting point for future update requests.
   * This will be sent only if the client provided |from_progress_marker|
   * in the update request.
   * The server may provide a new progress marker even if this is the end of
   * the batch, or if there were no new updates on the server; and the client
   * must save these.  If the server does not provide a |new_progress_marker|
   * value for a particular datatype, when the request provided a
   * |from_progress_marker| value for that datatype, the client should
   * interpret this to mean "no change from the previous state" and retain its
   * previous progress-marker value for that datatype.
   * Progress markers in the context of a response will never have the
   * |timestamp_token_for_migration| field set.
   * </pre>
   *
   * <code>repeated .sync_pb.DataTypeProgressMarker new_progress_marker = 5;</code>
   */
  private void addNewProgressMarker(
      int index, org.chromium.components.sync.protocol.DataTypeProgressMarker.Builder builderForValue) {
    ensureNewProgressMarkerIsMutable();
    newProgressMarker_.add(index, builderForValue.build());
  }
  /**
   * <pre>
   * Opaque, per-datatype timestamp-like tokens.  Clients should retain and
   * persist the values returned in this field, and present them back to the
   * server to indicate the starting point for future update requests.
   * This will be sent only if the client provided |from_progress_marker|
   * in the update request.
   * The server may provide a new progress marker even if this is the end of
   * the batch, or if there were no new updates on the server; and the client
   * must save these.  If the server does not provide a |new_progress_marker|
   * value for a particular datatype, when the request provided a
   * |from_progress_marker| value for that datatype, the client should
   * interpret this to mean "no change from the previous state" and retain its
   * previous progress-marker value for that datatype.
   * Progress markers in the context of a response will never have the
   * |timestamp_token_for_migration| field set.
   * </pre>
   *
   * <code>repeated .sync_pb.DataTypeProgressMarker new_progress_marker = 5;</code>
   */
  private void addAllNewProgressMarker(
      java.lang.Iterable<? extends org.chromium.components.sync.protocol.DataTypeProgressMarker> values) {
    ensureNewProgressMarkerIsMutable();
    com.google.protobuf.AbstractMessageLite.addAll(
        values, newProgressMarker_);
  }
  /**
   * <pre>
   * Opaque, per-datatype timestamp-like tokens.  Clients should retain and
   * persist the values returned in this field, and present them back to the
   * server to indicate the starting point for future update requests.
   * This will be sent only if the client provided |from_progress_marker|
   * in the update request.
   * The server may provide a new progress marker even if this is the end of
   * the batch, or if there were no new updates on the server; and the client
   * must save these.  If the server does not provide a |new_progress_marker|
   * value for a particular datatype, when the request provided a
   * |from_progress_marker| value for that datatype, the client should
   * interpret this to mean "no change from the previous state" and retain its
   * previous progress-marker value for that datatype.
   * Progress markers in the context of a response will never have the
   * |timestamp_token_for_migration| field set.
   * </pre>
   *
   * <code>repeated .sync_pb.DataTypeProgressMarker new_progress_marker = 5;</code>
   */
  private void clearNewProgressMarker() {
    newProgressMarker_ = emptyProtobufList();
  }
  /**
   * <pre>
   * Opaque, per-datatype timestamp-like tokens.  Clients should retain and
   * persist the values returned in this field, and present them back to the
   * server to indicate the starting point for future update requests.
   * This will be sent only if the client provided |from_progress_marker|
   * in the update request.
   * The server may provide a new progress marker even if this is the end of
   * the batch, or if there were no new updates on the server; and the client
   * must save these.  If the server does not provide a |new_progress_marker|
   * value for a particular datatype, when the request provided a
   * |from_progress_marker| value for that datatype, the client should
   * interpret this to mean "no change from the previous state" and retain its
   * previous progress-marker value for that datatype.
   * Progress markers in the context of a response will never have the
   * |timestamp_token_for_migration| field set.
   * </pre>
   *
   * <code>repeated .sync_pb.DataTypeProgressMarker new_progress_marker = 5;</code>
   */
  private void removeNewProgressMarker(int index) {
    ensureNewProgressMarkerIsMutable();
    newProgressMarker_.remove(index);
  }

  public static final int ENCRYPTION_KEYS_FIELD_NUMBER = 6;
  private com.google.protobuf.Internal.ProtobufList<com.google.protobuf.ByteString> encryptionKeys_;
  /**
   * <pre>
   * The current encryption keys associated with this account. Will be set if
   * the GetUpdatesMessage in the request had need_encryption_key == true or
   * the server has updated the set of encryption keys (e.g. due to a key
   * rotation).
   * </pre>
   *
   * <code>repeated bytes encryption_keys = 6;</code>
   */
  public java.util.List<com.google.protobuf.ByteString>
      getEncryptionKeysList() {
    return encryptionKeys_;
  }
  /**
   * <pre>
   * The current encryption keys associated with this account. Will be set if
   * the GetUpdatesMessage in the request had need_encryption_key == true or
   * the server has updated the set of encryption keys (e.g. due to a key
   * rotation).
   * </pre>
   *
   * <code>repeated bytes encryption_keys = 6;</code>
   */
  public int getEncryptionKeysCount() {
    return encryptionKeys_.size();
  }
  /**
   * <pre>
   * The current encryption keys associated with this account. Will be set if
   * the GetUpdatesMessage in the request had need_encryption_key == true or
   * the server has updated the set of encryption keys (e.g. due to a key
   * rotation).
   * </pre>
   *
   * <code>repeated bytes encryption_keys = 6;</code>
   */
  public com.google.protobuf.ByteString getEncryptionKeys(int index) {
    return encryptionKeys_.get(index);
  }
  private void ensureEncryptionKeysIsMutable() {
    if (!encryptionKeys_.isModifiable()) {
      encryptionKeys_ =
          com.google.protobuf.GeneratedMessageLite.mutableCopy(encryptionKeys_);
     }
  }
  /**
   * <pre>
   * The current encryption keys associated with this account. Will be set if
   * the GetUpdatesMessage in the request had need_encryption_key == true or
   * the server has updated the set of encryption keys (e.g. due to a key
   * rotation).
   * </pre>
   *
   * <code>repeated bytes encryption_keys = 6;</code>
   */
  private void setEncryptionKeys(
      int index, com.google.protobuf.ByteString value) {
    if (value == null) {
    throw new NullPointerException();
  }
  ensureEncryptionKeysIsMutable();
    encryptionKeys_.set(index, value);
  }
  /**
   * <pre>
   * The current encryption keys associated with this account. Will be set if
   * the GetUpdatesMessage in the request had need_encryption_key == true or
   * the server has updated the set of encryption keys (e.g. due to a key
   * rotation).
   * </pre>
   *
   * <code>repeated bytes encryption_keys = 6;</code>
   */
  private void addEncryptionKeys(com.google.protobuf.ByteString value) {
    if (value == null) {
    throw new NullPointerException();
  }
  ensureEncryptionKeysIsMutable();
    encryptionKeys_.add(value);
  }
  /**
   * <pre>
   * The current encryption keys associated with this account. Will be set if
   * the GetUpdatesMessage in the request had need_encryption_key == true or
   * the server has updated the set of encryption keys (e.g. due to a key
   * rotation).
   * </pre>
   *
   * <code>repeated bytes encryption_keys = 6;</code>
   */
  private void addAllEncryptionKeys(
      java.lang.Iterable<? extends com.google.protobuf.ByteString> values) {
    ensureEncryptionKeysIsMutable();
    com.google.protobuf.AbstractMessageLite.addAll(
        values, encryptionKeys_);
  }
  /**
   * <pre>
   * The current encryption keys associated with this account. Will be set if
   * the GetUpdatesMessage in the request had need_encryption_key == true or
   * the server has updated the set of encryption keys (e.g. due to a key
   * rotation).
   * </pre>
   *
   * <code>repeated bytes encryption_keys = 6;</code>
   */
  private void clearEncryptionKeys() {
    encryptionKeys_ = emptyProtobufList();
  }

  public static final int CONTEXT_MUTATIONS_FIELD_NUMBER = 7;
  private com.google.protobuf.Internal.ProtobufList<org.chromium.components.sync.protocol.DataTypeContext> contextMutations_;
  /**
   * <pre>
   * Set of optional datatype contexts server mutations.
   * </pre>
   *
   * <code>repeated .sync_pb.DataTypeContext context_mutations = 7;</code>
   */
  public java.util.List<org.chromium.components.sync.protocol.DataTypeContext> getContextMutationsList() {
    return contextMutations_;
  }
  /**
   * <pre>
   * Set of optional datatype contexts server mutations.
   * </pre>
   *
   * <code>repeated .sync_pb.DataTypeContext context_mutations = 7;</code>
   */
  public java.util.List<? extends org.chromium.components.sync.protocol.DataTypeContextOrBuilder> 
      getContextMutationsOrBuilderList() {
    return contextMutations_;
  }
  /**
   * <pre>
   * Set of optional datatype contexts server mutations.
   * </pre>
   *
   * <code>repeated .sync_pb.DataTypeContext context_mutations = 7;</code>
   */
  public int getContextMutationsCount() {
    return contextMutations_.size();
  }
  /**
   * <pre>
   * Set of optional datatype contexts server mutations.
   * </pre>
   *
   * <code>repeated .sync_pb.DataTypeContext context_mutations = 7;</code>
   */
  public org.chromium.components.sync.protocol.DataTypeContext getContextMutations(int index) {
    return contextMutations_.get(index);
  }
  /**
   * <pre>
   * Set of optional datatype contexts server mutations.
   * </pre>
   *
   * <code>repeated .sync_pb.DataTypeContext context_mutations = 7;</code>
   */
  public org.chromium.components.sync.protocol.DataTypeContextOrBuilder getContextMutationsOrBuilder(
      int index) {
    return contextMutations_.get(index);
  }
  private void ensureContextMutationsIsMutable() {
    if (!contextMutations_.isModifiable()) {
      contextMutations_ =
          com.google.protobuf.GeneratedMessageLite.mutableCopy(contextMutations_);
     }
  }

  /**
   * <pre>
   * Set of optional datatype contexts server mutations.
   * </pre>
   *
   * <code>repeated .sync_pb.DataTypeContext context_mutations = 7;</code>
   */
  private void setContextMutations(
      int index, org.chromium.components.sync.protocol.DataTypeContext value) {
    if (value == null) {
      throw new NullPointerException();
    }
    ensureContextMutationsIsMutable();
    contextMutations_.set(index, value);
  }
  /**
   * <pre>
   * Set of optional datatype contexts server mutations.
   * </pre>
   *
   * <code>repeated .sync_pb.DataTypeContext context_mutations = 7;</code>
   */
  private void setContextMutations(
      int index, org.chromium.components.sync.protocol.DataTypeContext.Builder builderForValue) {
    ensureContextMutationsIsMutable();
    contextMutations_.set(index, builderForValue.build());
  }
  /**
   * <pre>
   * Set of optional datatype contexts server mutations.
   * </pre>
   *
   * <code>repeated .sync_pb.DataTypeContext context_mutations = 7;</code>
   */
  private void addContextMutations(org.chromium.components.sync.protocol.DataTypeContext value) {
    if (value == null) {
      throw new NullPointerException();
    }
    ensureContextMutationsIsMutable();
    contextMutations_.add(value);
  }
  /**
   * <pre>
   * Set of optional datatype contexts server mutations.
   * </pre>
   *
   * <code>repeated .sync_pb.DataTypeContext context_mutations = 7;</code>
   */
  private void addContextMutations(
      int index, org.chromium.components.sync.protocol.DataTypeContext value) {
    if (value == null) {
      throw new NullPointerException();
    }
    ensureContextMutationsIsMutable();
    contextMutations_.add(index, value);
  }
  /**
   * <pre>
   * Set of optional datatype contexts server mutations.
   * </pre>
   *
   * <code>repeated .sync_pb.DataTypeContext context_mutations = 7;</code>
   */
  private void addContextMutations(
      org.chromium.components.sync.protocol.DataTypeContext.Builder builderForValue) {
    ensureContextMutationsIsMutable();
    contextMutations_.add(builderForValue.build());
  }
  /**
   * <pre>
   * Set of optional datatype contexts server mutations.
   * </pre>
   *
   * <code>repeated .sync_pb.DataTypeContext context_mutations = 7;</code>
   */
  private void addContextMutations(
      int index, org.chromium.components.sync.protocol.DataTypeContext.Builder builderForValue) {
    ensureContextMutationsIsMutable();
    contextMutations_.add(index, builderForValue.build());
  }
  /**
   * <pre>
   * Set of optional datatype contexts server mutations.
   * </pre>
   *
   * <code>repeated .sync_pb.DataTypeContext context_mutations = 7;</code>
   */
  private void addAllContextMutations(
      java.lang.Iterable<? extends org.chromium.components.sync.protocol.DataTypeContext> values) {
    ensureContextMutationsIsMutable();
    com.google.protobuf.AbstractMessageLite.addAll(
        values, contextMutations_);
  }
  /**
   * <pre>
   * Set of optional datatype contexts server mutations.
   * </pre>
   *
   * <code>repeated .sync_pb.DataTypeContext context_mutations = 7;</code>
   */
  private void clearContextMutations() {
    contextMutations_ = emptyProtobufList();
  }
  /**
   * <pre>
   * Set of optional datatype contexts server mutations.
   * </pre>
   *
   * <code>repeated .sync_pb.DataTypeContext context_mutations = 7;</code>
   */
  private void removeContextMutations(int index) {
    ensureContextMutationsIsMutable();
    contextMutations_.remove(index);
  }

  public void writeTo(com.google.protobuf.CodedOutputStream output)
                      throws java.io.IOException {
    for (int i = 0; i < entries_.size(); i++) {
      output.writeMessage(1, entries_.get(i));
    }
    if (((bitField0_ & 0x00000001) == 0x00000001)) {
      output.writeInt64(4, changesRemaining_);
    }
    for (int i = 0; i < newProgressMarker_.size(); i++) {
      output.writeMessage(5, newProgressMarker_.get(i));
    }
    for (int i = 0; i < encryptionKeys_.size(); i++) {
      output.writeBytes(6, encryptionKeys_.get(i));
    }
    for (int i = 0; i < contextMutations_.size(); i++) {
      output.writeMessage(7, contextMutations_.get(i));
    }
    unknownFields.writeTo(output);
  }

  public int getSerializedSize() {
    int size = memoizedSerializedSize;
    if (size != -1) return size;

    size = 0;
    for (int i = 0; i < entries_.size(); i++) {
      size += com.google.protobuf.CodedOutputStream
        .computeMessageSize(1, entries_.get(i));
    }
    if (((bitField0_ & 0x00000001) == 0x00000001)) {
      size += com.google.protobuf.CodedOutputStream
        .computeInt64Size(4, changesRemaining_);
    }
    for (int i = 0; i < newProgressMarker_.size(); i++) {
      size += com.google.protobuf.CodedOutputStream
        .computeMessageSize(5, newProgressMarker_.get(i));
    }
    {
      int dataSize = 0;
      for (int i = 0; i < encryptionKeys_.size(); i++) {
        dataSize += com.google.protobuf.CodedOutputStream
          .computeBytesSizeNoTag(encryptionKeys_.get(i));
      }
      size += dataSize;
      size += 1 * getEncryptionKeysList().size();
    }
    for (int i = 0; i < contextMutations_.size(); i++) {
      size += com.google.protobuf.CodedOutputStream
        .computeMessageSize(7, contextMutations_.get(i));
    }
    size += unknownFields.getSerializedSize();
    memoizedSerializedSize = size;
    return size;
  }

  public static org.chromium.components.sync.protocol.GetUpdatesResponse parseFrom(
      com.google.protobuf.ByteString data)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, data);
  }
  public static org.chromium.components.sync.protocol.GetUpdatesResponse parseFrom(
      com.google.protobuf.ByteString data,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, data, extensionRegistry);
  }
  public static org.chromium.components.sync.protocol.GetUpdatesResponse parseFrom(byte[] data)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, data);
  }
  public static org.chromium.components.sync.protocol.GetUpdatesResponse parseFrom(
      byte[] data,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, data, extensionRegistry);
  }
  public static org.chromium.components.sync.protocol.GetUpdatesResponse parseFrom(java.io.InputStream input)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, input);
  }
  public static org.chromium.components.sync.protocol.GetUpdatesResponse parseFrom(
      java.io.InputStream input,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, input, extensionRegistry);
  }
  public static org.chromium.components.sync.protocol.GetUpdatesResponse parseDelimitedFrom(java.io.InputStream input)
      throws java.io.IOException {
    return parseDelimitedFrom(DEFAULT_INSTANCE, input);
  }
  public static org.chromium.components.sync.protocol.GetUpdatesResponse parseDelimitedFrom(
      java.io.InputStream input,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws java.io.IOException {
    return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
  }
  public static org.chromium.components.sync.protocol.GetUpdatesResponse parseFrom(
      com.google.protobuf.CodedInputStream input)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, input);
  }
  public static org.chromium.components.sync.protocol.GetUpdatesResponse parseFrom(
      com.google.protobuf.CodedInputStream input,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, input, extensionRegistry);
  }

  public static Builder newBuilder() {
    return DEFAULT_INSTANCE.toBuilder();
  }
  public static Builder newBuilder(org.chromium.components.sync.protocol.GetUpdatesResponse prototype) {
    return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
  }

  /**
   * Protobuf type {@code sync_pb.GetUpdatesResponse}
   */
  public static final class Builder extends
      com.google.protobuf.GeneratedMessageLite.Builder<
        org.chromium.components.sync.protocol.GetUpdatesResponse, Builder> implements
      // @@protoc_insertion_point(builder_implements:sync_pb.GetUpdatesResponse)
      org.chromium.components.sync.protocol.GetUpdatesResponseOrBuilder {
    // Construct using org.chromium.components.sync.protocol.GetUpdatesResponse.newBuilder()
    private Builder() {
      super(DEFAULT_INSTANCE);
    }


    /**
     * <pre>
     * New sync entries that the client should apply.
     * </pre>
     *
     * <code>repeated .sync_pb.SyncEntity entries = 1;</code>
     */
    public java.util.List<org.chromium.components.sync.protocol.SyncEntity> getEntriesList() {
      return java.util.Collections.unmodifiableList(
          instance.getEntriesList());
    }
    /**
     * <pre>
     * New sync entries that the client should apply.
     * </pre>
     *
     * <code>repeated .sync_pb.SyncEntity entries = 1;</code>
     */
    public int getEntriesCount() {
      return instance.getEntriesCount();
    }/**
     * <pre>
     * New sync entries that the client should apply.
     * </pre>
     *
     * <code>repeated .sync_pb.SyncEntity entries = 1;</code>
     */
    public org.chromium.components.sync.protocol.SyncEntity getEntries(int index) {
      return instance.getEntries(index);
    }
    /**
     * <pre>
     * New sync entries that the client should apply.
     * </pre>
     *
     * <code>repeated .sync_pb.SyncEntity entries = 1;</code>
     */
    public Builder setEntries(
        int index, org.chromium.components.sync.protocol.SyncEntity value) {
      copyOnWrite();
      instance.setEntries(index, value);
      return this;
    }
    /**
     * <pre>
     * New sync entries that the client should apply.
     * </pre>
     *
     * <code>repeated .sync_pb.SyncEntity entries = 1;</code>
     */
    public Builder setEntries(
        int index, org.chromium.components.sync.protocol.SyncEntity.Builder builderForValue) {
      copyOnWrite();
      instance.setEntries(index, builderForValue);
      return this;
    }
    /**
     * <pre>
     * New sync entries that the client should apply.
     * </pre>
     *
     * <code>repeated .sync_pb.SyncEntity entries = 1;</code>
     */
    public Builder addEntries(org.chromium.components.sync.protocol.SyncEntity value) {
      copyOnWrite();
      instance.addEntries(value);
      return this;
    }
    /**
     * <pre>
     * New sync entries that the client should apply.
     * </pre>
     *
     * <code>repeated .sync_pb.SyncEntity entries = 1;</code>
     */
    public Builder addEntries(
        int index, org.chromium.components.sync.protocol.SyncEntity value) {
      copyOnWrite();
      instance.addEntries(index, value);
      return this;
    }
    /**
     * <pre>
     * New sync entries that the client should apply.
     * </pre>
     *
     * <code>repeated .sync_pb.SyncEntity entries = 1;</code>
     */
    public Builder addEntries(
        org.chromium.components.sync.protocol.SyncEntity.Builder builderForValue) {
      copyOnWrite();
      instance.addEntries(builderForValue);
      return this;
    }
    /**
     * <pre>
     * New sync entries that the client should apply.
     * </pre>
     *
     * <code>repeated .sync_pb.SyncEntity entries = 1;</code>
     */
    public Builder addEntries(
        int index, org.chromium.components.sync.protocol.SyncEntity.Builder builderForValue) {
      copyOnWrite();
      instance.addEntries(index, builderForValue);
      return this;
    }
    /**
     * <pre>
     * New sync entries that the client should apply.
     * </pre>
     *
     * <code>repeated .sync_pb.SyncEntity entries = 1;</code>
     */
    public Builder addAllEntries(
        java.lang.Iterable<? extends org.chromium.components.sync.protocol.SyncEntity> values) {
      copyOnWrite();
      instance.addAllEntries(values);
      return this;
    }
    /**
     * <pre>
     * New sync entries that the client should apply.
     * </pre>
     *
     * <code>repeated .sync_pb.SyncEntity entries = 1;</code>
     */
    public Builder clearEntries() {
      copyOnWrite();
      instance.clearEntries();
      return this;
    }
    /**
     * <pre>
     * New sync entries that the client should apply.
     * </pre>
     *
     * <code>repeated .sync_pb.SyncEntity entries = 1;</code>
     */
    public Builder removeEntries(int index) {
      copyOnWrite();
      instance.removeEntries(index);
      return this;
    }

    /**
     * <pre>
     * Approximate count of changes remaining - use this for UI feedback.
     * If present and zero, this estimate is firm: the server has no changes
     * after the current batch.
     * </pre>
     *
     * <code>optional int64 changes_remaining = 4;</code>
     */
    public boolean hasChangesRemaining() {
      return instance.hasChangesRemaining();
    }
    /**
     * <pre>
     * Approximate count of changes remaining - use this for UI feedback.
     * If present and zero, this estimate is firm: the server has no changes
     * after the current batch.
     * </pre>
     *
     * <code>optional int64 changes_remaining = 4;</code>
     */
    public long getChangesRemaining() {
      return instance.getChangesRemaining();
    }
    /**
     * <pre>
     * Approximate count of changes remaining - use this for UI feedback.
     * If present and zero, this estimate is firm: the server has no changes
     * after the current batch.
     * </pre>
     *
     * <code>optional int64 changes_remaining = 4;</code>
     */
    public Builder setChangesRemaining(long value) {
      copyOnWrite();
      instance.setChangesRemaining(value);
      return this;
    }
    /**
     * <pre>
     * Approximate count of changes remaining - use this for UI feedback.
     * If present and zero, this estimate is firm: the server has no changes
     * after the current batch.
     * </pre>
     *
     * <code>optional int64 changes_remaining = 4;</code>
     */
    public Builder clearChangesRemaining() {
      copyOnWrite();
      instance.clearChangesRemaining();
      return this;
    }

    /**
     * <pre>
     * Opaque, per-datatype timestamp-like tokens.  Clients should retain and
     * persist the values returned in this field, and present them back to the
     * server to indicate the starting point for future update requests.
     * This will be sent only if the client provided |from_progress_marker|
     * in the update request.
     * The server may provide a new progress marker even if this is the end of
     * the batch, or if there were no new updates on the server; and the client
     * must save these.  If the server does not provide a |new_progress_marker|
     * value for a particular datatype, when the request provided a
     * |from_progress_marker| value for that datatype, the client should
     * interpret this to mean "no change from the previous state" and retain its
     * previous progress-marker value for that datatype.
     * Progress markers in the context of a response will never have the
     * |timestamp_token_for_migration| field set.
     * </pre>
     *
     * <code>repeated .sync_pb.DataTypeProgressMarker new_progress_marker = 5;</code>
     */
    public java.util.List<org.chromium.components.sync.protocol.DataTypeProgressMarker> getNewProgressMarkerList() {
      return java.util.Collections.unmodifiableList(
          instance.getNewProgressMarkerList());
    }
    /**
     * <pre>
     * Opaque, per-datatype timestamp-like tokens.  Clients should retain and
     * persist the values returned in this field, and present them back to the
     * server to indicate the starting point for future update requests.
     * This will be sent only if the client provided |from_progress_marker|
     * in the update request.
     * The server may provide a new progress marker even if this is the end of
     * the batch, or if there were no new updates on the server; and the client
     * must save these.  If the server does not provide a |new_progress_marker|
     * value for a particular datatype, when the request provided a
     * |from_progress_marker| value for that datatype, the client should
     * interpret this to mean "no change from the previous state" and retain its
     * previous progress-marker value for that datatype.
     * Progress markers in the context of a response will never have the
     * |timestamp_token_for_migration| field set.
     * </pre>
     *
     * <code>repeated .sync_pb.DataTypeProgressMarker new_progress_marker = 5;</code>
     */
    public int getNewProgressMarkerCount() {
      return instance.getNewProgressMarkerCount();
    }/**
     * <pre>
     * Opaque, per-datatype timestamp-like tokens.  Clients should retain and
     * persist the values returned in this field, and present them back to the
     * server to indicate the starting point for future update requests.
     * This will be sent only if the client provided |from_progress_marker|
     * in the update request.
     * The server may provide a new progress marker even if this is the end of
     * the batch, or if there were no new updates on the server; and the client
     * must save these.  If the server does not provide a |new_progress_marker|
     * value for a particular datatype, when the request provided a
     * |from_progress_marker| value for that datatype, the client should
     * interpret this to mean "no change from the previous state" and retain its
     * previous progress-marker value for that datatype.
     * Progress markers in the context of a response will never have the
     * |timestamp_token_for_migration| field set.
     * </pre>
     *
     * <code>repeated .sync_pb.DataTypeProgressMarker new_progress_marker = 5;</code>
     */
    public org.chromium.components.sync.protocol.DataTypeProgressMarker getNewProgressMarker(int index) {
      return instance.getNewProgressMarker(index);
    }
    /**
     * <pre>
     * Opaque, per-datatype timestamp-like tokens.  Clients should retain and
     * persist the values returned in this field, and present them back to the
     * server to indicate the starting point for future update requests.
     * This will be sent only if the client provided |from_progress_marker|
     * in the update request.
     * The server may provide a new progress marker even if this is the end of
     * the batch, or if there were no new updates on the server; and the client
     * must save these.  If the server does not provide a |new_progress_marker|
     * value for a particular datatype, when the request provided a
     * |from_progress_marker| value for that datatype, the client should
     * interpret this to mean "no change from the previous state" and retain its
     * previous progress-marker value for that datatype.
     * Progress markers in the context of a response will never have the
     * |timestamp_token_for_migration| field set.
     * </pre>
     *
     * <code>repeated .sync_pb.DataTypeProgressMarker new_progress_marker = 5;</code>
     */
    public Builder setNewProgressMarker(
        int index, org.chromium.components.sync.protocol.DataTypeProgressMarker value) {
      copyOnWrite();
      instance.setNewProgressMarker(index, value);
      return this;
    }
    /**
     * <pre>
     * Opaque, per-datatype timestamp-like tokens.  Clients should retain and
     * persist the values returned in this field, and present them back to the
     * server to indicate the starting point for future update requests.
     * This will be sent only if the client provided |from_progress_marker|
     * in the update request.
     * The server may provide a new progress marker even if this is the end of
     * the batch, or if there were no new updates on the server; and the client
     * must save these.  If the server does not provide a |new_progress_marker|
     * value for a particular datatype, when the request provided a
     * |from_progress_marker| value for that datatype, the client should
     * interpret this to mean "no change from the previous state" and retain its
     * previous progress-marker value for that datatype.
     * Progress markers in the context of a response will never have the
     * |timestamp_token_for_migration| field set.
     * </pre>
     *
     * <code>repeated .sync_pb.DataTypeProgressMarker new_progress_marker = 5;</code>
     */
    public Builder setNewProgressMarker(
        int index, org.chromium.components.sync.protocol.DataTypeProgressMarker.Builder builderForValue) {
      copyOnWrite();
      instance.setNewProgressMarker(index, builderForValue);
      return this;
    }
    /**
     * <pre>
     * Opaque, per-datatype timestamp-like tokens.  Clients should retain and
     * persist the values returned in this field, and present them back to the
     * server to indicate the starting point for future update requests.
     * This will be sent only if the client provided |from_progress_marker|
     * in the update request.
     * The server may provide a new progress marker even if this is the end of
     * the batch, or if there were no new updates on the server; and the client
     * must save these.  If the server does not provide a |new_progress_marker|
     * value for a particular datatype, when the request provided a
     * |from_progress_marker| value for that datatype, the client should
     * interpret this to mean "no change from the previous state" and retain its
     * previous progress-marker value for that datatype.
     * Progress markers in the context of a response will never have the
     * |timestamp_token_for_migration| field set.
     * </pre>
     *
     * <code>repeated .sync_pb.DataTypeProgressMarker new_progress_marker = 5;</code>
     */
    public Builder addNewProgressMarker(org.chromium.components.sync.protocol.DataTypeProgressMarker value) {
      copyOnWrite();
      instance.addNewProgressMarker(value);
      return this;
    }
    /**
     * <pre>
     * Opaque, per-datatype timestamp-like tokens.  Clients should retain and
     * persist the values returned in this field, and present them back to the
     * server to indicate the starting point for future update requests.
     * This will be sent only if the client provided |from_progress_marker|
     * in the update request.
     * The server may provide a new progress marker even if this is the end of
     * the batch, or if there were no new updates on the server; and the client
     * must save these.  If the server does not provide a |new_progress_marker|
     * value for a particular datatype, when the request provided a
     * |from_progress_marker| value for that datatype, the client should
     * interpret this to mean "no change from the previous state" and retain its
     * previous progress-marker value for that datatype.
     * Progress markers in the context of a response will never have the
     * |timestamp_token_for_migration| field set.
     * </pre>
     *
     * <code>repeated .sync_pb.DataTypeProgressMarker new_progress_marker = 5;</code>
     */
    public Builder addNewProgressMarker(
        int index, org.chromium.components.sync.protocol.DataTypeProgressMarker value) {
      copyOnWrite();
      instance.addNewProgressMarker(index, value);
      return this;
    }
    /**
     * <pre>
     * Opaque, per-datatype timestamp-like tokens.  Clients should retain and
     * persist the values returned in this field, and present them back to the
     * server to indicate the starting point for future update requests.
     * This will be sent only if the client provided |from_progress_marker|
     * in the update request.
     * The server may provide a new progress marker even if this is the end of
     * the batch, or if there were no new updates on the server; and the client
     * must save these.  If the server does not provide a |new_progress_marker|
     * value for a particular datatype, when the request provided a
     * |from_progress_marker| value for that datatype, the client should
     * interpret this to mean "no change from the previous state" and retain its
     * previous progress-marker value for that datatype.
     * Progress markers in the context of a response will never have the
     * |timestamp_token_for_migration| field set.
     * </pre>
     *
     * <code>repeated .sync_pb.DataTypeProgressMarker new_progress_marker = 5;</code>
     */
    public Builder addNewProgressMarker(
        org.chromium.components.sync.protocol.DataTypeProgressMarker.Builder builderForValue) {
      copyOnWrite();
      instance.addNewProgressMarker(builderForValue);
      return this;
    }
    /**
     * <pre>
     * Opaque, per-datatype timestamp-like tokens.  Clients should retain and
     * persist the values returned in this field, and present them back to the
     * server to indicate the starting point for future update requests.
     * This will be sent only if the client provided |from_progress_marker|
     * in the update request.
     * The server may provide a new progress marker even if this is the end of
     * the batch, or if there were no new updates on the server; and the client
     * must save these.  If the server does not provide a |new_progress_marker|
     * value for a particular datatype, when the request provided a
     * |from_progress_marker| value for that datatype, the client should
     * interpret this to mean "no change from the previous state" and retain its
     * previous progress-marker value for that datatype.
     * Progress markers in the context of a response will never have the
     * |timestamp_token_for_migration| field set.
     * </pre>
     *
     * <code>repeated .sync_pb.DataTypeProgressMarker new_progress_marker = 5;</code>
     */
    public Builder addNewProgressMarker(
        int index, org.chromium.components.sync.protocol.DataTypeProgressMarker.Builder builderForValue) {
      copyOnWrite();
      instance.addNewProgressMarker(index, builderForValue);
      return this;
    }
    /**
     * <pre>
     * Opaque, per-datatype timestamp-like tokens.  Clients should retain and
     * persist the values returned in this field, and present them back to the
     * server to indicate the starting point for future update requests.
     * This will be sent only if the client provided |from_progress_marker|
     * in the update request.
     * The server may provide a new progress marker even if this is the end of
     * the batch, or if there were no new updates on the server; and the client
     * must save these.  If the server does not provide a |new_progress_marker|
     * value for a particular datatype, when the request provided a
     * |from_progress_marker| value for that datatype, the client should
     * interpret this to mean "no change from the previous state" and retain its
     * previous progress-marker value for that datatype.
     * Progress markers in the context of a response will never have the
     * |timestamp_token_for_migration| field set.
     * </pre>
     *
     * <code>repeated .sync_pb.DataTypeProgressMarker new_progress_marker = 5;</code>
     */
    public Builder addAllNewProgressMarker(
        java.lang.Iterable<? extends org.chromium.components.sync.protocol.DataTypeProgressMarker> values) {
      copyOnWrite();
      instance.addAllNewProgressMarker(values);
      return this;
    }
    /**
     * <pre>
     * Opaque, per-datatype timestamp-like tokens.  Clients should retain and
     * persist the values returned in this field, and present them back to the
     * server to indicate the starting point for future update requests.
     * This will be sent only if the client provided |from_progress_marker|
     * in the update request.
     * The server may provide a new progress marker even if this is the end of
     * the batch, or if there were no new updates on the server; and the client
     * must save these.  If the server does not provide a |new_progress_marker|
     * value for a particular datatype, when the request provided a
     * |from_progress_marker| value for that datatype, the client should
     * interpret this to mean "no change from the previous state" and retain its
     * previous progress-marker value for that datatype.
     * Progress markers in the context of a response will never have the
     * |timestamp_token_for_migration| field set.
     * </pre>
     *
     * <code>repeated .sync_pb.DataTypeProgressMarker new_progress_marker = 5;</code>
     */
    public Builder clearNewProgressMarker() {
      copyOnWrite();
      instance.clearNewProgressMarker();
      return this;
    }
    /**
     * <pre>
     * Opaque, per-datatype timestamp-like tokens.  Clients should retain and
     * persist the values returned in this field, and present them back to the
     * server to indicate the starting point for future update requests.
     * This will be sent only if the client provided |from_progress_marker|
     * in the update request.
     * The server may provide a new progress marker even if this is the end of
     * the batch, or if there were no new updates on the server; and the client
     * must save these.  If the server does not provide a |new_progress_marker|
     * value for a particular datatype, when the request provided a
     * |from_progress_marker| value for that datatype, the client should
     * interpret this to mean "no change from the previous state" and retain its
     * previous progress-marker value for that datatype.
     * Progress markers in the context of a response will never have the
     * |timestamp_token_for_migration| field set.
     * </pre>
     *
     * <code>repeated .sync_pb.DataTypeProgressMarker new_progress_marker = 5;</code>
     */
    public Builder removeNewProgressMarker(int index) {
      copyOnWrite();
      instance.removeNewProgressMarker(index);
      return this;
    }

    /**
     * <pre>
     * The current encryption keys associated with this account. Will be set if
     * the GetUpdatesMessage in the request had need_encryption_key == true or
     * the server has updated the set of encryption keys (e.g. due to a key
     * rotation).
     * </pre>
     *
     * <code>repeated bytes encryption_keys = 6;</code>
     */
    public java.util.List<com.google.protobuf.ByteString>
        getEncryptionKeysList() {
      return java.util.Collections.unmodifiableList(
          instance.getEncryptionKeysList());
    }
    /**
     * <pre>
     * The current encryption keys associated with this account. Will be set if
     * the GetUpdatesMessage in the request had need_encryption_key == true or
     * the server has updated the set of encryption keys (e.g. due to a key
     * rotation).
     * </pre>
     *
     * <code>repeated bytes encryption_keys = 6;</code>
     */
    public int getEncryptionKeysCount() {
      return instance.getEncryptionKeysCount();
    }
    /**
     * <pre>
     * The current encryption keys associated with this account. Will be set if
     * the GetUpdatesMessage in the request had need_encryption_key == true or
     * the server has updated the set of encryption keys (e.g. due to a key
     * rotation).
     * </pre>
     *
     * <code>repeated bytes encryption_keys = 6;</code>
     */
    public com.google.protobuf.ByteString getEncryptionKeys(int index) {
      return instance.getEncryptionKeys(index);
    }
    /**
     * <pre>
     * The current encryption keys associated with this account. Will be set if
     * the GetUpdatesMessage in the request had need_encryption_key == true or
     * the server has updated the set of encryption keys (e.g. due to a key
     * rotation).
     * </pre>
     *
     * <code>repeated bytes encryption_keys = 6;</code>
     */
    public Builder setEncryptionKeys(
        int index, com.google.protobuf.ByteString value) {
      copyOnWrite();
      instance.setEncryptionKeys(index, value);
      return this;
    }
    /**
     * <pre>
     * The current encryption keys associated with this account. Will be set if
     * the GetUpdatesMessage in the request had need_encryption_key == true or
     * the server has updated the set of encryption keys (e.g. due to a key
     * rotation).
     * </pre>
     *
     * <code>repeated bytes encryption_keys = 6;</code>
     */
    public Builder addEncryptionKeys(com.google.protobuf.ByteString value) {
      copyOnWrite();
      instance.addEncryptionKeys(value);
      return this;
    }
    /**
     * <pre>
     * The current encryption keys associated with this account. Will be set if
     * the GetUpdatesMessage in the request had need_encryption_key == true or
     * the server has updated the set of encryption keys (e.g. due to a key
     * rotation).
     * </pre>
     *
     * <code>repeated bytes encryption_keys = 6;</code>
     */
    public Builder addAllEncryptionKeys(
        java.lang.Iterable<? extends com.google.protobuf.ByteString> values) {
      copyOnWrite();
      instance.addAllEncryptionKeys(values);
      return this;
    }
    /**
     * <pre>
     * The current encryption keys associated with this account. Will be set if
     * the GetUpdatesMessage in the request had need_encryption_key == true or
     * the server has updated the set of encryption keys (e.g. due to a key
     * rotation).
     * </pre>
     *
     * <code>repeated bytes encryption_keys = 6;</code>
     */
    public Builder clearEncryptionKeys() {
      copyOnWrite();
      instance.clearEncryptionKeys();
      return this;
    }

    /**
     * <pre>
     * Set of optional datatype contexts server mutations.
     * </pre>
     *
     * <code>repeated .sync_pb.DataTypeContext context_mutations = 7;</code>
     */
    public java.util.List<org.chromium.components.sync.protocol.DataTypeContext> getContextMutationsList() {
      return java.util.Collections.unmodifiableList(
          instance.getContextMutationsList());
    }
    /**
     * <pre>
     * Set of optional datatype contexts server mutations.
     * </pre>
     *
     * <code>repeated .sync_pb.DataTypeContext context_mutations = 7;</code>
     */
    public int getContextMutationsCount() {
      return instance.getContextMutationsCount();
    }/**
     * <pre>
     * Set of optional datatype contexts server mutations.
     * </pre>
     *
     * <code>repeated .sync_pb.DataTypeContext context_mutations = 7;</code>
     */
    public org.chromium.components.sync.protocol.DataTypeContext getContextMutations(int index) {
      return instance.getContextMutations(index);
    }
    /**
     * <pre>
     * Set of optional datatype contexts server mutations.
     * </pre>
     *
     * <code>repeated .sync_pb.DataTypeContext context_mutations = 7;</code>
     */
    public Builder setContextMutations(
        int index, org.chromium.components.sync.protocol.DataTypeContext value) {
      copyOnWrite();
      instance.setContextMutations(index, value);
      return this;
    }
    /**
     * <pre>
     * Set of optional datatype contexts server mutations.
     * </pre>
     *
     * <code>repeated .sync_pb.DataTypeContext context_mutations = 7;</code>
     */
    public Builder setContextMutations(
        int index, org.chromium.components.sync.protocol.DataTypeContext.Builder builderForValue) {
      copyOnWrite();
      instance.setContextMutations(index, builderForValue);
      return this;
    }
    /**
     * <pre>
     * Set of optional datatype contexts server mutations.
     * </pre>
     *
     * <code>repeated .sync_pb.DataTypeContext context_mutations = 7;</code>
     */
    public Builder addContextMutations(org.chromium.components.sync.protocol.DataTypeContext value) {
      copyOnWrite();
      instance.addContextMutations(value);
      return this;
    }
    /**
     * <pre>
     * Set of optional datatype contexts server mutations.
     * </pre>
     *
     * <code>repeated .sync_pb.DataTypeContext context_mutations = 7;</code>
     */
    public Builder addContextMutations(
        int index, org.chromium.components.sync.protocol.DataTypeContext value) {
      copyOnWrite();
      instance.addContextMutations(index, value);
      return this;
    }
    /**
     * <pre>
     * Set of optional datatype contexts server mutations.
     * </pre>
     *
     * <code>repeated .sync_pb.DataTypeContext context_mutations = 7;</code>
     */
    public Builder addContextMutations(
        org.chromium.components.sync.protocol.DataTypeContext.Builder builderForValue) {
      copyOnWrite();
      instance.addContextMutations(builderForValue);
      return this;
    }
    /**
     * <pre>
     * Set of optional datatype contexts server mutations.
     * </pre>
     *
     * <code>repeated .sync_pb.DataTypeContext context_mutations = 7;</code>
     */
    public Builder addContextMutations(
        int index, org.chromium.components.sync.protocol.DataTypeContext.Builder builderForValue) {
      copyOnWrite();
      instance.addContextMutations(index, builderForValue);
      return this;
    }
    /**
     * <pre>
     * Set of optional datatype contexts server mutations.
     * </pre>
     *
     * <code>repeated .sync_pb.DataTypeContext context_mutations = 7;</code>
     */
    public Builder addAllContextMutations(
        java.lang.Iterable<? extends org.chromium.components.sync.protocol.DataTypeContext> values) {
      copyOnWrite();
      instance.addAllContextMutations(values);
      return this;
    }
    /**
     * <pre>
     * Set of optional datatype contexts server mutations.
     * </pre>
     *
     * <code>repeated .sync_pb.DataTypeContext context_mutations = 7;</code>
     */
    public Builder clearContextMutations() {
      copyOnWrite();
      instance.clearContextMutations();
      return this;
    }
    /**
     * <pre>
     * Set of optional datatype contexts server mutations.
     * </pre>
     *
     * <code>repeated .sync_pb.DataTypeContext context_mutations = 7;</code>
     */
    public Builder removeContextMutations(int index) {
      copyOnWrite();
      instance.removeContextMutations(index);
      return this;
    }

    // @@protoc_insertion_point(builder_scope:sync_pb.GetUpdatesResponse)
  }
  protected final Object dynamicMethod(
      com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
      Object arg0, Object arg1) {
    switch (method) {
      case NEW_MUTABLE_INSTANCE: {
        return new org.chromium.components.sync.protocol.GetUpdatesResponse();
      }
      case IS_INITIALIZED: {
        return DEFAULT_INSTANCE;
      }
      case MAKE_IMMUTABLE: {
        entries_.makeImmutable();
        newProgressMarker_.makeImmutable();
        encryptionKeys_.makeImmutable();
        contextMutations_.makeImmutable();
        return null;
      }
      case NEW_BUILDER: {
        return new Builder();
      }
      case VISIT: {
        Visitor visitor = (Visitor) arg0;
        org.chromium.components.sync.protocol.GetUpdatesResponse other = (org.chromium.components.sync.protocol.GetUpdatesResponse) arg1;
        entries_= visitor.visitList(entries_, other.entries_);
        changesRemaining_ = visitor.visitLong(
            hasChangesRemaining(), changesRemaining_,
            other.hasChangesRemaining(), other.changesRemaining_);
        newProgressMarker_= visitor.visitList(newProgressMarker_, other.newProgressMarker_);
        encryptionKeys_= visitor.visitList(encryptionKeys_, other.encryptionKeys_);
        contextMutations_= visitor.visitList(contextMutations_, other.contextMutations_);
        if (visitor == com.google.protobuf.GeneratedMessageLite.MergeFromVisitor
            .INSTANCE) {
          bitField0_ |= other.bitField0_;
        }
        return this;
      }
      case MERGE_FROM_STREAM: {
        com.google.protobuf.CodedInputStream input =
            (com.google.protobuf.CodedInputStream) arg0;
        com.google.protobuf.ExtensionRegistryLite extensionRegistry =
            (com.google.protobuf.ExtensionRegistryLite) arg1;
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              default: {
                if (!parseUnknownField(tag, input)) {
                  done = true;
                }
                break;
              }
              case 10: {
                if (!entries_.isModifiable()) {
                  entries_ =
                      com.google.protobuf.GeneratedMessageLite.mutableCopy(entries_);
                }
                entries_.add(
                    input.readMessage(org.chromium.components.sync.protocol.SyncEntity.parser(), extensionRegistry));
                break;
              }
              case 32: {
                bitField0_ |= 0x00000001;
                changesRemaining_ = input.readInt64();
                break;
              }
              case 42: {
                if (!newProgressMarker_.isModifiable()) {
                  newProgressMarker_ =
                      com.google.protobuf.GeneratedMessageLite.mutableCopy(newProgressMarker_);
                }
                newProgressMarker_.add(
                    input.readMessage(org.chromium.components.sync.protocol.DataTypeProgressMarker.parser(), extensionRegistry));
                break;
              }
              case 50: {
                if (!encryptionKeys_.isModifiable()) {
                  encryptionKeys_ =
                      com.google.protobuf.GeneratedMessageLite.mutableCopy(encryptionKeys_);
                }
                encryptionKeys_.add(input.readBytes());
                break;
              }
              case 58: {
                if (!contextMutations_.isModifiable()) {
                  contextMutations_ =
                      com.google.protobuf.GeneratedMessageLite.mutableCopy(contextMutations_);
                }
                contextMutations_.add(
                    input.readMessage(org.chromium.components.sync.protocol.DataTypeContext.parser(), extensionRegistry));
                break;
              }
            }
          }
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw new RuntimeException(e.setUnfinishedMessage(this));
        } catch (java.io.IOException e) {
          throw new RuntimeException(
              new com.google.protobuf.InvalidProtocolBufferException(
                  e.getMessage()).setUnfinishedMessage(this));
        } finally {
        }
      }
      case GET_DEFAULT_INSTANCE: {
        return DEFAULT_INSTANCE;
      }
      case GET_PARSER: {
        if (PARSER == null) {    synchronized (org.chromium.components.sync.protocol.GetUpdatesResponse.class) {
            if (PARSER == null) {
              PARSER = new DefaultInstanceBasedParser(DEFAULT_INSTANCE);
            }
          }
        }
        return PARSER;
      }
    }
    throw new UnsupportedOperationException();
  }


  // @@protoc_insertion_point(class_scope:sync_pb.GetUpdatesResponse)
  private static final org.chromium.components.sync.protocol.GetUpdatesResponse DEFAULT_INSTANCE;
  static {
    DEFAULT_INSTANCE = new GetUpdatesResponse();
    DEFAULT_INSTANCE.makeImmutable();
  }

  public static org.chromium.components.sync.protocol.GetUpdatesResponse getDefaultInstance() {
    return DEFAULT_INSTANCE;
  }

  private static volatile com.google.protobuf.Parser<GetUpdatesResponse> PARSER;

  public static com.google.protobuf.Parser<GetUpdatesResponse> parser() {
    return DEFAULT_INSTANCE.getParserForType();
  }
}

